{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction NEM Library is a layer on top of NEM Blockchain to handle the inner complexity and help creating robust NEM Applications. Source Code Repository on GitHub stable version 1.1.0 Check the npm repostory for the latest updates Installation npm install nem-library rxjs@5 --save NEM Library is build with TypeScript Language , so be sure that you have the latest version installed. We recommend to use TypeScript instead of JavaScript for building applications for NEM Blockchain due the type system and how the nem-library is meant to be used, without counting other great benefits that TypeScript provides. npm install -g typescript MINIMUM TypeScript version 2.5.X Platforms supported Platform Version TypeScript >= 2.5.0 NodeJS >= 6.11.1 (but 8.x.x is recommended) Angular >= 4.2 Ionic >= 4.0 Firefox >= 53.0 Chrome >= 58.0.3029.81 Chromium >= 59.0.3071.86 Opera >= 46.0.2597.46 Edge >= 40.15063.0.0 Safari >= 10.0 Android >= 5.0.0 iOS >= 9.3.5 Because of Ionic generates mobile applications, Android and iOS, the support is provided. Remark that Windows Phone is not supported yet. TypeScript compiler options Until nem-library upgrade into RxJS 6.0 , \"noStrictGenericChecks\" has to be set to true in tsconfig.json file. { \"compilerOptions\": { // ... \"noStrictGenericChecks\": true } } Usage THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Changelog 1.0.0 NEM Library version promoted into stable version. 0.10.0 BREAKING CHANGES AccountHttp : pagination replaced function arguements by QueryParams 0.9.0 BREAKING CHANGES TransferTransaction : amount and mosaic fields are now private, you have to use xem() and mosaic() methods instead AccountHttp : replaced function arguements by QueryParams & changed the order of the params in some cases NEW FEATURES TransferTransaction : added containMosaic method to verify if the Transfer Transaction contains mosaics Address now accepts lowercase MosaicId.toString() returns the same as MosaicId.description() 0.8.2 QRService: Added address and transaction generate and decrypt QR code 0.8.0 Wallet: Added unlockPrivateKey(password: Password): string method. Created QRService 0.7.0 Added statics to XEM Mosaic model Added optional levy to MosaicTransferable Created MosaicService to calculate levy value of a Mosaic MosaicId has equals & description methods FIXED issue TransferTransaction. When sending mosaics and message wrong fee calculation. 0.6.0 Connection Pool Created AccountOwnedMosaicService FIXED issue with Mosaics. Now a Mosaic can be created without a Levy 0.5.1 BREAKING CHANGES Where you had XEM(3) now you should add the new apperator first -> new XEM(3) Where you had mosaicHttp.getMosaicDefinitions , now you should call mosaicHttp.getAllMosaicsGivenNamespace NEW FEATURES TransactionHttp: Added getByHash method that returns a particular Transaction BrainPassword must be at least a 12 word password to avoid collitions SimpleWallet has readFromWLT & writeWLTFile methods to persist it BrainWallet has readFromWLT & writeWLTFile methods to persist it Wallet has static walletTypeGivenWLT(wlt: string): WalletType method Created WalletType enum MosaicHttp added getMosaicDefinition method MosaicHttp added getMosaicTransferableWithAmount method Created EcobitEco Mosaic model Created DimToken Mosaic model Created DimCoin Mosaic model 0.4.0 Pagable extends Subject OutgoingTransactionsPageable extends Pageable<> AllTransactionsPageable extends Pageable<> Account decryptMessage method now returns PlainMessage: No compatible with previus version ProvisionNamespaceTransaction added static createSub(timeWindow: TimeWindow, parentNamespace: string, newNamespaceName: string): ProvisionNamespaceTransaction; ProvisionNamespaceTransaction added static method createRoot(timeWindow: TimeWindow, namespaceName: string): ProvisionNamespaceTransaction; PlainMessage return the text decoded if it is encoded in UTF8, else plain payload 0.3.8 Listeners allow HTTPS protocol 0.3.7 Compiled JS is es5 Address trims the input 0.3.6 Released 29 July 2017 FIXED Listeners reconnection 0.3.5 Released 28 July 2017 FIXED ConfirmedTransactionListener: It emitted the same object three times. 0.3.4 Released 26 July 2017 AccountHttp.allTransactions : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.allTransactionsPaginated : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.incomingTransactions : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.incomingTransactionsPaginated : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.outgoingTransactions : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.outgoingTransactionsPaginated : Accepts pageSize as optional parameter. Between 5 and 100, default 10 0.3.3 Released 26 July 2017 Exported interface Pageable 0.3.2 Released 26 July 2017 FIX Listeners on Browsers Transaction Model : Changed signer field type from string to Public Account Block Model : Changed signer field type from string to Public Account NodeIdentity Model : Replaced publickey: string field to publicAccount: PublicAccount 0.3.1 Released 24 July 2017 0.3.0-RC4 Encrypted Message 0.3.0-RC1 Pagination Listeners Wallets 0.2.34 Stable version","title":"Home"},{"location":"#introduction","text":"NEM Library is a layer on top of NEM Blockchain to handle the inner complexity and help creating robust NEM Applications. Source Code Repository on GitHub","title":"Introduction"},{"location":"#stable-version-110","text":"Check the npm repostory for the latest updates","title":"stable version 1.1.0"},{"location":"#installation","text":"npm install nem-library rxjs@5 --save NEM Library is build with TypeScript Language , so be sure that you have the latest version installed. We recommend to use TypeScript instead of JavaScript for building applications for NEM Blockchain due the type system and how the nem-library is meant to be used, without counting other great benefits that TypeScript provides. npm install -g typescript MINIMUM TypeScript version 2.5.X","title":"Installation"},{"location":"#platforms-supported","text":"Platform Version TypeScript >= 2.5.0 NodeJS >= 6.11.1 (but 8.x.x is recommended) Angular >= 4.2 Ionic >= 4.0 Firefox >= 53.0 Chrome >= 58.0.3029.81 Chromium >= 59.0.3071.86 Opera >= 46.0.2597.46 Edge >= 40.15063.0.0 Safari >= 10.0 Android >= 5.0.0 iOS >= 9.3.5 Because of Ionic generates mobile applications, Android and iOS, the support is provided. Remark that Windows Phone is not supported yet.","title":"Platforms supported"},{"location":"#typescript-compiler-options","text":"Until nem-library upgrade into RxJS 6.0 , \"noStrictGenericChecks\" has to be set to true in tsconfig.json file. { \"compilerOptions\": { // ... \"noStrictGenericChecks\": true } }","title":"TypeScript compiler options"},{"location":"#usage","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Usage"},{"location":"#changelog","text":"","title":"Changelog"},{"location":"#100","text":"NEM Library version promoted into stable version.","title":"1.0.0"},{"location":"#0100","text":"BREAKING CHANGES AccountHttp : pagination replaced function arguements by QueryParams","title":"0.10.0"},{"location":"#090","text":"BREAKING CHANGES TransferTransaction : amount and mosaic fields are now private, you have to use xem() and mosaic() methods instead AccountHttp : replaced function arguements by QueryParams & changed the order of the params in some cases NEW FEATURES TransferTransaction : added containMosaic method to verify if the Transfer Transaction contains mosaics Address now accepts lowercase MosaicId.toString() returns the same as MosaicId.description()","title":"0.9.0"},{"location":"#082","text":"QRService: Added address and transaction generate and decrypt QR code","title":"0.8.2"},{"location":"#080","text":"Wallet: Added unlockPrivateKey(password: Password): string method. Created QRService","title":"0.8.0"},{"location":"#070","text":"Added statics to XEM Mosaic model Added optional levy to MosaicTransferable Created MosaicService to calculate levy value of a Mosaic MosaicId has equals & description methods FIXED issue TransferTransaction. When sending mosaics and message wrong fee calculation.","title":"0.7.0"},{"location":"#060","text":"Connection Pool Created AccountOwnedMosaicService FIXED issue with Mosaics. Now a Mosaic can be created without a Levy","title":"0.6.0"},{"location":"#051","text":"BREAKING CHANGES Where you had XEM(3) now you should add the new apperator first -> new XEM(3) Where you had mosaicHttp.getMosaicDefinitions , now you should call mosaicHttp.getAllMosaicsGivenNamespace NEW FEATURES TransactionHttp: Added getByHash method that returns a particular Transaction BrainPassword must be at least a 12 word password to avoid collitions SimpleWallet has readFromWLT & writeWLTFile methods to persist it BrainWallet has readFromWLT & writeWLTFile methods to persist it Wallet has static walletTypeGivenWLT(wlt: string): WalletType method Created WalletType enum MosaicHttp added getMosaicDefinition method MosaicHttp added getMosaicTransferableWithAmount method Created EcobitEco Mosaic model Created DimToken Mosaic model Created DimCoin Mosaic model","title":"0.5.1"},{"location":"#040","text":"Pagable extends Subject OutgoingTransactionsPageable extends Pageable<> AllTransactionsPageable extends Pageable<> Account decryptMessage method now returns PlainMessage: No compatible with previus version ProvisionNamespaceTransaction added static createSub(timeWindow: TimeWindow, parentNamespace: string, newNamespaceName: string): ProvisionNamespaceTransaction; ProvisionNamespaceTransaction added static method createRoot(timeWindow: TimeWindow, namespaceName: string): ProvisionNamespaceTransaction; PlainMessage return the text decoded if it is encoded in UTF8, else plain payload","title":"0.4.0"},{"location":"#038","text":"Listeners allow HTTPS protocol","title":"0.3.8"},{"location":"#037","text":"Compiled JS is es5 Address trims the input","title":"0.3.7"},{"location":"#036","text":"Released 29 July 2017 FIXED Listeners reconnection","title":"0.3.6"},{"location":"#035","text":"Released 28 July 2017 FIXED ConfirmedTransactionListener: It emitted the same object three times.","title":"0.3.5"},{"location":"#034","text":"Released 26 July 2017 AccountHttp.allTransactions : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.allTransactionsPaginated : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.incomingTransactions : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.incomingTransactionsPaginated : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.outgoingTransactions : Accepts pageSize as optional parameter. Between 5 and 100, default 10 AccountHttp.outgoingTransactionsPaginated : Accepts pageSize as optional parameter. Between 5 and 100, default 10","title":"0.3.4"},{"location":"#033","text":"Released 26 July 2017 Exported interface Pageable","title":"0.3.3"},{"location":"#032","text":"Released 26 July 2017 FIX Listeners on Browsers Transaction Model : Changed signer field type from string to Public Account Block Model : Changed signer field type from string to Public Account NodeIdentity Model : Replaced publickey: string field to publicAccount: PublicAccount","title":"0.3.2"},{"location":"#031","text":"Released 24 July 2017","title":"0.3.1"},{"location":"#030-rc4","text":"Encrypted Message","title":"0.3.0-RC4"},{"location":"#030-rc1","text":"Pagination Listeners Wallets","title":"0.3.0-RC1"},{"location":"#0234","text":"Stable version","title":"0.2.34"},{"location":"about/","text":"About NEM Library The origin of NEM Library is the need of a new development approach for enterprise-ready solutions built on top of the NEM Blockchain . The characteristics of the NEM Library are similar to the NEM Framework definition, but NEM Library has not the same roadmap or scope as described in the NEM Framework document. Hence, NEM Library's future is guided by the needs of the NEM Library usage and products build on top of it. NEM Library is developed independently of any institution by Guillem and Aleix . Follow us on our social networks! Guillem: Twitter , GitHub Email; guillemchain at gmail.com Aleix: Twitter , GitHub , Medium , Email; aleix602 at gmail.com","title":"About"},{"location":"about/#about-nem-library","text":"The origin of NEM Library is the need of a new development approach for enterprise-ready solutions built on top of the NEM Blockchain . The characteristics of the NEM Library are similar to the NEM Framework definition, but NEM Library has not the same roadmap or scope as described in the NEM Framework document. Hence, NEM Library's future is guided by the needs of the NEM Library usage and products build on top of it. NEM Library is developed independently of any institution by Guillem and Aleix . Follow us on our social networks! Guillem: Twitter , GitHub Email; guillemchain at gmail.com Aleix: Twitter , GitHub , Medium , Email; aleix602 at gmail.com","title":"About NEM Library"},{"location":"internal_development_process/","text":"Agile NEM Library is developed following the Agile Manifesto \u2019s values: Individuals and interactions over processes and tools Working software over extensive documentation Customer collaboration over contract negotiation Responding to change over following the plan Development Methodology NEM Library is developed applying Test-Driven Development and eXtreme Programming .","title":"Internal Development Process"},{"location":"internal_development_process/#agile","text":"NEM Library is developed following the Agile Manifesto \u2019s values: Individuals and interactions over processes and tools Working software over extensive documentation Customer collaboration over contract negotiation Responding to change over following the plan","title":"Agile"},{"location":"internal_development_process/#development-methodology","text":"NEM Library is developed applying Test-Driven Development and eXtreme Programming .","title":"Development Methodology"},{"location":"more_software/","text":"More Software Libraries nem-voting by shierve nem-voting is a typescript / node.js module for using the NEM voting functionalities easily on any project. Created using NEM-library. Source Code npmjs nem-trezor by shierve nem-trezor is a typescript / node.js npm module that adds trezor functionalities to nem-library. For the module to work you will need a trezor device connected to the system and trezor trezor-bridge should be running (or the chrome extension). The library only works in a browser environment because of the way trezor is implemented, if executed in a node script environment it will throw an exception. trezor.io Source Code npmjs Cloud AWS Lambda by Daoka Sample using NEMLibrary on AWS lambda. Source Code Mobile Apps NEMPay NEMPay is a mobile app to transfer NEM mosaics easily. NEMPay has been developed in Ionic, and currently available for Android and iOS. Source Code","title":"More Software"},{"location":"more_software/#more-software","text":"","title":"More Software"},{"location":"more_software/#libraries","text":"","title":"Libraries"},{"location":"more_software/#nem-voting-by-shierve","text":"nem-voting is a typescript / node.js module for using the NEM voting functionalities easily on any project. Created using NEM-library. Source Code npmjs","title":"nem-voting by shierve"},{"location":"more_software/#nem-trezor-by-shierve","text":"nem-trezor is a typescript / node.js npm module that adds trezor functionalities to nem-library. For the module to work you will need a trezor device connected to the system and trezor trezor-bridge should be running (or the chrome extension). The library only works in a browser environment because of the way trezor is implemented, if executed in a node script environment it will throw an exception. trezor.io Source Code npmjs","title":"nem-trezor by shierve"},{"location":"more_software/#cloud","text":"","title":"Cloud"},{"location":"more_software/#aws-lambda-by-daoka","text":"Sample using NEMLibrary on AWS lambda. Source Code","title":"AWS Lambda by Daoka"},{"location":"more_software/#mobile-apps","text":"","title":"Mobile Apps"},{"location":"more_software/#nempay","text":"NEMPay is a mobile app to transfer NEM mosaics easily. NEMPay has been developed in Ionic, and currently available for Android and iOS. Source Code","title":"NEMPay"},{"location":"support/","text":"Bug reports If you think you have found a bug in NEM Library, first make sure that you are testing against the latest version of NEM Library - your issue may already have been fixed. If not, search our issues list on GitHub in case a similar issue has already been opened. It is very helpful if you can prepare a reproduction of the bug. In other words, provide a small test case which we can run to confirm your bug. It makes it easier to find the problem and to fix it. Please, take in consideration the next template to report your issue: Expected Behaviour Short and expressive sentence explaining what the code should do. Current Behaviour A short sentence enplaning what the code does. Steps to reproduce For faster issue detection, we would need a step by step description do reproduce the issue. Provide as much information as you can. Open a new issue here . Feature requests If you find yourself wishing for a feature that doesn't exist in NEM Library, you are probably not alone. There are bound to be others out there with similar needs. Many of the features that NEM Library has today have been added because our users saw the need. Open an issue on our issues list on GitHub which describes the feature you would like to see, why you need it, and how it should work. Join the development discussion We love to listen your thoughts about NEM Library, you can find us in Gitter or checkout our About section","title":"Support"},{"location":"support/#bug-reports","text":"If you think you have found a bug in NEM Library, first make sure that you are testing against the latest version of NEM Library - your issue may already have been fixed. If not, search our issues list on GitHub in case a similar issue has already been opened. It is very helpful if you can prepare a reproduction of the bug. In other words, provide a small test case which we can run to confirm your bug. It makes it easier to find the problem and to fix it. Please, take in consideration the next template to report your issue: Expected Behaviour Short and expressive sentence explaining what the code should do. Current Behaviour A short sentence enplaning what the code does. Steps to reproduce For faster issue detection, we would need a step by step description do reproduce the issue. Provide as much information as you can.","title":"Bug reports"},{"location":"support/#open-a-new-issue-here","text":"","title":"Open a new issue here."},{"location":"support/#feature-requests","text":"If you find yourself wishing for a feature that doesn't exist in NEM Library, you are probably not alone. There are bound to be others out there with similar needs. Many of the features that NEM Library has today have been added because our users saw the need. Open an issue on our issues list on GitHub which describes the feature you would like to see, why you need it, and how it should work.","title":"Feature requests"},{"location":"support/#join-the-development-discussion","text":"We love to listen your thoughts about NEM Library, you can find us in Gitter or checkout our About section","title":"Join the development discussion"},{"location":"documentation/account/","text":"Account related requests This chapter will guide you through the process of retrieving account information from a NEM Infrastructure Server (NIS). The information that can be retrieved is the durable account data, its meta data and information about transactions and harvested blocks. NIS supports two different kind of accounts: normal accounts and multsig (short for: multi signature) accounts: Normal accounts: Normal accounts are created and controlled by a private key. Any action for the account like sending NEM to another account via a transfer transaction is signed with this private key. If an attacker gains knowledge of the private key, he/she can rob the account. The private key must therefore be kept secret by all means. Multisig accounts: Multisig accounts can be created by converting a normal account to a multisig account via a aggregate modification transaction. This adds cosignatories to the account. After that modification, only the cosignatories can initiate an action for the account. Any action must be signed by all cosignatories. This makes a multisig account significantly more secure than a normal account. When a single cosignatory private key is gained by an attacker, the attacker still can`t initiate any action on the account since all cosignatories must sign. It is strongly recommended to convert any account holding a significantly high amount of NEM into a multisig account with at least 3 cosignatories. Once converted to a multisig account, the original private key for the account plays no role any more. Official Source Keypair concept NEM Library replaces the Keypair model, which usually holds the public and private key, with the Account model. The reason is that we aim to keep the private key as secret as possible, just providing a set of methods where the private key is involved. AccountHttp definition export declare class AccountHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets an AccountInfoWithMetaData for an account. * @param address - Address * @return Observable<AccountInfoWithMetaData> */ getFromAddress(address: Address): Observable<AccountInfoWithMetaData>; /** * Gets an AccountInfoWithMetaData for an account with publicKey * @param publicKey - NEM * @return Observable<AccountInfoWithMetaData> */ getFromPublicKey(publicKey: string): Observable<AccountInfoWithMetaData>; /** * Given a delegate (formerly known as remote) account's address, gets the AccountMetaDataPair for the account for which the given account is the delegate account. * If the given account address is not a delegate account for any account, the request returns the AccountMetaDataPair for the given address. * @param address - Address * @return Observable<AccountInfoWithMetaData> */ getOriginalAccountDataFromDelegatedAccountAddress(address: Address): Observable<AccountInfoWithMetaData>; /** * retrieve the original account data by providing the public key of the delegate account. * @param publicKey - string * @return Observable<AccountInfoWithMetaData> */ getOriginalAccountDataFromDelegatedAccountPublicKey(publicKey: string): Observable<AccountInfoWithMetaData>; /** * Gets the AccountMetaData from an account. * @param address - NEM Address * @return Observable<AccountStatus> */ status(address: Address): Observable<AccountStatus>; /** * A transaction is said to be incoming with respect to an account if the account is the recipient of the transaction. * In the same way outgoing transaction are the transactions where the account is the sender of the transaction. * Unconfirmed transactions are those transactions that have not yet been included in a block. * Unconfirmed transactions are not guaranteed to be included in any block * @param address - The address of the account. * @param params */ incomingTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>; /** * Paginaged version of incomingTransactions request * @param address * @param params */ incomingTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>; /** * Gets an array of transaction meta data pairs where the recipient has the address given as parameter to the request. * A maximum of 25 transaction meta data pairs is returned. For details about sorting and discussion of the second parameter see Incoming transactions. * @param address - The address of the account. * @param params */ outgoingTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>; /** * Paginaged version of outgoingTransactions request * @param address * @param params * @param params */ outgoingTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>; /** * Gets an array of transaction meta data pairs for which an account is the sender or receiver. * A maximum of 25 transaction meta data pairs is returned. * For details about sorting and discussion of the second parameter see Incoming transactions. * @param address - The address of the account. * @param params */ allTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>; /** * Paginaged version of allTransactions request * @param address * @param params */ allTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>; /** * Gets the array of transactions for which an account is the sender or receiver and which have not yet been included in a block * @param address - NEM Address * @return Observable<Transaction[]> */ unconfirmedTransactions(address: Address): Observable<Transaction[]>; /** * Gets an array of harvest info objects for an account. * @param address - Address * @param id - string (optional) * @return Observable<AccountHarvestInfo[]> */ getHarvestInfoDataForAnAccount(address: Address, id?: string): Observable<AccountHarvestInfo[]>; /** * Paginaged version of allTransactions request * @param address * @param id * @returns {HarvestInfoPageable} */ getHarvestInfoDataForAnAccountPaginated(address: Address, id?: string): Pageable<AccountHarvestInfo[]>; /** * Gets an array of account importance view model objects. * @return Observable<AccountImportanceInfo[]> */ getAccountImportances(): Observable<AccountImportanceInfo[]>; /** * Gets an array of namespace objects for a given account address. * The parent parameter is optional. If supplied, only sub-namespaces of the parent namespace are returned. * @param address - Address * @param parent - The optional parent namespace id. * @param id - The optional namespace database id up to which namespaces are returned. * @param pageSize - The (optional) number of namespaces to be returned. * @return Observable<Namespace[]> */ getNamespaceOwnedByAddress(address: Address, parent?: string, pageSize?: number, id?: string): Observable<Namespace[]>; /** * Gets an array of mosaic definition objects for a given account address. The parent parameter is optional. * If supplied, only mosaic definitions for the given parent namespace are returned. * The id parameter is optional and allows retrieving mosaic definitions in batches of 25 mosaic definitions. * @param address - The address of the account. * @param parent - The optional parent namespace id. * @param id - The optional mosaic definition database id up to which mosaic definitions are returned. * @return Observable<MosaicDefinition[]> */ getMosaicCreatedByAddress(address: Address, parent?: string, id?: string): Observable<MosaicDefinition[]>; /** * Gets an array of mosaic objects for a given account address. * @param address - Address * @return Observable<Mosaic[]> */ getMosaicOwnedByAddress(address: Address): Observable<Mosaic[]>; /** * Unlocks an account (starts harvesting). * @param host - string * @param privateKey - string * @return Observable<boolean> */ unlockHarvesting(host: string, privateKey: string): Observable<boolean>; /** * Locks an account (stops harvesting). * @param host - string * @param privateKey - string * @return Observable<boolean> */ lockHarvesting(host: string, privateKey: string): Observable<boolean>; /** * Each node can allow users to harvest with their delegated key on that node. * The NIS configuration has entries for configuring the maximum number of allowed harvesters and optionally allow harvesting only for certain account addresses. * The unlock info gives information about the maximum number of allowed harvesters and how many harvesters are already using the node. * @return Observable<NodeHarvestInfo> */ unlockInfo(): Observable<NodeHarvestInfo>; /** * Gets historical information for an account. * @param address - The address of the account. * @param startHeight - The block height from which on the data should be supplied. * @param endHeight - The block height up to which the data should be supplied. The end height must be greater than or equal to the start height. * @param increment - The value by which the height is incremented between each data point. The value must be greater than 0. NIS can supply up to 1000 data points with one request. Requesting more than 1000 data points results in an error. * @return Observable<AccountHistoricalInfo[]> */ getHistoricalAccountData(address: Address, startHeight: number, endHeight: number, increment: number): Observable<AccountHistoricalInfo[]>; /** * Gets historical information for an array of accounts. * @param addresses - The addresses of the accounts as an array of addresses. * @param startHeight - The block height from which on the data should be supplied. * @param endHeight - The block height up to which the data should be supplied. The end height must be greater than or equal to the start height. * @param increment - The value by which the height is incremented between each data point. The value must be greater than 0. NIS can supply up to 1000 data points with one request. Requesting more than 1000 data points results in an error. * @return Observable<AccountHistoricalInfo[][]> */ getBatchHistoricalAccountData(addresses: Address[], startHeight: number, endHeight: number, increment: number): Observable<AccountHistoricalInfo[][]> /** * Gets batch information for an array of accounts. * @param addresses - The addresses of the accounts as an array. * @return Observable<AccountInfoWithMetadata[]> */ getBatchAccountData(addresses: Address[]): Observable<AccountInfoWithMetaData[]> } QueryParams export interface QueryParams { /** * (Optional) The xem of transactions returned. Between 5 and 100, otherwise 10 */ pageSize?: number; /** * (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned. */ hash?: string; /** * (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash. */ id?: string; } AccountHttp usage import {AccountHttp, NEMLibrary, NetworkTypes, Address} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"\"); const accountHttp = new AccountHttp(); accountHttp.getFromAddress(address).subscribe(accountInfoWithMetaData => { console.log(accountInfoWithMetaData); }); Output: AccountInfoWithMetaData { balance: Balance { balance: 50481110745315, vestedBalance: 50480744575985, unvestedBalance: 366169330 }, importance: 0.005735794657626706, publicAccount: PublicAccount { address: Address { value: 'TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C', networkType: 152 }, publicKey: '74375c15c6ce6bdbde59be88a069745a0de34444ea933f8c9f46ef407cf30196' }, harvestedBlocks: 116319, cosignatoriesCount: undefined, minCosignatories: undefined, status: 'UNLOCKED', remoteStatus: 'INACTIVE', cosignatoryOf: [], cosignatories: [] } Run the code Models Account /** * Account model */ export declare class Account extends PublicAccount { private readonly privateKey; /** * Sign a transaction * @param transaction * @returns {{data: any, signature: string}} */ signTransaction(transaction: Transaction): SignedTransaction; /** * constructor with private key * @param privateKey * @returns {Account} */ static createWithPrivateKey(privateKey: string): Account; /** * Create a new encrypted Message * @param message * @param recipientPublicAccount * @returns {EncryptedMessage} */ encryptMessage(message: string, recipientPublicAccount: PublicAccount): EncryptedMessage; /** * Decrypts an encrypted message * @param encryptedMessage * @param recipientPublicAccount * @returns {PlainMessage} */ decryptMessage(encryptedMessage: EncryptedMessage, recipientPublicAccount: PublicAccount): PlainMessage; } PublicAccount /** * Public account */ export declare class PublicAccount { readonly address: Address; readonly publicKey: string; /** * @returns {boolean} */ hasPublicKey(): boolean; /** * Creates a new PublicAccount from a public key * @param publicKey * @returns {PublicAccount} */ static createWithPublicKey(publicKey: string): PublicAccount; } Address /** * Address model */ export declare class Address { private readonly value; private readonly networkType; constructor(address: string); /** * Get address in plain format ex: TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C * @returns {string} */ plain(): string; /** * Get address in pretty format ex: TALICE-ROONSJ-CPHC63-F52V6F-Y3SDMS-VAEUGH-MB7C * @returns {string} */ pretty(): string; /** * Address network * @returns {number} */ network(): NetworkTypes; } Balance /** * Balance model */ export declare class Balance { /** * The balance of the account in micro NEM. */ readonly balance: number; /** * The vested part of the balance of the account in micro NEM. */ readonly vestedBalance: number; /** * The unvested part of the balance of the account in micro NEM. */ readonly unvestedBalance: number; } AccountInfo export declare enum RemoteStatus { REMOTE = \"REMOTE\", ACTIVATING = \"ACTIVATING\", ACTIVE = \"ACTIVE\", DEACTIVATING = \"DEACTIVATING\", INACTIVE = \"INACTIVE\", } export declare enum Status { UNKNOWN = \"UNKNOWN\", LOCKED = \"LOCKED\", UNLOCKED = \"UNLOCKED\", } /** * The account structure describes basic information for an account. */ export declare class AccountInfo { /** * The balance of the account in micro NEM. */ readonly balance: Balance; /** * The importance of the account. */ readonly importance: number; /** * The public key of the account. */ readonly publicAccount: PublicAccount; /** * The number blocks that the account already harvested. */ readonly harvestedBlocks: number; /** * Total number of cosignatories */ readonly cosignatoriesCount?: number; /** * Minimum number of cosignatories needed for a transaction to be processed */ readonly minCosignatories?: number; } export declare class AccountInfoWithMetaData extends AccountInfo { /** * The harvesting status of a queried account */ readonly status: Status; /** * The status of remote harvesting of a queried account */ readonly remoteStatus: RemoteStatus; /** * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array. */ readonly cosignatoryOf: AccountInfo[]; /** * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account. */ readonly cosignatories: AccountInfo[]; } export declare class AccountStatus { /** * The harvesting status of a queried account */ readonly status: Status; /** * The status of remote harvesting of a queried account */ readonly remoteStatus: RemoteStatus; /** * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array. */ readonly cosignatoryOf: AccountInfo[]; /** * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account. */ readonly cosignatories: AccountInfo[]; } AccountHarvestInfo /** * A HarvestInfo object contains information about a block that an account harvested. */ export declare class AccountHarvestInfo { /** * The number of seconds elapsed since the creation of the nemesis block. */ readonly timeStamp: number; /** * The database id for the harvested block. */ readonly id: number; /** * The block difficulty. The initial difficulty was set to 100000000000000. The block difficulty is always between one tenth and ten times the initial difficulty. */ readonly difficulty: number; /** * The total fee collected by harvesting the block. */ readonly totalFee: number; /** * The height of the harvested block. */ readonly height: number; } AccountHistoricalInfo /** * Nodes can support a feature for retrieving historical data of accounts. * If this is supported, it returns an array of AccountHistoricalInfo */ export declare class AccountHistoricalInfo { /** * The balance of the account in micro NEM. */ readonly balance: Balance; /** * The importance of the account. */ readonly importance: number; /** * The public key of the account. */ readonly address: Address; /** * The page rank part of the importance. */ readonly pageRank: number; } AccountImportanceInfo /** * Each account is assigned an importance in the NEM network. The ability of an account to generate new blocks is proportional to its importance. The importance is a number between 0 and 1. */ export declare class AccountImportanceInfo { /** * The address of the account. */ readonly address: Address; /** * Substructure that describes the importance of the account. */ readonly importance: AccountImportanceData; } /** * Substructure that describes the importance of the account. */ export declare class AccountImportanceData { /** * Indicates if the fields \"score\", \"ev\" and \"height\" are available.isSet can have the values 0 or 1. In case isSet is 0 the fields are not available. */ readonly isSet: number; /** * The importance of the account. The importance ranges between 0 and 1. */ readonly score?: number; /** * The page rank portion of the importance. The page rank ranges between 0 and 1. */ readonly ev?: number; /** * The height at which the importance calculation was performed. */ readonly height?: number; } NodeHarvestInfo export declare class NodeHarvestInfo { /** * Maximum unlocked slots */ readonly maxUnlocked: number; /** * Number of slots unlocked */ readonly numUnlocked: number; } Pageable /** * Pageable class */ export declare class Pageable<T> extends Subject<T> { /** * Execute next page */ nextPage(): void; }","title":"Account related requests"},{"location":"documentation/account/#account-related-requests","text":"This chapter will guide you through the process of retrieving account information from a NEM Infrastructure Server (NIS). The information that can be retrieved is the durable account data, its meta data and information about transactions and harvested blocks. NIS supports two different kind of accounts: normal accounts and multsig (short for: multi signature) accounts: Normal accounts: Normal accounts are created and controlled by a private key. Any action for the account like sending NEM to another account via a transfer transaction is signed with this private key. If an attacker gains knowledge of the private key, he/she can rob the account. The private key must therefore be kept secret by all means. Multisig accounts: Multisig accounts can be created by converting a normal account to a multisig account via a aggregate modification transaction. This adds cosignatories to the account. After that modification, only the cosignatories can initiate an action for the account. Any action must be signed by all cosignatories. This makes a multisig account significantly more secure than a normal account. When a single cosignatory private key is gained by an attacker, the attacker still can`t initiate any action on the account since all cosignatories must sign. It is strongly recommended to convert any account holding a significantly high amount of NEM into a multisig account with at least 3 cosignatories. Once converted to a multisig account, the original private key for the account plays no role any more. Official Source","title":"Account related requests"},{"location":"documentation/account/#keypair-concept","text":"NEM Library replaces the Keypair model, which usually holds the public and private key, with the Account model. The reason is that we aim to keep the private key as secret as possible, just providing a set of methods where the private key is involved.","title":"Keypair concept"},{"location":"documentation/account/#accounthttp-definition","text":"export declare class AccountHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets an AccountInfoWithMetaData for an account. * @param address - Address * @return Observable<AccountInfoWithMetaData> */ getFromAddress(address: Address): Observable<AccountInfoWithMetaData>; /** * Gets an AccountInfoWithMetaData for an account with publicKey * @param publicKey - NEM * @return Observable<AccountInfoWithMetaData> */ getFromPublicKey(publicKey: string): Observable<AccountInfoWithMetaData>; /** * Given a delegate (formerly known as remote) account's address, gets the AccountMetaDataPair for the account for which the given account is the delegate account. * If the given account address is not a delegate account for any account, the request returns the AccountMetaDataPair for the given address. * @param address - Address * @return Observable<AccountInfoWithMetaData> */ getOriginalAccountDataFromDelegatedAccountAddress(address: Address): Observable<AccountInfoWithMetaData>; /** * retrieve the original account data by providing the public key of the delegate account. * @param publicKey - string * @return Observable<AccountInfoWithMetaData> */ getOriginalAccountDataFromDelegatedAccountPublicKey(publicKey: string): Observable<AccountInfoWithMetaData>; /** * Gets the AccountMetaData from an account. * @param address - NEM Address * @return Observable<AccountStatus> */ status(address: Address): Observable<AccountStatus>; /** * A transaction is said to be incoming with respect to an account if the account is the recipient of the transaction. * In the same way outgoing transaction are the transactions where the account is the sender of the transaction. * Unconfirmed transactions are those transactions that have not yet been included in a block. * Unconfirmed transactions are not guaranteed to be included in any block * @param address - The address of the account. * @param params */ incomingTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>; /** * Paginaged version of incomingTransactions request * @param address * @param params */ incomingTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>; /** * Gets an array of transaction meta data pairs where the recipient has the address given as parameter to the request. * A maximum of 25 transaction meta data pairs is returned. For details about sorting and discussion of the second parameter see Incoming transactions. * @param address - The address of the account. * @param params */ outgoingTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>; /** * Paginaged version of outgoingTransactions request * @param address * @param params * @param params */ outgoingTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>; /** * Gets an array of transaction meta data pairs for which an account is the sender or receiver. * A maximum of 25 transaction meta data pairs is returned. * For details about sorting and discussion of the second parameter see Incoming transactions. * @param address - The address of the account. * @param params */ allTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>; /** * Paginaged version of allTransactions request * @param address * @param params */ allTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>; /** * Gets the array of transactions for which an account is the sender or receiver and which have not yet been included in a block * @param address - NEM Address * @return Observable<Transaction[]> */ unconfirmedTransactions(address: Address): Observable<Transaction[]>; /** * Gets an array of harvest info objects for an account. * @param address - Address * @param id - string (optional) * @return Observable<AccountHarvestInfo[]> */ getHarvestInfoDataForAnAccount(address: Address, id?: string): Observable<AccountHarvestInfo[]>; /** * Paginaged version of allTransactions request * @param address * @param id * @returns {HarvestInfoPageable} */ getHarvestInfoDataForAnAccountPaginated(address: Address, id?: string): Pageable<AccountHarvestInfo[]>; /** * Gets an array of account importance view model objects. * @return Observable<AccountImportanceInfo[]> */ getAccountImportances(): Observable<AccountImportanceInfo[]>; /** * Gets an array of namespace objects for a given account address. * The parent parameter is optional. If supplied, only sub-namespaces of the parent namespace are returned. * @param address - Address * @param parent - The optional parent namespace id. * @param id - The optional namespace database id up to which namespaces are returned. * @param pageSize - The (optional) number of namespaces to be returned. * @return Observable<Namespace[]> */ getNamespaceOwnedByAddress(address: Address, parent?: string, pageSize?: number, id?: string): Observable<Namespace[]>; /** * Gets an array of mosaic definition objects for a given account address. The parent parameter is optional. * If supplied, only mosaic definitions for the given parent namespace are returned. * The id parameter is optional and allows retrieving mosaic definitions in batches of 25 mosaic definitions. * @param address - The address of the account. * @param parent - The optional parent namespace id. * @param id - The optional mosaic definition database id up to which mosaic definitions are returned. * @return Observable<MosaicDefinition[]> */ getMosaicCreatedByAddress(address: Address, parent?: string, id?: string): Observable<MosaicDefinition[]>; /** * Gets an array of mosaic objects for a given account address. * @param address - Address * @return Observable<Mosaic[]> */ getMosaicOwnedByAddress(address: Address): Observable<Mosaic[]>; /** * Unlocks an account (starts harvesting). * @param host - string * @param privateKey - string * @return Observable<boolean> */ unlockHarvesting(host: string, privateKey: string): Observable<boolean>; /** * Locks an account (stops harvesting). * @param host - string * @param privateKey - string * @return Observable<boolean> */ lockHarvesting(host: string, privateKey: string): Observable<boolean>; /** * Each node can allow users to harvest with their delegated key on that node. * The NIS configuration has entries for configuring the maximum number of allowed harvesters and optionally allow harvesting only for certain account addresses. * The unlock info gives information about the maximum number of allowed harvesters and how many harvesters are already using the node. * @return Observable<NodeHarvestInfo> */ unlockInfo(): Observable<NodeHarvestInfo>; /** * Gets historical information for an account. * @param address - The address of the account. * @param startHeight - The block height from which on the data should be supplied. * @param endHeight - The block height up to which the data should be supplied. The end height must be greater than or equal to the start height. * @param increment - The value by which the height is incremented between each data point. The value must be greater than 0. NIS can supply up to 1000 data points with one request. Requesting more than 1000 data points results in an error. * @return Observable<AccountHistoricalInfo[]> */ getHistoricalAccountData(address: Address, startHeight: number, endHeight: number, increment: number): Observable<AccountHistoricalInfo[]>; /** * Gets historical information for an array of accounts. * @param addresses - The addresses of the accounts as an array of addresses. * @param startHeight - The block height from which on the data should be supplied. * @param endHeight - The block height up to which the data should be supplied. The end height must be greater than or equal to the start height. * @param increment - The value by which the height is incremented between each data point. The value must be greater than 0. NIS can supply up to 1000 data points with one request. Requesting more than 1000 data points results in an error. * @return Observable<AccountHistoricalInfo[][]> */ getBatchHistoricalAccountData(addresses: Address[], startHeight: number, endHeight: number, increment: number): Observable<AccountHistoricalInfo[][]> /** * Gets batch information for an array of accounts. * @param addresses - The addresses of the accounts as an array. * @return Observable<AccountInfoWithMetadata[]> */ getBatchAccountData(addresses: Address[]): Observable<AccountInfoWithMetaData[]> }","title":"AccountHttp definition"},{"location":"documentation/account/#queryparams","text":"export interface QueryParams { /** * (Optional) The xem of transactions returned. Between 5 and 100, otherwise 10 */ pageSize?: number; /** * (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned. */ hash?: string; /** * (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash. */ id?: string; }","title":"QueryParams"},{"location":"documentation/account/#accounthttp-usage","text":"import {AccountHttp, NEMLibrary, NetworkTypes, Address} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"\"); const accountHttp = new AccountHttp(); accountHttp.getFromAddress(address).subscribe(accountInfoWithMetaData => { console.log(accountInfoWithMetaData); }); Output: AccountInfoWithMetaData { balance: Balance { balance: 50481110745315, vestedBalance: 50480744575985, unvestedBalance: 366169330 }, importance: 0.005735794657626706, publicAccount: PublicAccount { address: Address { value: 'TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C', networkType: 152 }, publicKey: '74375c15c6ce6bdbde59be88a069745a0de34444ea933f8c9f46ef407cf30196' }, harvestedBlocks: 116319, cosignatoriesCount: undefined, minCosignatories: undefined, status: 'UNLOCKED', remoteStatus: 'INACTIVE', cosignatoryOf: [], cosignatories: [] } Run the code","title":"AccountHttp usage"},{"location":"documentation/account/#models","text":"","title":"Models"},{"location":"documentation/account/#publicaccount","text":"/** * Public account */ export declare class PublicAccount { readonly address: Address; readonly publicKey: string; /** * @returns {boolean} */ hasPublicKey(): boolean; /** * Creates a new PublicAccount from a public key * @param publicKey * @returns {PublicAccount} */ static createWithPublicKey(publicKey: string): PublicAccount; }","title":"PublicAccount"},{"location":"documentation/account/#address","text":"/** * Address model */ export declare class Address { private readonly value; private readonly networkType; constructor(address: string); /** * Get address in plain format ex: TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C * @returns {string} */ plain(): string; /** * Get address in pretty format ex: TALICE-ROONSJ-CPHC63-F52V6F-Y3SDMS-VAEUGH-MB7C * @returns {string} */ pretty(): string; /** * Address network * @returns {number} */ network(): NetworkTypes; }","title":"Address"},{"location":"documentation/account/#balance","text":"/** * Balance model */ export declare class Balance { /** * The balance of the account in micro NEM. */ readonly balance: number; /** * The vested part of the balance of the account in micro NEM. */ readonly vestedBalance: number; /** * The unvested part of the balance of the account in micro NEM. */ readonly unvestedBalance: number; }","title":"Balance"},{"location":"documentation/account/#accountinfo","text":"export declare enum RemoteStatus { REMOTE = \"REMOTE\", ACTIVATING = \"ACTIVATING\", ACTIVE = \"ACTIVE\", DEACTIVATING = \"DEACTIVATING\", INACTIVE = \"INACTIVE\", } export declare enum Status { UNKNOWN = \"UNKNOWN\", LOCKED = \"LOCKED\", UNLOCKED = \"UNLOCKED\", } /** * The account structure describes basic information for an account. */ export declare class AccountInfo { /** * The balance of the account in micro NEM. */ readonly balance: Balance; /** * The importance of the account. */ readonly importance: number; /** * The public key of the account. */ readonly publicAccount: PublicAccount; /** * The number blocks that the account already harvested. */ readonly harvestedBlocks: number; /** * Total number of cosignatories */ readonly cosignatoriesCount?: number; /** * Minimum number of cosignatories needed for a transaction to be processed */ readonly minCosignatories?: number; } export declare class AccountInfoWithMetaData extends AccountInfo { /** * The harvesting status of a queried account */ readonly status: Status; /** * The status of remote harvesting of a queried account */ readonly remoteStatus: RemoteStatus; /** * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array. */ readonly cosignatoryOf: AccountInfo[]; /** * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account. */ readonly cosignatories: AccountInfo[]; } export declare class AccountStatus { /** * The harvesting status of a queried account */ readonly status: Status; /** * The status of remote harvesting of a queried account */ readonly remoteStatus: RemoteStatus; /** * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array. */ readonly cosignatoryOf: AccountInfo[]; /** * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account. */ readonly cosignatories: AccountInfo[]; }","title":"AccountInfo"},{"location":"documentation/account/#accountharvestinfo","text":"/** * A HarvestInfo object contains information about a block that an account harvested. */ export declare class AccountHarvestInfo { /** * The number of seconds elapsed since the creation of the nemesis block. */ readonly timeStamp: number; /** * The database id for the harvested block. */ readonly id: number; /** * The block difficulty. The initial difficulty was set to 100000000000000. The block difficulty is always between one tenth and ten times the initial difficulty. */ readonly difficulty: number; /** * The total fee collected by harvesting the block. */ readonly totalFee: number; /** * The height of the harvested block. */ readonly height: number; }","title":"AccountHarvestInfo"},{"location":"documentation/account/#accounthistoricalinfo","text":"/** * Nodes can support a feature for retrieving historical data of accounts. * If this is supported, it returns an array of AccountHistoricalInfo */ export declare class AccountHistoricalInfo { /** * The balance of the account in micro NEM. */ readonly balance: Balance; /** * The importance of the account. */ readonly importance: number; /** * The public key of the account. */ readonly address: Address; /** * The page rank part of the importance. */ readonly pageRank: number; }","title":"AccountHistoricalInfo"},{"location":"documentation/account/#accountimportanceinfo","text":"/** * Each account is assigned an importance in the NEM network. The ability of an account to generate new blocks is proportional to its importance. The importance is a number between 0 and 1. */ export declare class AccountImportanceInfo { /** * The address of the account. */ readonly address: Address; /** * Substructure that describes the importance of the account. */ readonly importance: AccountImportanceData; } /** * Substructure that describes the importance of the account. */ export declare class AccountImportanceData { /** * Indicates if the fields \"score\", \"ev\" and \"height\" are available.isSet can have the values 0 or 1. In case isSet is 0 the fields are not available. */ readonly isSet: number; /** * The importance of the account. The importance ranges between 0 and 1. */ readonly score?: number; /** * The page rank portion of the importance. The page rank ranges between 0 and 1. */ readonly ev?: number; /** * The height at which the importance calculation was performed. */ readonly height?: number; }","title":"AccountImportanceInfo"},{"location":"documentation/account/#nodeharvestinfo","text":"export declare class NodeHarvestInfo { /** * Maximum unlocked slots */ readonly maxUnlocked: number; /** * Number of slots unlocked */ readonly numUnlocked: number; }","title":"NodeHarvestInfo"},{"location":"documentation/account/#pageable","text":"/** * Pageable class */ export declare class Pageable<T> extends Subject<T> { /** * Execute next page */ nextPage(): void; }","title":"Pageable"},{"location":"documentation/architecture/","text":"Architecture NEM Library works perfect in a multitier architecture , because it is the layer between your business logic and the data tier. It enables the developers focus on the product rather than the NEM Blockchain specific API details due its higher abstraction. NEM Blockchain : Persistent layer. NEM Library : Abstraction layer. Your Application : Where the business logic resides. Final Users : People who benefit the NEM Blockchain Technology. NEM Library has a functional programming approach to deal with the immutability of the NEM Blockchain. So, the developer will find himself/herself comfortable with the easy way to fetch the state, and create new Transactions in order to change that state. Brief description of NEM Library organization NEM Library follows the next rules: Infrastructure : The HTTP requests are done following the Repository Pattern , and they return NEM Domain immutable models via the Observable Pattern . So, the state fetched from the NEM Blockchain cannot be changed via code. NEM Domain models : The NEM Domain models are immutable by definition, the developer cannot change its attributes. Instead, the developer have to create new Transactions and dispatch them to NEM Blockchain via TransactionHTTP, in order to change the NEM Blockchain state. Characteristics Standardized Contracts : Guaranteeing interoperability and harmonization of data models. Loose Coupling : Reducing the degree of component coupling fosters. Abstraction : Increasing long-term consistency of interoperability and allowing underlying components to evolve independently. Reusability : Enabling high-level interoperability between modules and potential component consumers. Stateless : Increasing availability and scalability of components allowing them to interoperate more frequent and reliable. Composability : For components to be effectively composable they must be interoperable. A key objective is for interoperability to become a natural design of the NEM Library, ideally to extend that components to work with other products or systems. Reactive NEM Library uses RxJS as Reactive Library. See its docs here Functional : Developers can avoid intricate stateful programs using clean input/output functions over observable streams. Less is more :ReactiveX's operators often reduce what was once an elaborate challenge into a few lines of code. Async error handling : Traditional try/catch is powerless for errors handling in asynchronous computations, but ReactiveX will offer developers the proper tools to handling these sort of errors. Concurrency made easy : Observables and Schedulers in ReactiveX allow the programmer to abstract away low-level threading, synchronization, and concurrency issues. Frontend : Simple manipulation of UI events and API responses on the Web using RxJS Backend : Embrace ReactiveX's asynchronicity, enabling concurrency and implementation independence. Connection Pool : NEM Library will offer a Connection Pool feature that will distribute load throughout the network ensuring maintained connectivity, higher speeds and higher availability.","title":"Architecture"},{"location":"documentation/architecture/#architecture","text":"NEM Library works perfect in a multitier architecture , because it is the layer between your business logic and the data tier. It enables the developers focus on the product rather than the NEM Blockchain specific API details due its higher abstraction. NEM Blockchain : Persistent layer. NEM Library : Abstraction layer. Your Application : Where the business logic resides. Final Users : People who benefit the NEM Blockchain Technology. NEM Library has a functional programming approach to deal with the immutability of the NEM Blockchain. So, the developer will find himself/herself comfortable with the easy way to fetch the state, and create new Transactions in order to change that state.","title":"Architecture"},{"location":"documentation/architecture/#brief-description-of-nem-library-organization","text":"NEM Library follows the next rules: Infrastructure : The HTTP requests are done following the Repository Pattern , and they return NEM Domain immutable models via the Observable Pattern . So, the state fetched from the NEM Blockchain cannot be changed via code. NEM Domain models : The NEM Domain models are immutable by definition, the developer cannot change its attributes. Instead, the developer have to create new Transactions and dispatch them to NEM Blockchain via TransactionHTTP, in order to change the NEM Blockchain state.","title":"Brief description of NEM Library organization"},{"location":"documentation/architecture/#characteristics","text":"Standardized Contracts : Guaranteeing interoperability and harmonization of data models. Loose Coupling : Reducing the degree of component coupling fosters. Abstraction : Increasing long-term consistency of interoperability and allowing underlying components to evolve independently. Reusability : Enabling high-level interoperability between modules and potential component consumers. Stateless : Increasing availability and scalability of components allowing them to interoperate more frequent and reliable. Composability : For components to be effectively composable they must be interoperable. A key objective is for interoperability to become a natural design of the NEM Library, ideally to extend that components to work with other products or systems.","title":"Characteristics"},{"location":"documentation/architecture/#reactive","text":"NEM Library uses RxJS as Reactive Library. See its docs here Functional : Developers can avoid intricate stateful programs using clean input/output functions over observable streams. Less is more :ReactiveX's operators often reduce what was once an elaborate challenge into a few lines of code. Async error handling : Traditional try/catch is powerless for errors handling in asynchronous computations, but ReactiveX will offer developers the proper tools to handling these sort of errors. Concurrency made easy : Observables and Schedulers in ReactiveX allow the programmer to abstract away low-level threading, synchronization, and concurrency issues. Frontend : Simple manipulation of UI events and API responses on the Web using RxJS Backend : Embrace ReactiveX's asynchronicity, enabling concurrency and implementation independence. Connection Pool : NEM Library will offer a Connection Pool feature that will distribute load throughout the network ensuring maintained connectivity, higher speeds and higher availability.","title":"Reactive"},{"location":"documentation/blockchain/","text":"Blockchain related requests NEM builds a blockchain which contains every bit of information needed. Subsequent blocks in the blockchain have increasing heights that differ by one. Each block can contain transactions. Transactions build the basis of all account activity. It is therefore important to understand the concept and the structures of blocks and transactions. Blocks are generated by accounts. If an account generates a block and the block gets included in the blockchain, the generating account, called the harvester, gets all the transaction fees for transactions that are included in the block. A harvester will therefore usually include as many transactions as possible. Transactions reflect all account activities. In order for a client to have an up to date balance on every account it is crucial to know about every transaction that occurred and therefore the client must have knowledge about every single block in the chain (one says: the client must be synchronized with the blockchain). Official Source BlockHttp definition export declare type BlockHeight = number; export declare type BlockChainScore = number; export declare class BlockHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets a block from the chain that has a given hash. * @param BlockHeight - A BlockHeight JSON object * @returns Observable<Block> */ getBlockByHeight(blockHeight: BlockHeight): Observable<Block>; } BlockHttp usage import {BlockHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const blockHttp = new BlockHttp(); blockHttp.getBlockByHeight(1033023).subscribe(block => { console.log(block); }); Output Block { height: 1033023, type: 1, timeStamp: 72650707, prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' }, signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00', signer: PublicAccount { address: Address { value: 'TDONALICE7O3L63AS3KNDCPT7ZA7HMQTFZGYUCAH', networkType: 152 }, publicKey: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a' }, transactions: [], version: -1744830463 } Run the code ChainHttp definition export declare class ChainHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets the current height of the block chain. * @returns Observable<BlockHeight> */ getBlockchainHeight(): Observable<BlockHeight>; /** * Gets the current score of the block chain. The higher the score, the better the chain. * During synchronization, nodes try to get the best block chain in the network. * @returns Observable<BlockChainScore> */ getBlockchainScore(): Observable<BlockChainScore>; /** * Gets the current last block of the chain. * @returns Observable<Block> */ getBlockchainLastBlock(): Observable<Block>; } ChainHttp usage import {ChainHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const chainHttp = new ChainHttp(); chainHttp.getBlockchainLastBlock().subscribe(block => { console.log(block); }); Output Block { height: 1033023, type: 1, timeStamp: 72650707, prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' }, signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00', signer: PublicAccount { address: Address { value: 'TDONALICE7O3L63AS3KNDCPT7ZA7HMQTFZGYUCAH', networkType: 152 }, publicKey: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a' }, transactions: [], version: -1744830463 } Run the code Models Block export declare enum BlockVersion { MAIN_NET = 0x68, TEST_NET = 0x98 } export declare enum BlockType { NEMESIS = -1, REGULAR = 1 } /** * A blockchain is the structure that contains the transaction information. A blockchain can contain up to 120 transactions. Blocks are generated and signed by accounts and are the instrument by which information is spread in the network. */ export declare class Block { /** * The height of the blockchain. Each blockchain has a unique height. Subsequent blocks differ in height by 1. */ readonly height: BlockHeight; /** * The blockchain type */ readonly type: BlockType; /** * The number of seconds elapsed since the creation of the nemesis blockchain. */ readonly timeStamp: number; /** * The sha3-256 hash of the last blockchain as hex-string. */ readonly prevBlockHash: HashData; /** * The public account of the harvester of the blockchain as hexadecimal number. */ readonly signer: PublicAccount; /** * The public key of the harvester of the blockchain as hexadecimal number. */ readonly signer: string; /** * The array of transaction */ readonly transactions: Transaction[]; /** * The blockchain version */ readonly version: BlockVersion; }","title":"Blockchain related requests"},{"location":"documentation/blockchain/#blockchain-related-requests","text":"NEM builds a blockchain which contains every bit of information needed. Subsequent blocks in the blockchain have increasing heights that differ by one. Each block can contain transactions. Transactions build the basis of all account activity. It is therefore important to understand the concept and the structures of blocks and transactions. Blocks are generated by accounts. If an account generates a block and the block gets included in the blockchain, the generating account, called the harvester, gets all the transaction fees for transactions that are included in the block. A harvester will therefore usually include as many transactions as possible. Transactions reflect all account activities. In order for a client to have an up to date balance on every account it is crucial to know about every transaction that occurred and therefore the client must have knowledge about every single block in the chain (one says: the client must be synchronized with the blockchain). Official Source","title":"Blockchain related requests"},{"location":"documentation/blockchain/#blockhttp-definition","text":"export declare type BlockHeight = number; export declare type BlockChainScore = number; export declare class BlockHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets a block from the chain that has a given hash. * @param BlockHeight - A BlockHeight JSON object * @returns Observable<Block> */ getBlockByHeight(blockHeight: BlockHeight): Observable<Block>; }","title":"BlockHttp definition"},{"location":"documentation/blockchain/#blockhttp-usage","text":"import {BlockHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const blockHttp = new BlockHttp(); blockHttp.getBlockByHeight(1033023).subscribe(block => { console.log(block); }); Output Block { height: 1033023, type: 1, timeStamp: 72650707, prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' }, signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00', signer: PublicAccount { address: Address { value: 'TDONALICE7O3L63AS3KNDCPT7ZA7HMQTFZGYUCAH', networkType: 152 }, publicKey: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a' }, transactions: [], version: -1744830463 } Run the code","title":"BlockHttp usage"},{"location":"documentation/blockchain/#chainhttp-definition","text":"export declare class ChainHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets the current height of the block chain. * @returns Observable<BlockHeight> */ getBlockchainHeight(): Observable<BlockHeight>; /** * Gets the current score of the block chain. The higher the score, the better the chain. * During synchronization, nodes try to get the best block chain in the network. * @returns Observable<BlockChainScore> */ getBlockchainScore(): Observable<BlockChainScore>; /** * Gets the current last block of the chain. * @returns Observable<Block> */ getBlockchainLastBlock(): Observable<Block>; }","title":"ChainHttp definition"},{"location":"documentation/blockchain/#chainhttp-usage","text":"import {ChainHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const chainHttp = new ChainHttp(); chainHttp.getBlockchainLastBlock().subscribe(block => { console.log(block); }); Output Block { height: 1033023, type: 1, timeStamp: 72650707, prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' }, signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00', signer: PublicAccount { address: Address { value: 'TDONALICE7O3L63AS3KNDCPT7ZA7HMQTFZGYUCAH', networkType: 152 }, publicKey: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a' }, transactions: [], version: -1744830463 } Run the code","title":"ChainHttp usage"},{"location":"documentation/blockchain/#models","text":"","title":"Models"},{"location":"documentation/blockchain/#block","text":"export declare enum BlockVersion { MAIN_NET = 0x68, TEST_NET = 0x98 } export declare enum BlockType { NEMESIS = -1, REGULAR = 1 } /** * A blockchain is the structure that contains the transaction information. A blockchain can contain up to 120 transactions. Blocks are generated and signed by accounts and are the instrument by which information is spread in the network. */ export declare class Block { /** * The height of the blockchain. Each blockchain has a unique height. Subsequent blocks differ in height by 1. */ readonly height: BlockHeight; /** * The blockchain type */ readonly type: BlockType; /** * The number of seconds elapsed since the creation of the nemesis blockchain. */ readonly timeStamp: number; /** * The sha3-256 hash of the last blockchain as hex-string. */ readonly prevBlockHash: HashData; /** * The public account of the harvester of the blockchain as hexadecimal number. */ readonly signer: PublicAccount; /** * The public key of the harvester of the blockchain as hexadecimal number. */ readonly signer: string; /** * The array of transaction */ readonly transactions: Transaction[]; /** * The blockchain version */ readonly version: BlockVersion; }","title":"Block"},{"location":"documentation/connection_pool/","text":"Connection Pool NEM Library handles the connections to the NEM Nodes (NIS) automatically. How to use it We use AccountHttp for this example, but it works for every *Http class. All *Http classes already use the Connection Pool by default. If no argument is passed into its constructor, the default NIS nodes will be used. If you like to use your own NIS nodes, you could specify an array with the domain information. Furthermore, the Connection Pool allows you to specify the protocol that you like to use in the second constructor argument. NEMLibrary.bootstrap(NetworkTypes.TEST_NET); // Creates an AccountHttp instance with a pool of NIS nodes for TEST_NET const accountHttpWithDefaultNodes = new AccountHttp(); // Using an AccountHttp with a custom NIS nodes const accountHttpWithCustomNodes = new AccountHttp([ {protocol: \"http\", domain: \"192.3.61.243\", port: 7890}, {protocol: \"http\", domain: \"23.228.67.85\", port: 7890} ]); In case you want to use a specific protocol, for example HTTPS , you can specify your preferred protocol in the AccountHttp constructor. NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttpWithDefaultNodes = new AccountHttp(undefined, \"https\"); How it works The NEM Library starts the request to a NIS node. If the request is successfull, the result is returned. If not, step 3. The connection pool handles the connection error and tries the next available server.","title":"Connection Pool"},{"location":"documentation/connection_pool/#connection-pool","text":"NEM Library handles the connections to the NEM Nodes (NIS) automatically.","title":"Connection Pool"},{"location":"documentation/connection_pool/#how-to-use-it","text":"We use AccountHttp for this example, but it works for every *Http class. All *Http classes already use the Connection Pool by default. If no argument is passed into its constructor, the default NIS nodes will be used. If you like to use your own NIS nodes, you could specify an array with the domain information. Furthermore, the Connection Pool allows you to specify the protocol that you like to use in the second constructor argument. NEMLibrary.bootstrap(NetworkTypes.TEST_NET); // Creates an AccountHttp instance with a pool of NIS nodes for TEST_NET const accountHttpWithDefaultNodes = new AccountHttp(); // Using an AccountHttp with a custom NIS nodes const accountHttpWithCustomNodes = new AccountHttp([ {protocol: \"http\", domain: \"192.3.61.243\", port: 7890}, {protocol: \"http\", domain: \"23.228.67.85\", port: 7890} ]); In case you want to use a specific protocol, for example HTTPS , you can specify your preferred protocol in the AccountHttp constructor. NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttpWithDefaultNodes = new AccountHttp(undefined, \"https\");","title":"How to use it"},{"location":"documentation/connection_pool/#how-it-works","text":"The NEM Library starts the request to a NIS node. If the request is successfull, the result is returned. If not, step 3. The connection pool handles the connection error and tries the next available server.","title":"How it works"},{"location":"documentation/error/","text":"Errors In case NIS encounters an error while processing a request it returns an error. This chapter describes the error messages that can be returned from NIS. Error messages Request method 'GET' not supported The request was performed as a GET request but was expected to be a POST request. address must be valid: At least one address supplied in the request was invalid. Addresses are validated before processing a request. If validation fails, an error containing this message is returned. FAILURE_SERVER_LIMIT: The number of accounts that are allowed to harvest on NIS was exceeded. JSON Object was expected: A parameter is missing in the request. FAILURE_UNKNOWN_ACCOUNT: The account specified in the request is not known. block not found in the db The block that was requested could not be found in the database. height must be positive The block height supplied in a request was zero or negative. Block height must always be greater than zero. network has not been booted yet Most requests need the node that should answer the request to be already booted. If node is not booted yet, this error message will be returned. network boot was already attempted It was attempted to boot an already booted node. Nodes can only be booted once. remote 123.45.67.89 attempted to call local /node/boot It was attempted to boot a remote node. Only local node can be booted. FAILURE_PAST_DEADLINE The deadline for the entity has already expired. The deadline must always lie in the future. FAILURE_FUTURE_DEADLINE The deadline lies too far in the future. Deadlines are only allowed to lie up to 24 hours in the future. FAILURE_INSUFFICIENT_BALANCE The account does not have enough funds. FAILURE_MESSAGE_TOO_LARGE The message for the transaction exceeds the limit of 512 bytes. FAILURE_HASH_EXISTS The hash of the entity already exists either in the cache or in the database. FAILURE_SIGNATURE_NOT_VERIFIABLE The signature of the entity failed upon verification. FAILURE_TIMESTAMP_TOO_FAR_IN_PAST The timestamp of the entity lies to far in the past. FAILURE_TIMESTAMP_TOO_FAR_IN_FUTURE The timestamp of the entity lies too far in the future. FAILURE_INELIGIBLE_BLOCK_SIGNER Validation failed because the block had an ineligible signer. This usually occurs when remote harvesting is in the process of being activated or deactivated. FAILURE_ENTITY_UNUSABLE_OUT_OF_SYNC The entity cannot be processed because the remote node is out of synchronization with the local node. This happens frequently when a node is not fully synchronized and receives a new block with much larger height than its own chain. FAILURE_INSUFFICIENT_FEE The supplied transaction has an insufficient fee. FAILURE_NEMESIS_ACCOUNT_TRANSACTION_AFTER_NEMESIS_BLOCK The supplied transaction has the nemesis account as sender and cannot be included in a normal block. FAILURE_TRANSACTION_CACHE_TOO_FULL The transaction was rejected because the transaction cache is too full. This happens when an account tries to send too many transactions in a short time. To improve the chance that the transaction gets accepted you can try to raise the transaction fee. FAILURE_WRONG_NETWORK Entity was rejected because it has the wrong network specified. FAILURE_CANNOT_HARVEST_FROM_BLOCKED_ACCOUNT Block was rejected because it was harvested by a blocked account (typically a reserved NEM fund). FAILURE_DESTINATION_ACCOUNT_HAS_NONZERO_BALANCE The importance cannot be transferred to an account with nonzero balance. FAILURE_IMPORTANCE_TRANSFER_IN_PROGRESS The transaction is conflicting because there is already a transfer of importance in progress. FAILURE_IMPORTANCE_TRANSFER_NEEDS_TO_BE_DEACTIVATED The transaction is conflicting because the importance was already transferred. FAILURE_IMPORTANCE_TRANSFER_IS_NOT_ACTIVE The transaction is conflicting because no importance has been transferred yet. FAILURE_TRANSACTION_NOT_ALLOWED_FOR_REMOTE Validation failed because transaction is using remote account in an improper way. FAILURE_MULTISIG_NOT_A_COSIGNER The multisig transaction was rejected because the signer of the transaction is not a cosignatory of the sender account of the inner transaction. FAILURE_MULTISIG_INVALID_COSIGNERS Validation failed because the cosignatories attached to a multisig transaction were invalid. FAILURE_MULTISIG_NO_MATCHING_MULTISIG The signature transaction was rejected because the corresponding multisig transaction was not found. FAILURE_TRANSACTION_NOT_ALLOWED_FOR_MULTISIG The transaction was rejected because the signer is a multisig account. Multisig accounts are not allowed to initiate any transaction (only cosignatories are allowed to do so). FAILURE_MULTISIG_ALREADY_A_COSIGNER The transaction was rejected because it tried to add a cosignatory to a multisig account which already has this cosignatory. FAILURE_MULTISIG_MODIFICATION_MULTIPLE_DELETES The transaction was rejected because it tried to remove multiple cosignatories at once. It is only allowed to remove one cosignatory at a time. FAILURE_MULTISIG_MODIFICATION_REDUNDANT_MODIFICATIONS The transaction was rejected because it tried to do redundant modifications. This can happen if a transaction tries to add the same cosignatory two time. FAILURE_CONFLICTING_MULTISIG_MODIFICATION The transaction was rejected because it contained conflicting modifications to a multisig account. This can for instance happen if a transaction tries to add and then delete the same cosignatory. FAILURE_TOO_MANY_MULTISIG_COSIGNERS The transaction was rejected because it contains too many cosignatories. The maximum number of cosignatories allowed for a multisig account is 32. FAILURE_MULTISIG_ACCOUNT_CANNOT_BE_COSIGNER Validation failed because a multisig modification would result in a multisig account being a cosigner. FAILURE_MULTISIG_MIN_COSIGNATORIES_OUT_OF_RANGE Validation failed because the minimum number of cosignatories is negative or larger than the number of cosignatories. FAILURE_NAMESPACE_UNKNOWN Validation failed because the namespace is unknown. FAILURE_NAMESPACE_ALREADY_EXISTS Validation failed because the namespace already exists. FAILURE_NAMESPACE_EXPIRED Validation failed because the namespace has expired. FAILURE_NAMESPACE_OWNER_CONFLICT Validation failed because the transaction signer is not the owner of the namespace. FAILURE_NAMESPACE_INVALID_NAME( Validation failed because the name for the namespace is invalid. FAILURE_NAMESPACE_INVALID_RENTAL_FEE_SINK Validation failed because the specified namespace rental fee sink is invalid. FAILURE_NAMESPACE_INVALID_RENTAL_FEE Validation failed because the specified rental fee is invalid. FAILURE_NAMESPACE_PROVISION_TOO_EARLY Validation failed because the provision was done too early. FAILURE_NAMESPACE_NOT_CLAIMABLE Validation failed because the namespace contains a reserved part and is not claimable. FAILURE_MOSAIC_UNKNOWN Validation failed because the mosaic is unknown. FAILURE_MOSAIC_MODIFICATION_NOT_ALLOWED Validation failed because the modification of the existing mosaic is not allowed. FAILURE_MOSAIC_CREATOR_CONFLICT Validation failed because the transaction signer is not the creator of the mosaic. FAILURE_MOSAIC_SUPPLY_IMMUTABLE Validation failed because the mosaic supply is immutable. FAILURE_MOSAIC_MAX_SUPPLY_EXCEEDED Validation failed because the maximum overall mosaic supply is exceeded. FAILURE_MOSAIC_SUPPLY_NEGATIVE Validation failed because the resulting mosaic supply would be negative. FAILURE_MOSAIC_NOT_TRANSFERABLE Validation failed because the mosaic is not transferable. FAILURE_MOSAIC_DIVISIBILITY_VIOLATED Validation failed because the divisibility of the mosaic is violated. FAILURE_CONFLICTING_MOSAIC_CREATION Validation failed because conflicting mosaic creation is present. FAILURE_MOSAIC_INVALID_CREATION_FEE_SINK Validation failed because the mosaic creation fee sink is invalid. FAILURE_MOSAIC_INVALID_CREATION_FEE Validation failed because the specified creation fee is invalid. FAILURE_TOO_MANY_MOSAIC_TRANSFERS Validation failed because a transfer transaction had too many attached mosaic transfers.","title":"Errors"},{"location":"documentation/error/#errors","text":"In case NIS encounters an error while processing a request it returns an error. This chapter describes the error messages that can be returned from NIS.","title":"Errors"},{"location":"documentation/error/#error-messages","text":"Request method 'GET' not supported The request was performed as a GET request but was expected to be a POST request. address must be valid: At least one address supplied in the request was invalid. Addresses are validated before processing a request. If validation fails, an error containing this message is returned. FAILURE_SERVER_LIMIT: The number of accounts that are allowed to harvest on NIS was exceeded. JSON Object was expected: A parameter is missing in the request. FAILURE_UNKNOWN_ACCOUNT: The account specified in the request is not known. block not found in the db The block that was requested could not be found in the database. height must be positive The block height supplied in a request was zero or negative. Block height must always be greater than zero. network has not been booted yet Most requests need the node that should answer the request to be already booted. If node is not booted yet, this error message will be returned. network boot was already attempted It was attempted to boot an already booted node. Nodes can only be booted once. remote 123.45.67.89 attempted to call local /node/boot It was attempted to boot a remote node. Only local node can be booted. FAILURE_PAST_DEADLINE The deadline for the entity has already expired. The deadline must always lie in the future. FAILURE_FUTURE_DEADLINE The deadline lies too far in the future. Deadlines are only allowed to lie up to 24 hours in the future. FAILURE_INSUFFICIENT_BALANCE The account does not have enough funds. FAILURE_MESSAGE_TOO_LARGE The message for the transaction exceeds the limit of 512 bytes. FAILURE_HASH_EXISTS The hash of the entity already exists either in the cache or in the database. FAILURE_SIGNATURE_NOT_VERIFIABLE The signature of the entity failed upon verification. FAILURE_TIMESTAMP_TOO_FAR_IN_PAST The timestamp of the entity lies to far in the past. FAILURE_TIMESTAMP_TOO_FAR_IN_FUTURE The timestamp of the entity lies too far in the future. FAILURE_INELIGIBLE_BLOCK_SIGNER Validation failed because the block had an ineligible signer. This usually occurs when remote harvesting is in the process of being activated or deactivated. FAILURE_ENTITY_UNUSABLE_OUT_OF_SYNC The entity cannot be processed because the remote node is out of synchronization with the local node. This happens frequently when a node is not fully synchronized and receives a new block with much larger height than its own chain. FAILURE_INSUFFICIENT_FEE The supplied transaction has an insufficient fee. FAILURE_NEMESIS_ACCOUNT_TRANSACTION_AFTER_NEMESIS_BLOCK The supplied transaction has the nemesis account as sender and cannot be included in a normal block. FAILURE_TRANSACTION_CACHE_TOO_FULL The transaction was rejected because the transaction cache is too full. This happens when an account tries to send too many transactions in a short time. To improve the chance that the transaction gets accepted you can try to raise the transaction fee. FAILURE_WRONG_NETWORK Entity was rejected because it has the wrong network specified. FAILURE_CANNOT_HARVEST_FROM_BLOCKED_ACCOUNT Block was rejected because it was harvested by a blocked account (typically a reserved NEM fund). FAILURE_DESTINATION_ACCOUNT_HAS_NONZERO_BALANCE The importance cannot be transferred to an account with nonzero balance. FAILURE_IMPORTANCE_TRANSFER_IN_PROGRESS The transaction is conflicting because there is already a transfer of importance in progress. FAILURE_IMPORTANCE_TRANSFER_NEEDS_TO_BE_DEACTIVATED The transaction is conflicting because the importance was already transferred. FAILURE_IMPORTANCE_TRANSFER_IS_NOT_ACTIVE The transaction is conflicting because no importance has been transferred yet. FAILURE_TRANSACTION_NOT_ALLOWED_FOR_REMOTE Validation failed because transaction is using remote account in an improper way. FAILURE_MULTISIG_NOT_A_COSIGNER The multisig transaction was rejected because the signer of the transaction is not a cosignatory of the sender account of the inner transaction. FAILURE_MULTISIG_INVALID_COSIGNERS Validation failed because the cosignatories attached to a multisig transaction were invalid. FAILURE_MULTISIG_NO_MATCHING_MULTISIG The signature transaction was rejected because the corresponding multisig transaction was not found. FAILURE_TRANSACTION_NOT_ALLOWED_FOR_MULTISIG The transaction was rejected because the signer is a multisig account. Multisig accounts are not allowed to initiate any transaction (only cosignatories are allowed to do so). FAILURE_MULTISIG_ALREADY_A_COSIGNER The transaction was rejected because it tried to add a cosignatory to a multisig account which already has this cosignatory. FAILURE_MULTISIG_MODIFICATION_MULTIPLE_DELETES The transaction was rejected because it tried to remove multiple cosignatories at once. It is only allowed to remove one cosignatory at a time. FAILURE_MULTISIG_MODIFICATION_REDUNDANT_MODIFICATIONS The transaction was rejected because it tried to do redundant modifications. This can happen if a transaction tries to add the same cosignatory two time. FAILURE_CONFLICTING_MULTISIG_MODIFICATION The transaction was rejected because it contained conflicting modifications to a multisig account. This can for instance happen if a transaction tries to add and then delete the same cosignatory. FAILURE_TOO_MANY_MULTISIG_COSIGNERS The transaction was rejected because it contains too many cosignatories. The maximum number of cosignatories allowed for a multisig account is 32. FAILURE_MULTISIG_ACCOUNT_CANNOT_BE_COSIGNER Validation failed because a multisig modification would result in a multisig account being a cosigner. FAILURE_MULTISIG_MIN_COSIGNATORIES_OUT_OF_RANGE Validation failed because the minimum number of cosignatories is negative or larger than the number of cosignatories. FAILURE_NAMESPACE_UNKNOWN Validation failed because the namespace is unknown. FAILURE_NAMESPACE_ALREADY_EXISTS Validation failed because the namespace already exists. FAILURE_NAMESPACE_EXPIRED Validation failed because the namespace has expired. FAILURE_NAMESPACE_OWNER_CONFLICT Validation failed because the transaction signer is not the owner of the namespace. FAILURE_NAMESPACE_INVALID_NAME( Validation failed because the name for the namespace is invalid. FAILURE_NAMESPACE_INVALID_RENTAL_FEE_SINK Validation failed because the specified namespace rental fee sink is invalid. FAILURE_NAMESPACE_INVALID_RENTAL_FEE Validation failed because the specified rental fee is invalid. FAILURE_NAMESPACE_PROVISION_TOO_EARLY Validation failed because the provision was done too early. FAILURE_NAMESPACE_NOT_CLAIMABLE Validation failed because the namespace contains a reserved part and is not claimable. FAILURE_MOSAIC_UNKNOWN Validation failed because the mosaic is unknown. FAILURE_MOSAIC_MODIFICATION_NOT_ALLOWED Validation failed because the modification of the existing mosaic is not allowed. FAILURE_MOSAIC_CREATOR_CONFLICT Validation failed because the transaction signer is not the creator of the mosaic. FAILURE_MOSAIC_SUPPLY_IMMUTABLE Validation failed because the mosaic supply is immutable. FAILURE_MOSAIC_MAX_SUPPLY_EXCEEDED Validation failed because the maximum overall mosaic supply is exceeded. FAILURE_MOSAIC_SUPPLY_NEGATIVE Validation failed because the resulting mosaic supply would be negative. FAILURE_MOSAIC_NOT_TRANSFERABLE Validation failed because the mosaic is not transferable. FAILURE_MOSAIC_DIVISIBILITY_VIOLATED Validation failed because the divisibility of the mosaic is violated. FAILURE_CONFLICTING_MOSAIC_CREATION Validation failed because conflicting mosaic creation is present. FAILURE_MOSAIC_INVALID_CREATION_FEE_SINK Validation failed because the mosaic creation fee sink is invalid. FAILURE_MOSAIC_INVALID_CREATION_FEE Validation failed because the specified creation fee is invalid. FAILURE_TOO_MANY_MOSAIC_TRANSFERS Validation failed because a transfer transaction had too many attached mosaic transfers.","title":"Error messages"},{"location":"documentation/listener/","text":"Listeners AccountListener definition /** * Account listener */ export declare class AccountListener extends Listener { /** * Constructor * @param nodes */ constructor(nodes?: WebSocketConfig[]); /** * Start listening updates * @param address * @returns {Observable<AccountInfoWithMetaData>} */ given(address: Address): Observable<AccountInfoWithMetaData>; } AccountListener usage /** * nem-library 0.3.0 */ import {AccountListener, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\"); let accountListener = new AccountListener().given(address).subscribe(x => { console.log(x); }, err => { console.log(err); }); Output AccountInfoWithMetaData { balance: Balance { balance: 10246300001, vestedBalance: 5507591402, unvestedBalance: 4738708599 }, importance: 0, publicAccount: PublicAccount { address: Address { value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA', networkType: 152 }, publicKey: 'a4f9d42cf8e1f7c6c3216ede81896c4fa9f49071ee4aee2a4843e2711899b23a' }, harvestedBlocks: 0, cosignatoriesCount: undefined, minCosignatories: undefined, status: 'LOCKED', remoteStatus: 'ACTIVE', cosignatoryOf: [ AccountInfo { balance: [Object], importance: 0, publicAccount: [Object], harvestedBlocks: 0, cosignatoriesCount: undefined, minCosignatories: undefined }, AccountInfo { balance: [Object], importance: 0, publicAccount: [Object], harvestedBlocks: 0, cosignatoriesCount: undefined, minCosignatories: undefined } ], cosignatories: [] } Run the code BlockchainListener definition /** * Blockchain listener */ export declare class BlockchainListener extends Listener { /** * Constructor * @param nodes */ constructor(nodes?: WebSocketConfig[]); /** * Start listening new blocks * @returns {Observable<Block>} */ newBlock(): Observable<Block>; /** * Start listening new blockchain height * @returns {Observable<BlockHeight>} */ newHeight(): Observable<BlockHeight>; } UnconfirmedTransactionListener definition /** * UnconfirmedTransaction listener */ export declare class UnconfirmedTransactionListener extends Listener { /** * Constructor * @param nodes */ constructor(nodes?: WebSocketConfig[]); /** * Start listening new unconfirmed transactions * @param address * @returns {Observable<Transaction>} */ given(address: Address): Observable<Transaction>; } ConfirmedTransactionListener definition /** * ConfirmedTransaction listener */ export declare class ConfirmedTransactionListener extends Listener { /** * Constructor * @param nodes */ constructor(nodes?: WebSocketConfig[]); /** * Start listening new confirmed transactions * @param address * @returns {Observable<Transaction>} */ given(address: Address): Observable<Transaction>; }","title":"Listeners"},{"location":"documentation/listener/#listeners","text":"","title":"Listeners"},{"location":"documentation/listener/#accountlistener-definition","text":"/** * Account listener */ export declare class AccountListener extends Listener { /** * Constructor * @param nodes */ constructor(nodes?: WebSocketConfig[]); /** * Start listening updates * @param address * @returns {Observable<AccountInfoWithMetaData>} */ given(address: Address): Observable<AccountInfoWithMetaData>; }","title":"AccountListener definition"},{"location":"documentation/listener/#accountlistener-usage","text":"/** * nem-library 0.3.0 */ import {AccountListener, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\"); let accountListener = new AccountListener().given(address).subscribe(x => { console.log(x); }, err => { console.log(err); }); Output AccountInfoWithMetaData { balance: Balance { balance: 10246300001, vestedBalance: 5507591402, unvestedBalance: 4738708599 }, importance: 0, publicAccount: PublicAccount { address: Address { value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA', networkType: 152 }, publicKey: 'a4f9d42cf8e1f7c6c3216ede81896c4fa9f49071ee4aee2a4843e2711899b23a' }, harvestedBlocks: 0, cosignatoriesCount: undefined, minCosignatories: undefined, status: 'LOCKED', remoteStatus: 'ACTIVE', cosignatoryOf: [ AccountInfo { balance: [Object], importance: 0, publicAccount: [Object], harvestedBlocks: 0, cosignatoriesCount: undefined, minCosignatories: undefined }, AccountInfo { balance: [Object], importance: 0, publicAccount: [Object], harvestedBlocks: 0, cosignatoriesCount: undefined, minCosignatories: undefined } ], cosignatories: [] } Run the code","title":"AccountListener usage"},{"location":"documentation/listener/#blockchainlistener-definition","text":"/** * Blockchain listener */ export declare class BlockchainListener extends Listener { /** * Constructor * @param nodes */ constructor(nodes?: WebSocketConfig[]); /** * Start listening new blocks * @returns {Observable<Block>} */ newBlock(): Observable<Block>; /** * Start listening new blockchain height * @returns {Observable<BlockHeight>} */ newHeight(): Observable<BlockHeight>; }","title":"BlockchainListener definition"},{"location":"documentation/listener/#unconfirmedtransactionlistener-definition","text":"/** * UnconfirmedTransaction listener */ export declare class UnconfirmedTransactionListener extends Listener { /** * Constructor * @param nodes */ constructor(nodes?: WebSocketConfig[]); /** * Start listening new unconfirmed transactions * @param address * @returns {Observable<Transaction>} */ given(address: Address): Observable<Transaction>; }","title":"UnconfirmedTransactionListener definition"},{"location":"documentation/listener/#confirmedtransactionlistener-definition","text":"/** * ConfirmedTransaction listener */ export declare class ConfirmedTransactionListener extends Listener { /** * Constructor * @param nodes */ constructor(nodes?: WebSocketConfig[]); /** * Start listening new confirmed transactions * @param address * @returns {Observable<Transaction>} */ given(address: Address): Observable<Transaction>; }","title":"ConfirmedTransactionListener definition"},{"location":"documentation/mosaic/","text":"Mosaic related requests NEM mosaics are assets that expose additional properties and other features. Each mosaic has an underlying mosaic definition. To be able to create a mosaic definition, an account must rent at least one root namespace which the mosaic definition can then refer to. Official Source MosaicHttp definition export declare class MosaicHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets the mosaic definitions for a given namespace. The request supports paging. * @param namespace * @param id - The topmost mosaic definition database id up to which root mosaic definitions are returned. The parameter is optional. If not supplied the most recent mosaic definitiona are returned. * @param pageSize - The number of mosaic definition objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100. * @returns Observable<MosaicDefinition[]> */ getAllMosaicsGivenNamespace(namespace: string, id?: number, pageSize?: number): Observable<MosaicDefinition[]>; /** * Return the Mosaic Definition given a namespace and mosaic. Throw exception if no mosaic is found * @param {string} mosaicId * @returns {Observable<MosaicDefinition>} */ getMosaicDefinition(mosaicId: MosaicId): Observable<MosaicDefinition>; /** * Return a MosaicTransferable with the amount * @param {string} mosaicId * @param {number} amount * @returns {Observable<MosaicTransferable>} */ getMosaicTransferableWithAmount(mosaicId: MosaicId, amount: number): Observable<MosaicTransferable>; } MosaicHttp usage import {MosaicHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const mosaicHttp = new MosaicHttp(); const namespace = \"server\"; mosaicHttp.getAllMosaicsGivenNamespace(namespace).subscribe(mosaicDefinitions => { console.log(mosaicDefinitions); }); Output [ MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' }, id: MosaicId { namespaceId: 'server', name: 'testmosaic' }, description: 'descritpio', properties: MosaicProperties { initialSupply: 1000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: undefined, metaId: 447 }, MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' }, id: MosaicId { namespaceId: 'server', name: 'alcapone' }, description: 'the one and only al capone', properties: MosaicProperties { initialSupply: 10000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 }, metaId: 385 }, MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' }, id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' }, description: 'description', properties: MosaicProperties { initialSupply: 100000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 }, metaId: 384 } ] Run the code Models MosaicId /** * A mosaic id uniquely identifies an underlying mosaic definition. */ export declare class MosaicId { /** * The corresponding namespace id */ readonly namespaceId: string; /** * The name of the mosaic definition. */ readonly name: string; /** * constructor * @param namespaceId * @param name */ constructor(namespaceId: string, name: string); /** * Compares mosaicIds for equality * @param mosaicId * @returns {boolean} */ equals(mosaicId: MosaicId): boolean; /** * Mosaic Id description in format namespaceId:name ex: nem:xem */ description(): string; } Mosaic /** * A mosaic describes an instance of a mosaic definition. Mosaics can be transferred by means of a transfer transaction. */ export declare class Mosaic { /** * The mosaic id */ readonly mosaicId: MosaicId; /** * The mosaic quantity. The quantity is always given in smallest units for the mosaic, i.e. if it has a divisibility of 3 the quantity is given in millis. */ readonly quantity: number; /** * constructor * @param mosaicId * @param quantity */ constructor(mosaicId: MosaicId, quantity: number); } MosaicDefinition /** * A mosaic definition describes an asset class. Some fields are mandatory while others are optional. * The properties of a mosaic definition always have a default value and only need to be supplied if they differ from the default value. */ export declare class MosaicDefinition { /** * The public key of the mosaic definition creator. */ readonly creator: PublicAccount; /** * The mosaic id */ readonly id: MosaicId; /** * The mosaic description. The description may have a length of up to 512 characters and cannot be empty. */ readonly description: string; /** * Mosaic properties */ readonly properties: MosaicProperties; /** * The optional levy for the mosaic. A creator can demand that each mosaic transfer induces an additional fee */ readonly levy?: MosaicLevy; /** * The id for the mosaic definition object. */ readonly metaId?: number; /** * constructor * @param creator * @param id * @param description * @param properties * @param levy * @param metaId */ constructor(creator: PublicAccount, id: MosaicId, description: string, properties: MosaicProperties, levy?: MosaicLevy, metaId?: number); } /** * Each mosaic definition comes with a set of properties. * Each property has a default value which will be applied in case it was not specified. * Future release may add additional properties to the set of available properties */ export declare class MosaicProperties { /** * initialSupply: The creator can specify an initial supply of mosaics when creating the definition. * The supply is given in entire units of the mosaic, not in smallest sub-units. * The initial supply must be in the range of 0 and 9,000,000,000. The default value is \"1000\". */ readonly initialSupply: number; /** * The creator can choose between a definition that allows a mosaic supply change at a later point or an immutable supply. * Allowed values for the property are \"true\" and \"false\". The default value is \"false\". */ readonly supplyMutable: boolean; /** * The creator can choose if the mosaic definition should allow for transfers of the mosaic among accounts other than the creator. * If the property 'transferable' is set to \"false\", only transfer transactions having the creator as sender or as recipient can transfer mosaics of that type. * If set to \"true\" the mosaics can be transferred to and from arbitrary accounts. * Allowed values for the property are thus \"true\" and \"false\". The default value is \"true\". */ readonly transferable: boolean; /** * The divisibility determines up to what decimal place the mosaic can be divided into. * Thus a divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics, i.e. milli mosaics is the smallest sub-unit. * When transferring mosaics via a transfer transaction the quantity transferred is given in multiples of those smallest parts. * The divisibility must be in the range of 0 and 6. The default value is \"0\". */ readonly divisibility: number; /** * constructor * @param divisibility * @param initialSupply * @param supplyMutable * @param transferable */ constructor(divisibility?: number, initialSupply?: number, transferable?: boolean, supplyMutable?: boolean); } MosaicLevy export declare enum MosaicLevyType { Absolute = 1, Percentil = 2, } /** * A mosaic definition can optionally specify a levy for transferring those mosaics. This might be needed by legal entities needing to collect some taxes for transfers. */ export declare class MosaicLevy { /** * The levy type */ readonly type: MosaicLevyType; /** * The recipient of the levy. */ readonly recipient: Address; /** * The mosaic in which the levy is paid. */ readonly mosaicId: MosaicId; /** * The fee. The interpretation is dependent on the type of the levy */ readonly fee: number; /** * constructor * @param type * @param recipient * @param mosaicId * @param fee */ constructor(type: MosaicLevyType, recipient: Address, mosaicId: MosaicId, fee: number); } MosaicTransferable /** * Mosaic transferable model */ export declare class MosaicTransferable { /** * Quantity to be send */ readonly quantity: number; /** * Mosaic definition properties */ readonly properties: MosaicProperties; /** * Mosaic id */ readonly mosaicId: MosaicId; /** * Levy */ readonly levy?: MosaicLevy; /** * constructor * @param mosaicId * @param properties * @param amount * @param levy */ constructor(mosaicId: MosaicId, properties: MosaicProperties, amount: number, levy?: MosaicLevy); /** * Create a MosaicTransferable object with mosaic definition * @param mosaicDefinition * @param quantity * @returns {MosaicTransferable} */ static createWithMosaicDefinition(mosaicDefinition: MosaicDefinition, quantity: number): MosaicTransferable; } XEM /** * XEM mosaic transferable */ export declare class XEM extends MosaicTransferable { /** * Divisiblity * @type {number} */ static DIVISIBILITY: number; /** * Initial supply * @type {number} */ static INITIALSUPPLY: number; /** * Is tranferable * @type {boolean} */ static TRANSFERABLE: boolean; /** * Is mutable * @type {boolean} */ static SUPPLYMUTABLE: boolean; /** * mosaicId * @type {MosaicId} */ static MOSAICID: MosaicId; /** * constructor * @param amount */ constructor(amount: number) { super(new MosaicId(\"nem\", \"xem\"), new MosaicProperties(6, 8999999999, true, false), amount); } }","title":"Mosaic related requests"},{"location":"documentation/mosaic/#mosaic-related-requests","text":"NEM mosaics are assets that expose additional properties and other features. Each mosaic has an underlying mosaic definition. To be able to create a mosaic definition, an account must rent at least one root namespace which the mosaic definition can then refer to. Official Source","title":"Mosaic related requests"},{"location":"documentation/mosaic/#mosaichttp-definition","text":"export declare class MosaicHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets the mosaic definitions for a given namespace. The request supports paging. * @param namespace * @param id - The topmost mosaic definition database id up to which root mosaic definitions are returned. The parameter is optional. If not supplied the most recent mosaic definitiona are returned. * @param pageSize - The number of mosaic definition objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100. * @returns Observable<MosaicDefinition[]> */ getAllMosaicsGivenNamespace(namespace: string, id?: number, pageSize?: number): Observable<MosaicDefinition[]>; /** * Return the Mosaic Definition given a namespace and mosaic. Throw exception if no mosaic is found * @param {string} mosaicId * @returns {Observable<MosaicDefinition>} */ getMosaicDefinition(mosaicId: MosaicId): Observable<MosaicDefinition>; /** * Return a MosaicTransferable with the amount * @param {string} mosaicId * @param {number} amount * @returns {Observable<MosaicTransferable>} */ getMosaicTransferableWithAmount(mosaicId: MosaicId, amount: number): Observable<MosaicTransferable>; }","title":"MosaicHttp definition"},{"location":"documentation/mosaic/#mosaichttp-usage","text":"import {MosaicHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const mosaicHttp = new MosaicHttp(); const namespace = \"server\"; mosaicHttp.getAllMosaicsGivenNamespace(namespace).subscribe(mosaicDefinitions => { console.log(mosaicDefinitions); }); Output [ MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' }, id: MosaicId { namespaceId: 'server', name: 'testmosaic' }, description: 'descritpio', properties: MosaicProperties { initialSupply: 1000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: undefined, metaId: 447 }, MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' }, id: MosaicId { namespaceId: 'server', name: 'alcapone' }, description: 'the one and only al capone', properties: MosaicProperties { initialSupply: 10000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 }, metaId: 385 }, MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' }, id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' }, description: 'description', properties: MosaicProperties { initialSupply: 100000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 }, metaId: 384 } ] Run the code","title":"MosaicHttp usage"},{"location":"documentation/mosaic/#models","text":"","title":"Models"},{"location":"documentation/mosaic/#mosaicid","text":"/** * A mosaic id uniquely identifies an underlying mosaic definition. */ export declare class MosaicId { /** * The corresponding namespace id */ readonly namespaceId: string; /** * The name of the mosaic definition. */ readonly name: string; /** * constructor * @param namespaceId * @param name */ constructor(namespaceId: string, name: string); /** * Compares mosaicIds for equality * @param mosaicId * @returns {boolean} */ equals(mosaicId: MosaicId): boolean; /** * Mosaic Id description in format namespaceId:name ex: nem:xem */ description(): string; }","title":"MosaicId"},{"location":"documentation/mosaic/#mosaic","text":"/** * A mosaic describes an instance of a mosaic definition. Mosaics can be transferred by means of a transfer transaction. */ export declare class Mosaic { /** * The mosaic id */ readonly mosaicId: MosaicId; /** * The mosaic quantity. The quantity is always given in smallest units for the mosaic, i.e. if it has a divisibility of 3 the quantity is given in millis. */ readonly quantity: number; /** * constructor * @param mosaicId * @param quantity */ constructor(mosaicId: MosaicId, quantity: number); }","title":"Mosaic"},{"location":"documentation/mosaic/#mosaicdefinition","text":"/** * A mosaic definition describes an asset class. Some fields are mandatory while others are optional. * The properties of a mosaic definition always have a default value and only need to be supplied if they differ from the default value. */ export declare class MosaicDefinition { /** * The public key of the mosaic definition creator. */ readonly creator: PublicAccount; /** * The mosaic id */ readonly id: MosaicId; /** * The mosaic description. The description may have a length of up to 512 characters and cannot be empty. */ readonly description: string; /** * Mosaic properties */ readonly properties: MosaicProperties; /** * The optional levy for the mosaic. A creator can demand that each mosaic transfer induces an additional fee */ readonly levy?: MosaicLevy; /** * The id for the mosaic definition object. */ readonly metaId?: number; /** * constructor * @param creator * @param id * @param description * @param properties * @param levy * @param metaId */ constructor(creator: PublicAccount, id: MosaicId, description: string, properties: MosaicProperties, levy?: MosaicLevy, metaId?: number); } /** * Each mosaic definition comes with a set of properties. * Each property has a default value which will be applied in case it was not specified. * Future release may add additional properties to the set of available properties */ export declare class MosaicProperties { /** * initialSupply: The creator can specify an initial supply of mosaics when creating the definition. * The supply is given in entire units of the mosaic, not in smallest sub-units. * The initial supply must be in the range of 0 and 9,000,000,000. The default value is \"1000\". */ readonly initialSupply: number; /** * The creator can choose between a definition that allows a mosaic supply change at a later point or an immutable supply. * Allowed values for the property are \"true\" and \"false\". The default value is \"false\". */ readonly supplyMutable: boolean; /** * The creator can choose if the mosaic definition should allow for transfers of the mosaic among accounts other than the creator. * If the property 'transferable' is set to \"false\", only transfer transactions having the creator as sender or as recipient can transfer mosaics of that type. * If set to \"true\" the mosaics can be transferred to and from arbitrary accounts. * Allowed values for the property are thus \"true\" and \"false\". The default value is \"true\". */ readonly transferable: boolean; /** * The divisibility determines up to what decimal place the mosaic can be divided into. * Thus a divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics, i.e. milli mosaics is the smallest sub-unit. * When transferring mosaics via a transfer transaction the quantity transferred is given in multiples of those smallest parts. * The divisibility must be in the range of 0 and 6. The default value is \"0\". */ readonly divisibility: number; /** * constructor * @param divisibility * @param initialSupply * @param supplyMutable * @param transferable */ constructor(divisibility?: number, initialSupply?: number, transferable?: boolean, supplyMutable?: boolean); }","title":"MosaicDefinition"},{"location":"documentation/mosaic/#mosaiclevy","text":"export declare enum MosaicLevyType { Absolute = 1, Percentil = 2, } /** * A mosaic definition can optionally specify a levy for transferring those mosaics. This might be needed by legal entities needing to collect some taxes for transfers. */ export declare class MosaicLevy { /** * The levy type */ readonly type: MosaicLevyType; /** * The recipient of the levy. */ readonly recipient: Address; /** * The mosaic in which the levy is paid. */ readonly mosaicId: MosaicId; /** * The fee. The interpretation is dependent on the type of the levy */ readonly fee: number; /** * constructor * @param type * @param recipient * @param mosaicId * @param fee */ constructor(type: MosaicLevyType, recipient: Address, mosaicId: MosaicId, fee: number); }","title":"MosaicLevy"},{"location":"documentation/mosaic/#mosaictransferable","text":"/** * Mosaic transferable model */ export declare class MosaicTransferable { /** * Quantity to be send */ readonly quantity: number; /** * Mosaic definition properties */ readonly properties: MosaicProperties; /** * Mosaic id */ readonly mosaicId: MosaicId; /** * Levy */ readonly levy?: MosaicLevy; /** * constructor * @param mosaicId * @param properties * @param amount * @param levy */ constructor(mosaicId: MosaicId, properties: MosaicProperties, amount: number, levy?: MosaicLevy); /** * Create a MosaicTransferable object with mosaic definition * @param mosaicDefinition * @param quantity * @returns {MosaicTransferable} */ static createWithMosaicDefinition(mosaicDefinition: MosaicDefinition, quantity: number): MosaicTransferable; }","title":"MosaicTransferable"},{"location":"documentation/mosaic/#xem","text":"/** * XEM mosaic transferable */ export declare class XEM extends MosaicTransferable { /** * Divisiblity * @type {number} */ static DIVISIBILITY: number; /** * Initial supply * @type {number} */ static INITIALSUPPLY: number; /** * Is tranferable * @type {boolean} */ static TRANSFERABLE: boolean; /** * Is mutable * @type {boolean} */ static SUPPLYMUTABLE: boolean; /** * mosaicId * @type {MosaicId} */ static MOSAICID: MosaicId; /** * constructor * @param amount */ constructor(amount: number) { super(new MosaicId(\"nem\", \"xem\"), new MosaicProperties(6, 8999999999, true, false), amount); } }","title":"XEM"},{"location":"documentation/namespace/","text":"Namespace related requests NEM supports the concept of namespaces which is the NEM analog of internet domain names. A namespace is an identification string that consists of one or more parts that are concatenated by dots, for example 'makoto.metals.silver'. All namespaces are unique and thus can only have one owner at a time. A namespace that has only one part is called a root namespace, otherwise sub-namespace. Root namespaces can be rented by accounts for the duration of one year. One month before the root namespace expires the rental contract can be renewed for another year. If a root namespace rental contract is renewed, all sub-namespaces are valid for another year as well. If the root namespace is not renewed, it exires together with all sub-namespaces. One month after a root namespace expires, another account is able to rent that root namespace. The new owner does not inherit the sub-namespaces from the previous owner however. An account can only rent a sub-namespace if it owns the corresponding root namespace. Namespaces have certain restrictions with respected to the characters being allowed in the parts as well as the length of a part. A root namespace may have a length of 16 characters while sub-namespaces may have a length of 64 characters. Official Source NamespaceHttp definition export declare class NamespaceHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets the root namespaces. The requests supports paging, i.e. retrieving the root namespaces in batches of a specified size. * @param id - The topmost namespace database id up to which root namespaces are returned. The parameter is optional. If not supplied the most recent rented root namespaces are returned. * @param pageSize - (Optional) The number of namespace objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100. * @returns Observable<Namespace[]> */ getRootNamespaces(id: number, pageSize?: string): Observable<Namespace[]>; /** * Gets the namespace with given id. * @param namespace - The namespace id. * @returns Observable<Namespace> */ getNamespace(namespace: string): Observable<Namespace>; } NamespaceHttp usage import {NamespaceHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const namespaceHttp = new NamespaceHttp(); const id = 12344; namespaceHttp.getRootNamespaces(id).subscribe(namespaces => { console.log(namespaces); }); Output [ Namespace { name: 'ajkshgkerhkjerg', owner: Address { value: 'TDQJM2LZPKM4WRI44CF5TEUHRES5JCWQ3YRKGKUB', networkType: 152 }, height: 1034366, id: 409 }, Namespace { name: 'hitori', owner: Address { value: 'TCIY4MHDHZJ42NGHQ67PJXSWHLFACNMJLSM56VE3', networkType: 152 }, height: 1033761, id: 408 }, Namespace { name: 'vandelay', owner: Address { value: 'TAB5AEUDM3ALLDRLRLNMQYQXJXJZUSMDSEN5TND5', networkType: 152 }, height: 1032986, id: 405 }, Namespace { name: 'girish', owner: Address { value: 'TAFHY34ZKCJIYI6LPEJXVOCMVK5QHQXJ5AAPO5RG', networkType: 152 }, height: 1031091, id: 403 }, Namespace { name: 'multisigns', owner: Address { value: 'TDAEIWWYWZRE3VSUHXG77L5TW22BHNGV5FAPH2XJ', networkType: 152 }, height: 1029552, id: 402 }, Namespace { name: 'foobarltd', owner: Address { value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH', networkType: 152 }, height: 1029471, id: 401 }, Namespace { name: 'jabo', owner: Address { value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH', networkType: 152 }, height: 1029471, id: 400 }, Namespace { name: 'newpart', owner: Address { value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA', networkType: 152 }, height: 1028225, id: 399 }, Namespace { name: 'govegan', owner: Address { value: 'TBXWZW35ZJDHLXYDQ6EQTWKHJSWQG2EQYWDRKXXU', networkType: 152 }, height: 1027004, id: 398 }, Namespace { name: 'tescik11', owner: Address { value: 'TCWHXK5EI3RJIUV5DXURIIEASECB57L4N5EEGI24', networkType: 152 }, height: 1026918, id: 397 }, Namespace { name: 'fintech', owner: Address { value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT', networkType: 152 }, height: 1026764, id: 396 }, Namespace { name: 'kung', owner: Address { value: 'TAU5HO3DRQZNELFEMZZTUKQEZGQ7IUAHKPO7OOLK', networkType: 152 }, height: 1025402, id: 395 }, Namespace { name: 'dim', owner: Address { value: 'TDXTBQUI5PCPHBZKTHBSLMCJGKDWV3RVHHOCPX2V', networkType: 152 }, height: 1022794, id: 393 }, Namespace { name: 'multisig', owner: Address { value: 'TAVBSWJV3XNA7MRVEH3XQQYRTJGXM3VRKCQDKHR7', networkType: 152 }, height: 1021094, id: 392 }, Namespace { name: 'jeffmcdonald', owner: Address { value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344', networkType: 152 }, height: 1019783, id: 391 }, Namespace { name: 'lonwon', owner: Address { value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344', networkType: 152 }, height: 1019768, id: 390 }, Namespace { name: 'bok_tor', owner: Address { value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT', networkType: 152 }, height: 1018248, id: 389 }, Namespace { name: 'macy', owner: Address { value: 'TCF2JGBTB7LM6Y3VP22DSSFRUGDYZYVQMUGDX4TL', networkType: 152 }, height: 1018245, id: 388 }, Namespace { name: 'foo', owner: Address { value: 'TAOMBDIWECBSP7QGEKGUE476QOCRRN6MEOSQQ4RP', networkType: 152 }, height: 1017249, id: 387 }, Namespace { name: 'namespace_root1', owner: Address { value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK', networkType: 152 }, height: 1017028, id: 385 }, Namespace { name: 'root_namespace1', owner: Address { value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK', networkType: 152 }, height: 1017028, id: 384 }, Namespace { name: 'rivalkingdoms', owner: Address { value: 'TCBAR5KG4HHTF3EBBCQETVYUJVONF7XKWSYCI2CA', networkType: 152 }, height: 1016967, id: 382 }, Namespace { name: 'szpregel', owner: Address { value: 'TDFPX267BPLVUB2VF3OY2LSACGSF4XWLVPUXY3FC', networkType: 152 }, height: 1016780, id: 381 }, Namespace { name: 'marvel', owner: Address { value: 'TDSPQOUYI6VBGD2SAERJ73ZYMNY5ACJSYNTZSUHP', networkType: 152 }, height: 1016477, id: 379 }, Namespace { name: 'test', owner: Address { value: 'TADEADUYY4FE5JSHL22VNASNYXYXEJVZ7BF2E3IO', networkType: 152 }, height: 1015685, id: 378 } ] Run the code Models Namespace /** * A namespace is the NEM version of a domain. You can rent a namespace for the duration of a year by paying a fee. * The naming of the parts of a namespace has certain restrictions, see the corresponding chapter on namespaces. */ export declare class Namespace { /** * The fully qualified name of the namespace, also named namespace id. */ readonly name: string; /** * The owner of the namespace. */ readonly owner: Address; /** * The height at which the ownership begins. */ readonly height: number; /** * The database id for the namespace object. */ readonly id?: number; }","title":"Namespace related requests"},{"location":"documentation/namespace/#namespace-related-requests","text":"NEM supports the concept of namespaces which is the NEM analog of internet domain names. A namespace is an identification string that consists of one or more parts that are concatenated by dots, for example 'makoto.metals.silver'. All namespaces are unique and thus can only have one owner at a time. A namespace that has only one part is called a root namespace, otherwise sub-namespace. Root namespaces can be rented by accounts for the duration of one year. One month before the root namespace expires the rental contract can be renewed for another year. If a root namespace rental contract is renewed, all sub-namespaces are valid for another year as well. If the root namespace is not renewed, it exires together with all sub-namespaces. One month after a root namespace expires, another account is able to rent that root namespace. The new owner does not inherit the sub-namespaces from the previous owner however. An account can only rent a sub-namespace if it owns the corresponding root namespace. Namespaces have certain restrictions with respected to the characters being allowed in the parts as well as the length of a part. A root namespace may have a length of 16 characters while sub-namespaces may have a length of 64 characters. Official Source","title":"Namespace related requests"},{"location":"documentation/namespace/#namespacehttp-definition","text":"export declare class NamespaceHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets the root namespaces. The requests supports paging, i.e. retrieving the root namespaces in batches of a specified size. * @param id - The topmost namespace database id up to which root namespaces are returned. The parameter is optional. If not supplied the most recent rented root namespaces are returned. * @param pageSize - (Optional) The number of namespace objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100. * @returns Observable<Namespace[]> */ getRootNamespaces(id: number, pageSize?: string): Observable<Namespace[]>; /** * Gets the namespace with given id. * @param namespace - The namespace id. * @returns Observable<Namespace> */ getNamespace(namespace: string): Observable<Namespace>; }","title":"NamespaceHttp definition"},{"location":"documentation/namespace/#namespacehttp-usage","text":"import {NamespaceHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const namespaceHttp = new NamespaceHttp(); const id = 12344; namespaceHttp.getRootNamespaces(id).subscribe(namespaces => { console.log(namespaces); }); Output [ Namespace { name: 'ajkshgkerhkjerg', owner: Address { value: 'TDQJM2LZPKM4WRI44CF5TEUHRES5JCWQ3YRKGKUB', networkType: 152 }, height: 1034366, id: 409 }, Namespace { name: 'hitori', owner: Address { value: 'TCIY4MHDHZJ42NGHQ67PJXSWHLFACNMJLSM56VE3', networkType: 152 }, height: 1033761, id: 408 }, Namespace { name: 'vandelay', owner: Address { value: 'TAB5AEUDM3ALLDRLRLNMQYQXJXJZUSMDSEN5TND5', networkType: 152 }, height: 1032986, id: 405 }, Namespace { name: 'girish', owner: Address { value: 'TAFHY34ZKCJIYI6LPEJXVOCMVK5QHQXJ5AAPO5RG', networkType: 152 }, height: 1031091, id: 403 }, Namespace { name: 'multisigns', owner: Address { value: 'TDAEIWWYWZRE3VSUHXG77L5TW22BHNGV5FAPH2XJ', networkType: 152 }, height: 1029552, id: 402 }, Namespace { name: 'foobarltd', owner: Address { value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH', networkType: 152 }, height: 1029471, id: 401 }, Namespace { name: 'jabo', owner: Address { value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH', networkType: 152 }, height: 1029471, id: 400 }, Namespace { name: 'newpart', owner: Address { value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA', networkType: 152 }, height: 1028225, id: 399 }, Namespace { name: 'govegan', owner: Address { value: 'TBXWZW35ZJDHLXYDQ6EQTWKHJSWQG2EQYWDRKXXU', networkType: 152 }, height: 1027004, id: 398 }, Namespace { name: 'tescik11', owner: Address { value: 'TCWHXK5EI3RJIUV5DXURIIEASECB57L4N5EEGI24', networkType: 152 }, height: 1026918, id: 397 }, Namespace { name: 'fintech', owner: Address { value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT', networkType: 152 }, height: 1026764, id: 396 }, Namespace { name: 'kung', owner: Address { value: 'TAU5HO3DRQZNELFEMZZTUKQEZGQ7IUAHKPO7OOLK', networkType: 152 }, height: 1025402, id: 395 }, Namespace { name: 'dim', owner: Address { value: 'TDXTBQUI5PCPHBZKTHBSLMCJGKDWV3RVHHOCPX2V', networkType: 152 }, height: 1022794, id: 393 }, Namespace { name: 'multisig', owner: Address { value: 'TAVBSWJV3XNA7MRVEH3XQQYRTJGXM3VRKCQDKHR7', networkType: 152 }, height: 1021094, id: 392 }, Namespace { name: 'jeffmcdonald', owner: Address { value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344', networkType: 152 }, height: 1019783, id: 391 }, Namespace { name: 'lonwon', owner: Address { value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344', networkType: 152 }, height: 1019768, id: 390 }, Namespace { name: 'bok_tor', owner: Address { value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT', networkType: 152 }, height: 1018248, id: 389 }, Namespace { name: 'macy', owner: Address { value: 'TCF2JGBTB7LM6Y3VP22DSSFRUGDYZYVQMUGDX4TL', networkType: 152 }, height: 1018245, id: 388 }, Namespace { name: 'foo', owner: Address { value: 'TAOMBDIWECBSP7QGEKGUE476QOCRRN6MEOSQQ4RP', networkType: 152 }, height: 1017249, id: 387 }, Namespace { name: 'namespace_root1', owner: Address { value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK', networkType: 152 }, height: 1017028, id: 385 }, Namespace { name: 'root_namespace1', owner: Address { value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK', networkType: 152 }, height: 1017028, id: 384 }, Namespace { name: 'rivalkingdoms', owner: Address { value: 'TCBAR5KG4HHTF3EBBCQETVYUJVONF7XKWSYCI2CA', networkType: 152 }, height: 1016967, id: 382 }, Namespace { name: 'szpregel', owner: Address { value: 'TDFPX267BPLVUB2VF3OY2LSACGSF4XWLVPUXY3FC', networkType: 152 }, height: 1016780, id: 381 }, Namespace { name: 'marvel', owner: Address { value: 'TDSPQOUYI6VBGD2SAERJ73ZYMNY5ACJSYNTZSUHP', networkType: 152 }, height: 1016477, id: 379 }, Namespace { name: 'test', owner: Address { value: 'TADEADUYY4FE5JSHL22VNASNYXYXEJVZ7BF2E3IO', networkType: 152 }, height: 1015685, id: 378 } ] Run the code","title":"NamespaceHttp usage"},{"location":"documentation/namespace/#models","text":"","title":"Models"},{"location":"documentation/namespace/#namespace","text":"/** * A namespace is the NEM version of a domain. You can rent a namespace for the duration of a year by paying a fee. * The naming of the parts of a namespace has certain restrictions, see the corresponding chapter on namespaces. */ export declare class Namespace { /** * The fully qualified name of the namespace, also named namespace id. */ readonly name: string; /** * The owner of the namespace. */ readonly owner: Address; /** * The height at which the ownership begins. */ readonly height: number; /** * The database id for the namespace object. */ readonly id?: number; }","title":"Namespace"},{"location":"documentation/node/","text":"Node related requests Nodes are the entities that exchange data in a network. A node is essentially a NIS instance running on a computer. To be able to communicate with the network, a node needs to be booted. Through node requests it is possible to discover other nodes in the network, learn about other nodes experiences and get information about their current chain height. Official Source NodeHttp definition export declare class NodeHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets basic information about a node * @returns Observable<Node> */ getNodeInfo(): Observable<Node>; /** * Gets extended information about a node * @returns Observable<NisNodeInfo> */ getNisNodeInfo(): Observable<NisNodeInfo>; /** * Gets an array of all known nodes in the neighborhood. * @returns Observable<NodeCollection> */ getAllNodes(): Observable<NodeCollection>; /** * Gets an array of all nodes with status 'active' in the neighborhood. * @returns Observable<Node[]> */ getActiveNodes(): Observable<Node[]>; /** * Gets an array of active nodes in the neighborhood that are selected for broadcasts. * @returns Observable<Node[]> */ getActiveNeighbourNodes(): Observable<Node[]>; /** * Requests the chain height from every node in the active node list and returns the maximum height seen. * @returns Observable<BlockHeight> */ getMaximumChainHeightInActiveNeighborhood(): Observable<BlockHeight>; /** * Requests the chain height from every node in the active node list and returns the maximum height seen. * @returns Observable<ExtendedNodeExperience[]> */ getNodeExperiences(): Observable<ExtendedNodeExperience[]>; } NodeHttp usage import {NodeHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const nodeHttp = new NodeHttp(); nodeHttp.getNodeInfo().subscribe(node => { console.log(node); }); Output: Node { metaData: NodeMetaData { features: 3, network: -104, application: null, version: '0.6.92-BETA', platform: 'Oracle Corporation (1.8.0_40) on Linux' }, endpoint: NodeEndpoint { protocol: 'http', port: 7890, host: '104.128.226.60' }, identity: NodeIdentity { name: 'Hi, I am BigAlice2', publicAccount: undefined } } Run the code Models Node /** * Nodes are the entities that perform communication in the network like sending and receiving data. * A node has an identity which is tied to an account through which the node can identify itself to the network. * The communication is done through the endpoint of the node. Additionally a node provides meta data information. */ export declare class Node { /** * Denotes the beginning of the meta data substructure. */ readonly metaData: NodeMetaData; /** * Denotes the beginning of the endpoint substructure. */ readonly endpoint: NodeEndpoint; /** * Denotes the beginning of the identity substructure. */ readonly identity: NodeIdentity; } /** * Node meta data */ export declare class NodeMetaData { /** * The number of features the nodes has. */ readonly features: number; /** * The network id */ readonly network: NetworkTypes; /** * The name of the application that is running the node. */ readonly application: string; /** * The version of the application. */ readonly version: string; /** * The underlying platform (OS, java version). */ readonly platform: string; } /** * Node endpoint */ export declare class NodeEndpoint { /** * The protocol used for the communication (HTTP or HTTPS). */ readonly protocol: string; /** * The port used for the communication. */ readonly port: number; /** * The IP address of the endpoint. */ readonly host: string; } /** * Node identity */ export declare class NodeIdentity { /** * The name of the node. */ readonly name: string; /** * The public account used to identify the node. */ readonly publicAccount: PublicAccount; } NisNodeInfo /** * A NodeCollection object holds arrays of nodes with different statuses. */ export declare class NisNodeInfo { /** * Denotes the beginning of the node substructure. */ readonly node: Node; /** * Denotes the beginning of the application meta data substructure. */ readonly nisInfo: ApplicationMetaData; } /** * The application meta data object supplies additional information about the application running on a node. */ export declare class ApplicationMetaData { /** * The current network time, i.e. the number of seconds that have elapsed since the creation of the nemesis block. */ readonly currentTime: number; /** * The name of the application running on the node. */ readonly application: string; /** * The network time when the application was started. */ readonly startTime: number; /** * The application version. */ readonly version: string; /** * The signer of the certificate used by the application. */ readonly signer: string; } NodeCollection /** * A NodeCollection object holds arrays of nodes with different statuses. */ export declare class NodeCollection { /** * A connection to the node cannot be established. */ readonly inactive: Node[]; /** * A connection can be established and the remote node responds in a timely manner. */ readonly active: Node[]; /** * A connection can be established but the node cannot provide information within the timeout limits. */ readonly busy: Node[]; /** * A fatal error occurs when trying to establish a connection or the node couldn't authenticate itself correctly. */ readonly failure: Node[]; } ExtendedNodeExperience /** * When exchanging data with other nodes the result of the communication is divided into three * different outcomes: success, neutral and failure. * In the cases of success and failure the result is saved to be able to judge the quality of a node. * This has influence on the probability that a certain node is selected as partner. */ export declare class ExtendedNodeExperience { /** * Denotes the beginning of the of the Node substructure. */ readonly node: Node; /** * The number of synchronization attempts the node had with the remote node. */ readonly syncs: number; /** * Denotes the beginning of the of the NodeExperience substructure. */ readonly experience: ExtendedNodeExperienceData; } /** * Node experience data */ export declare class ExtendedNodeExperienceData { /** * The number of successful communications with the remote node. */ readonly s: number; /** * The number of failed communications with the remote node. */ readonly f: number; }","title":"Node related requests"},{"location":"documentation/node/#node-related-requests","text":"Nodes are the entities that exchange data in a network. A node is essentially a NIS instance running on a computer. To be able to communicate with the network, a node needs to be booted. Through node requests it is possible to discover other nodes in the network, learn about other nodes experiences and get information about their current chain height. Official Source","title":"Node related requests"},{"location":"documentation/node/#nodehttp-definition","text":"export declare class NodeHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Gets basic information about a node * @returns Observable<Node> */ getNodeInfo(): Observable<Node>; /** * Gets extended information about a node * @returns Observable<NisNodeInfo> */ getNisNodeInfo(): Observable<NisNodeInfo>; /** * Gets an array of all known nodes in the neighborhood. * @returns Observable<NodeCollection> */ getAllNodes(): Observable<NodeCollection>; /** * Gets an array of all nodes with status 'active' in the neighborhood. * @returns Observable<Node[]> */ getActiveNodes(): Observable<Node[]>; /** * Gets an array of active nodes in the neighborhood that are selected for broadcasts. * @returns Observable<Node[]> */ getActiveNeighbourNodes(): Observable<Node[]>; /** * Requests the chain height from every node in the active node list and returns the maximum height seen. * @returns Observable<BlockHeight> */ getMaximumChainHeightInActiveNeighborhood(): Observable<BlockHeight>; /** * Requests the chain height from every node in the active node list and returns the maximum height seen. * @returns Observable<ExtendedNodeExperience[]> */ getNodeExperiences(): Observable<ExtendedNodeExperience[]>; }","title":"NodeHttp definition"},{"location":"documentation/node/#nodehttp-usage","text":"import {NodeHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const nodeHttp = new NodeHttp(); nodeHttp.getNodeInfo().subscribe(node => { console.log(node); }); Output: Node { metaData: NodeMetaData { features: 3, network: -104, application: null, version: '0.6.92-BETA', platform: 'Oracle Corporation (1.8.0_40) on Linux' }, endpoint: NodeEndpoint { protocol: 'http', port: 7890, host: '104.128.226.60' }, identity: NodeIdentity { name: 'Hi, I am BigAlice2', publicAccount: undefined } } Run the code","title":"NodeHttp usage"},{"location":"documentation/node/#models","text":"","title":"Models"},{"location":"documentation/node/#node","text":"/** * Nodes are the entities that perform communication in the network like sending and receiving data. * A node has an identity which is tied to an account through which the node can identify itself to the network. * The communication is done through the endpoint of the node. Additionally a node provides meta data information. */ export declare class Node { /** * Denotes the beginning of the meta data substructure. */ readonly metaData: NodeMetaData; /** * Denotes the beginning of the endpoint substructure. */ readonly endpoint: NodeEndpoint; /** * Denotes the beginning of the identity substructure. */ readonly identity: NodeIdentity; } /** * Node meta data */ export declare class NodeMetaData { /** * The number of features the nodes has. */ readonly features: number; /** * The network id */ readonly network: NetworkTypes; /** * The name of the application that is running the node. */ readonly application: string; /** * The version of the application. */ readonly version: string; /** * The underlying platform (OS, java version). */ readonly platform: string; } /** * Node endpoint */ export declare class NodeEndpoint { /** * The protocol used for the communication (HTTP or HTTPS). */ readonly protocol: string; /** * The port used for the communication. */ readonly port: number; /** * The IP address of the endpoint. */ readonly host: string; } /** * Node identity */ export declare class NodeIdentity { /** * The name of the node. */ readonly name: string; /** * The public account used to identify the node. */ readonly publicAccount: PublicAccount; }","title":"Node"},{"location":"documentation/node/#nisnodeinfo","text":"/** * A NodeCollection object holds arrays of nodes with different statuses. */ export declare class NisNodeInfo { /** * Denotes the beginning of the node substructure. */ readonly node: Node; /** * Denotes the beginning of the application meta data substructure. */ readonly nisInfo: ApplicationMetaData; } /** * The application meta data object supplies additional information about the application running on a node. */ export declare class ApplicationMetaData { /** * The current network time, i.e. the number of seconds that have elapsed since the creation of the nemesis block. */ readonly currentTime: number; /** * The name of the application running on the node. */ readonly application: string; /** * The network time when the application was started. */ readonly startTime: number; /** * The application version. */ readonly version: string; /** * The signer of the certificate used by the application. */ readonly signer: string; }","title":"NisNodeInfo"},{"location":"documentation/node/#nodecollection","text":"/** * A NodeCollection object holds arrays of nodes with different statuses. */ export declare class NodeCollection { /** * A connection to the node cannot be established. */ readonly inactive: Node[]; /** * A connection can be established and the remote node responds in a timely manner. */ readonly active: Node[]; /** * A connection can be established but the node cannot provide information within the timeout limits. */ readonly busy: Node[]; /** * A fatal error occurs when trying to establish a connection or the node couldn't authenticate itself correctly. */ readonly failure: Node[]; }","title":"NodeCollection"},{"location":"documentation/node/#extendednodeexperience","text":"/** * When exchanging data with other nodes the result of the communication is divided into three * different outcomes: success, neutral and failure. * In the cases of success and failure the result is saved to be able to judge the quality of a node. * This has influence on the probability that a certain node is selected as partner. */ export declare class ExtendedNodeExperience { /** * Denotes the beginning of the of the Node substructure. */ readonly node: Node; /** * The number of synchronization attempts the node had with the remote node. */ readonly syncs: number; /** * Denotes the beginning of the of the NodeExperience substructure. */ readonly experience: ExtendedNodeExperienceData; } /** * Node experience data */ export declare class ExtendedNodeExperienceData { /** * The number of successful communications with the remote node. */ readonly s: number; /** * The number of failed communications with the remote node. */ readonly f: number; }","title":"ExtendedNodeExperience"},{"location":"documentation/overview/","text":"Installation Step1 : Add nem-library dependency to package.json $> npm install nem-library --save Step2 : Setup phase In your application startup file, initialize NEMLibrary. import { NEMLibrary, NetworkTypes } from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); Your application can have two modes, NetworkTypes.TEST_NET and NetworkTypes.MAIN_NET . Depending on the environment that you want to use, you should call the bootstrap method, with MAIN_NET or TEST_NET . Because the application should have a unique environment, calling NEMLibrary.bootstrap(_) multiple times will throw an Error . In case you need to change between environments in runtime, call NEMLibrary.reset() first. Configure endpoints Each infrastructure endpoints share the same constructor. // Using custom NIS Node const accountHttp = new AccountHttp([{ protocol: \"http\", domain: \"104.128.226.60\", port: 7890 }]); // Using default NIS Node const accountHttpWithDefaultConfig = new AccountHttp(); The default values are: TEST NET Parameter Value protocol http domain bigalice2.nem.ninja port 7890 Parameter Value protocol https domain pretestnet1.nem.ninja port 7778 MAIN NET Parameter Value protocol http domain alice6.nem.ninja port 7890 Parameter Value protocol https domain nis2.wnsl.biz port 7779","title":"Installation"},{"location":"documentation/overview/#installation","text":"Step1 : Add nem-library dependency to package.json $> npm install nem-library --save Step2 : Setup phase In your application startup file, initialize NEMLibrary. import { NEMLibrary, NetworkTypes } from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); Your application can have two modes, NetworkTypes.TEST_NET and NetworkTypes.MAIN_NET . Depending on the environment that you want to use, you should call the bootstrap method, with MAIN_NET or TEST_NET . Because the application should have a unique environment, calling NEMLibrary.bootstrap(_) multiple times will throw an Error . In case you need to change between environments in runtime, call NEMLibrary.reset() first.","title":"Installation"},{"location":"documentation/overview/#configure-endpoints","text":"Each infrastructure endpoints share the same constructor. // Using custom NIS Node const accountHttp = new AccountHttp([{ protocol: \"http\", domain: \"104.128.226.60\", port: 7890 }]); // Using default NIS Node const accountHttpWithDefaultConfig = new AccountHttp(); The default values are: TEST NET Parameter Value protocol http domain bigalice2.nem.ninja port 7890 Parameter Value protocol https domain pretestnet1.nem.ninja port 7778 MAIN NET Parameter Value protocol http domain alice6.nem.ninja port 7890 Parameter Value protocol https domain nis2.wnsl.biz port 7779","title":"Configure endpoints"},{"location":"documentation/service/","text":"AccountOwnedMosaicsService Definition /** * Service to get account owned mosaics */ export declare class AccountOwnedMosaicsService { /** * accountHttp */ accountHttp: AccountHttp; /** * mosaicHttp */ mosaicHttp: MosaicHttp; /** * constructor * @param accountHttp * @param mosaicHttp */ constructor(accountHttp: AccountHttp, mosaicHttp: MosaicHttp); /** * Account owned mosaics definitions * @param address * @returns {Observable<MosaicDefinition[]>} */ fromAddress(address: Address): Observable<MosaicDefinition[]>; } Usage import {NEMLibrary, NetworkTypes, Address, AccountOwnedMosaicsService, AccountHttp, MosaicHttp} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let address = new Address(\"\"); let accountOwnedMosaics = new AccountOwnedMosaicsService(new AccountHttp(), new MosaicHttp()); accountOwnedMosaics.fromAddress(address).subscribe(mosaics => { console.log(mosaics); }); Output: [ MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '34f510bc0173a1b65a0531e2fbb65b6db764234842d89b905e3071c4732ca3fd' }, id: MosaicId { namespaceId: 'country.cat', name: 'patufet' }, description: 'patufet coin', properties: MosaicProperties { initialSupply: 7000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: undefined, metaId: 319 }, MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' }, id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' }, description: 'description', properties: MosaicProperties { initialSupply: 100000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 }, metaId: 386 }] Run the code MosaicService Definition /** * Mosaic service */ export declare class MosaicService { /** * mosaicHttp */ private mosaicHttp; /** * constructor * @param mosaicHttp */ constructor(mosaicHttp: MosaicHttp); /** * Calculate levy for a given mosaicTransferable * @param mosaicTransferable * @returns {any} */ calculateLevy(mosaicTransferable: MosaicTransferable): Observable<number>; } Usage import {NEMLibrary, NetworkTypes, MosaicId, MosaicLevy, MosaicLevyType, Address, MosaicTransferable, MosaicHttp, MosaicProperties, MosaicService} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let levyMosaicId = new MosaicId(\"server\", \"testmosaic\"); let levy = new MosaicLevy(MosaicLevyType.Percentil, new Address(\"\"), levyMosaicId, 5); let mosaicTransferable = new MosaicTransferable(new MosaicId(\"server\", \"mosaic\"), new MosaicProperties(0, 10000000, true, false), 100000, levy); let mosaicService = new MosaicService(new MosaicHttp()); mosaicService.calculateLevy(mosaicTransferable).subscribe(levy => { console.log(levy); }); Output: 5 Run the code QRService Definition export declare class QRService { /** * Generates the QR text from the wallet * @returns {string} */ generateWalletQRText(password: Password, wallet: Wallet): string; /** * Decrypt the private key from the QR text * @param password password * @param qrWalletText Object generated by generateWalletQRText method * @return Decrypted private key */ decryptWalletQRText(password: Password, qrWalletText: QRWalletText): string; /** * Generates the QR text from an address * @returns {string} */ generateAddressQRText(address: Address): string; /** * Decrypt the address from the QR text * @param qrAddressText Object generated by generateAddressQRText method * @return Address */ decryptAddressQRText(qrAddressText: QRAddressText): Address; /** * Generates the QR text from a transaction * @returns {string} */ generateTransactionQRText(recipientAddress: Address, amount: number, msg: string): string; /** * Decrypt the transaction from the QR text * @param qrTransactionText Object generated by generateTransactionQRText method * @return TransferTransaction */ decryptTrasactionQRText(qrTransactionText: QRTransactionText): TransferTransaction; }","title":"AccountOwnedMosaicsService"},{"location":"documentation/service/#accountownedmosaicsservice","text":"Definition /** * Service to get account owned mosaics */ export declare class AccountOwnedMosaicsService { /** * accountHttp */ accountHttp: AccountHttp; /** * mosaicHttp */ mosaicHttp: MosaicHttp; /** * constructor * @param accountHttp * @param mosaicHttp */ constructor(accountHttp: AccountHttp, mosaicHttp: MosaicHttp); /** * Account owned mosaics definitions * @param address * @returns {Observable<MosaicDefinition[]>} */ fromAddress(address: Address): Observable<MosaicDefinition[]>; } Usage import {NEMLibrary, NetworkTypes, Address, AccountOwnedMosaicsService, AccountHttp, MosaicHttp} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let address = new Address(\"\"); let accountOwnedMosaics = new AccountOwnedMosaicsService(new AccountHttp(), new MosaicHttp()); accountOwnedMosaics.fromAddress(address).subscribe(mosaics => { console.log(mosaics); }); Output: [ MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '34f510bc0173a1b65a0531e2fbb65b6db764234842d89b905e3071c4732ca3fd' }, id: MosaicId { namespaceId: 'country.cat', name: 'patufet' }, description: 'patufet coin', properties: MosaicProperties { initialSupply: 7000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: undefined, metaId: 319 }, MosaicDefinition { creator: PublicAccount { address: [Object], publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' }, id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' }, description: 'description', properties: MosaicProperties { initialSupply: 100000000, supplyMutable: true, transferable: true, divisibility: 0 }, levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 }, metaId: 386 }] Run the code","title":"AccountOwnedMosaicsService"},{"location":"documentation/service/#mosaicservice","text":"Definition /** * Mosaic service */ export declare class MosaicService { /** * mosaicHttp */ private mosaicHttp; /** * constructor * @param mosaicHttp */ constructor(mosaicHttp: MosaicHttp); /** * Calculate levy for a given mosaicTransferable * @param mosaicTransferable * @returns {any} */ calculateLevy(mosaicTransferable: MosaicTransferable): Observable<number>; } Usage import {NEMLibrary, NetworkTypes, MosaicId, MosaicLevy, MosaicLevyType, Address, MosaicTransferable, MosaicHttp, MosaicProperties, MosaicService} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let levyMosaicId = new MosaicId(\"server\", \"testmosaic\"); let levy = new MosaicLevy(MosaicLevyType.Percentil, new Address(\"\"), levyMosaicId, 5); let mosaicTransferable = new MosaicTransferable(new MosaicId(\"server\", \"mosaic\"), new MosaicProperties(0, 10000000, true, false), 100000, levy); let mosaicService = new MosaicService(new MosaicHttp()); mosaicService.calculateLevy(mosaicTransferable).subscribe(levy => { console.log(levy); }); Output: 5 Run the code","title":"MosaicService"},{"location":"documentation/service/#qrservice","text":"Definition export declare class QRService { /** * Generates the QR text from the wallet * @returns {string} */ generateWalletQRText(password: Password, wallet: Wallet): string; /** * Decrypt the private key from the QR text * @param password password * @param qrWalletText Object generated by generateWalletQRText method * @return Decrypted private key */ decryptWalletQRText(password: Password, qrWalletText: QRWalletText): string; /** * Generates the QR text from an address * @returns {string} */ generateAddressQRText(address: Address): string; /** * Decrypt the address from the QR text * @param qrAddressText Object generated by generateAddressQRText method * @return Address */ decryptAddressQRText(qrAddressText: QRAddressText): Address; /** * Generates the QR text from a transaction * @returns {string} */ generateTransactionQRText(recipientAddress: Address, amount: number, msg: string): string; /** * Decrypt the transaction from the QR text * @param qrTransactionText Object generated by generateTransactionQRText method * @return TransferTransaction */ decryptTrasactionQRText(qrTransactionText: QRTransactionText): TransferTransaction; }","title":"QRService"},{"location":"documentation/transaction/","text":"Initiating transactions requests Transactions are the way of transferring NEM and/or messages from one account to another. Once a transaction is initiated, it is still unconfirmed and thus not yet accepted by the network. At this point, it is not yet clear if it will get included in a block. Never rely on a transaction which has the state 'unconfirmed'. Once it is included in a block, the transaction gets processed and, in case of a transfer transaction, the amount stated in the transaction gets transferred from the sender's account to the recipient's account. Additionally, the transaction fee is deducted from the sender's account. The transaction is said to have 0 confirmations at this point. When another block is added to the blockchain the transaction has 1 confirmation. The next block added to the chain will give it 2 confirmations and so on. Cryptocurrencies have the ability to roll back part of the blockchain. This is essential for being able to resolve forks of the blockchain. There is, however, a maximum number of blocks that can be rolled back, which is called the \"rewrite limit\". Hence, forks can only be resolved up to a certain depth too. NEM has a rewrite limit of 360 blocks. Once a transaction has more than 360 confirmations, it cannot be reversed. In real life, forks that are deeper than 20 blocks do not happen, unless there was some severe problem with the blockchain due to a bug in the code or an attack of some kind. Official Source TransactionHttp definition export declare class TransactionHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Send the signed transaction * @param transaction * @returns Observable<NemAnnounceResult> */ announceTransaction(transaction: SignedTransaction): Observable<NemAnnounceResult>; /** * Receive a transaction by its hash * @param {string} hash - transaction hash * @returns Observable<Transaction> */ getByHash(hash: string): Observable<Transaction>; } TransactionHttp usage import { AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, SignedTransaction } from \"nem-library\"; import {XEM} from \"nem-library/dist/src/models/mosaic/XEM\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY; const cosignerAccount = Account.createWithPrivateKey(privateKey); const transferTransaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(2), EmptyMessage ); const multisigTransaction = MultisigTransaction.create( TimeWindow.createWithDeadline(), transferTransaction, PublicAccount.createWithPublicKey(multisigAccountPublicKey) ); const transactionHttp = new TransactionHttp(); const signedTransaction: SignedTransaction = cosignerAccount.signTransaction(multisigTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Output NemAnnounceResult { type: 1, code: 1, message: 'SUCCESS', transactionHash: { data: '56b4d3e38cb5b707d4b96776116396c2885fd09be6945637f5657204528001b7' }, innerTransactionHash: { data: 'a61ce8d0df9aac98ae68e7d88a2f2bb453deb202fd95cf3cf375fde35e4e6794' } } Run the code Models TimeWindow export declare class TimeWindow { static timestampNemesisBlock: number; /** * The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block. * If a transaction does not get included in a block before the deadline is reached, it is deleted. */ deadline: LocalDateTime; /** * The number of seconds elapsed since the creation of the nemesis block. */ timeStamp: LocalDateTime; /** * @param deadline * @param chronoUnit * @returns {TimeWindow} */ static createWithDeadline(deadline?: number, chronoUnit?: ChronoUnit): TimeWindow; } TransactionInfo export declare class TransactionInfo { /** * The height of the block in which the transaction was included. */ readonly height: number; /** * The id of the transaction. */ readonly id: number; /** * The transaction hash. */ readonly hash: HashData; /** * constructor * @param height * @param id * @param hash */ constructor(height: number, id: number, hash: HashData); } export declare class MultisigTransactionInfo extends TransactionInfo { /** * The hash of the inner transaction. This entry is only available for multisig transactions. */ readonly innerHash: HashData; /** * constructor * @param height * @param id * @param hash * @param innerHash */ constructor(height: number, id: number, hash: HashData, innerHash: HashData); } TransactionTypes /** * Static class containing transaction type constants. */ export declare class TransactionTypes { /** * Transfer Transaction * @type {number} */ static readonly TRANSFER: number; /** * Importance transfer transaction. * @type {number} */ static readonly IMPORTANCE_TRANSFER: number; /** * A new asset transaction. * @type {number} */ static readonly ASSET_NEW: number; /** * An asset ask transaction. * @type {number} */ static readonly ASSET_ASK: number; /** * An asset bid transaction. * @type {number} */ static readonly ASSET_BID: number; /** * A snapshot transaction. * @type {number} */ static readonly SNAPSHOT: number; /** * A multisig change transaction (e.g. announce an account as multi-sig). * @type {number} */ static readonly MULTISIG_AGGREGATE_MODIFICATION: number; /** * A multisig signature transaction. * @type {number} */ static readonly MULTISIG_SIGNATURE: number; /** * A multisig transaction. * @type {number} */ static readonly MULTISIG: number; /** * A provision namespace transaction. * @type {number} */ static readonly PROVISION_NAMESPACE: number; /** * A mosaic definition creation transaction. * @type {number} */ static readonly MOSAIC_DEFINITION_CREATION: number; /** * A mosaic supply change transaction. * @type {number} */ static readonly MOSAIC_SUPPLY_CHANGE: number; /** * Gets all multisig embeddable types. * @returns {number[]} */ static getMultisigEmbeddableTypes(): number[]; /** * Gets all block embeddable types. * @returns {number[]} */ static getBlockEmbeddableTypes(): number[]; /** * Gets all active types. * @returns {number[]} */ static getActiveTypes(): number[]; } Transaction /** * An abstract transaction class that serves as the base class of all NEM transactions. */ export declare abstract class Transaction { /** * The transaction type. */ readonly type: number; /** * The version of the structure. */ readonly version: number; /** * The transaction signature (missing if part of a multisig transaction). */ readonly signature?: string; /** * The public account of the transaction creator. */ public signer?: PublicAccount; /** * TimeWindow */ readonly timeWindow: TimeWindow; /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly abstract fee: number; /** * Transactions meta data object contains additional information about the transaction. */ protected readonly transactionInfo?: TransactionInfo; /** * Checks if the transaction has been confirmed and included in a block */ isConfirmed(): boolean; /** * Get transaction info */ getTransactionInfo(): TransactionInfo; } TransferTransaction /** * Transfer transactions contain data about transfers of XEM or mosaics to another account. */ export declare class TransferTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The address of the recipient. */ readonly recipient: Address; /** * The xem of XEM that is transferred from sender to recipient. */ private readonly _xem; /** * Optionally a transaction can contain a message. In this case the transaction contains a message substructure. If not the field is null. */ readonly message: PlainMessage | EncryptedMessage; /** * The array of Mosaic objects. */ private readonly _mosaics?; /** * in case that the transfer transaction contains mosaics, it throws an error * @returns {XEM} */ xem(): XEM; /** * in case that the transfer transaction does not contain mosaics, it throws an error * @returns {Mosaic[]} */ mosaics(): Mosaic[]; /** * * @returns {boolean} */ containsMosaics(): boolean; /** * all the Mosaic Identifiers of the attached mosaics * @returns {MosaicId[]} */ mosaicIds(): MosaicId[]; /** * Create a TransferTransaction object * @param timeWindow * @param recipient * @param xem * @param message * @returns {TransferTransaction} */ static create(timeWindow: TimeWindow, recipient: Address, xem: XEM, message: PlainMessage | EncryptedMessage): TransferTransaction; /** * Create a TransferTransaction object * @param timeWindow * @param recipient * @param mosaics * @param message * @returns {TransferTransaction} */ static createWithMosaics(timeWindow: TimeWindow, recipient: Address, mosaics: MosaicTransferable[], message: PlainMessage | EncryptedMessage): TransferTransaction; } Message /** * Message model */ export declare abstract class Message { /** * Message payload */ readonly payload: string; } PlainMessage /** * Plain Message model */ export declare class PlainMessage extends Message { /** * Create new constructor * @returns {boolean} */ static create(message: string): PlainMessage; /** * Message string * @returns {string} */ plain(): string; } export declare const EmptyMessage: PlainMessage; EncryptedMessage /** * Encrypted Message model */ export declare class EncryptedMessage extends Message { readonly recipientPublicAccount?: PublicAccount; } ImportanceTransferTransaction export declare enum ImportanceMode { Activate = 1, Deactivate = 2, } /** * NIS has the ability to transfer the importance of one account to another account for harvesting. * The account receiving the importance is called the remote account. * Importance transfer transactions are part of the secure harvesting feature of NEM. * Once an importance transaction has been included in a block it needs 6 hours to become active. */ export declare class ImportanceTransferTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The public key of the receiving account as hexadecimal string. */ readonly remoteAccount: PublicAccount; /** * The mode, activate or deactivate */ readonly mode: ImportanceMode; /** * Create a ImportanceTransferTransaction object * @param timeWindow * @param mode * @param remoteAccount * @returns {ImportanceTransferTransaction} */ static create(timeWindow: TimeWindow, mode: ImportanceMode, remoteAccount: PublicAccount): ImportanceTransferTransaction; } ProvisionNamespaceTransaction /** * Accounts can rent a namespace for one year and after a year renew the contract. This is done via a ProvisionNamespaceTransaction. */ export declare class ProvisionNamespaceTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The Address to which the rental fee is transferred. */ readonly rentalFeeSink: Address; /** * The fee for renting the namespace. */ readonly rentalFee: number; /** * The parent namespace. This can be undefined if the transaction rents a root namespace. */ readonly parent?: string; /** * The new part which is concatenated to the parent with a '.' as separator. */ readonly newPart: string; /** * Create a ProvisionNamespaceTransaction object * @param timeWindow * @param newPart * @param parent * @returns {ProvisionNamespaceTransaction} */ static create(timeWindow: TimeWindow, newPart: string, parent?: string): ProvisionNamespaceTransaction; /** * * @param {TimeWindow} timeWindow * @param {string} namespaceName - Root namespace provision * @returns {ProvisionNamespaceTransaction} */ static createRoot(timeWindow: TimeWindow, namespaceName: string): ProvisionNamespaceTransaction; /** * * @param {TimeWindow} timeWindow * @param {string }parentNamespace * @param {string} newNamespaceName * @returns {ProvisionNamespaceTransaction} */ static createSub(timeWindow: TimeWindow, parentNamespace: string, newNamespaceName: string): ProvisionNamespaceTransaction; } MosaicDefinitionCreationTransaction /** * Before a mosaic can be created or transferred, a corresponding definition of the mosaic has to be created and published to the network. * This is done via a mosaic definition creation transaction. */ export declare class MosaicDefinitionCreationTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The fee for the creation of the mosaic. */ readonly creationFee: number; /** * The public account to which the creation fee is tranferred. */ readonly creationFeeSink: Address; /** * The actual mosaic definition. */ readonly mosaicDefinition: MosaicDefinition; /** * Create a MosaicDefinitionCreationTransaction object * @param timeWindow * @param mosaicDefinition * @returns {MosaicDefinitionCreationTransaction} */ static create(timeWindow: TimeWindow, mosaicDefinition: MosaicDefinition): MosaicDefinitionCreationTransaction; } MosaicSupplyChangeTransaction export declare enum MosaicSupplyType { Increase = 1, Decrease = 2, } /** * In case a mosaic definition has the property 'supplyMutable' set to true, the creator of the mosaic definition can change the supply, i.e. increase or decrease the supply. */ export declare class MosaicSupplyChangeTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The mosaic id. */ readonly mosaicId: MosaicId; /** * The supply type. */ readonly supplyType: MosaicSupplyType; /** * The supply change in units for the mosaic. */ readonly delta: number; /** * Create a MosaicSupplyChangeTransaction object * @param timeWindow * @param mosaicId * @param supplyType * @param delta * @returns {MosaicSupplyChangeTransaction} */ static create(timeWindow: TimeWindow, mosaicId: MosaicId, supplyType: MosaicSupplyType, delta: number): MosaicSupplyChangeTransaction; } MultisigTransaction /** * Multisig transaction are the only way to make transaction from a multisig account to another account. * A multisig transaction carries another transaction inside (often referred to as \"inner\" transaction). * The inner transaction can be a transfer, an importance transfer or an aggregate modification transaction. * A multisig transaction also has multisig signature transactions from the cosignatories of the multisig account inside. */ export declare class MultisigTransaction extends Transaction { /** * The fee for the transaction. */ readonly fee: number; /** * The JSON array of MulsigSignatureTransaction objects. */ readonly signatures: MultisigSignatureTransaction[]; /** * The inner transaction. The inner transaction can be a transfer transaction, an importance transfer transaction or a multisig aggregate modification transaction. * The inner transaction does not have a valid signature. */ readonly otherTransaction: Transaction; /** * Hash data */ readonly hashData?: HashData; /** * Check if transaction is pending to sign * @returns {boolean} */ isPendingToSign(): boolean; /** * Create a MultisigTransaction object * @param timeWindow * @param otherTrans * @param multisig * @returns {MultisigTransaction} */ static create(timeWindow: TimeWindow, otherTrans: Transaction, multisig: PublicAccount): MultisigTransaction; } MultisigAggregateModificationTransaction /** * Multisig aggregate modification transactions are part of the NEM's multisig account system. * A multisig aggregate modification transaction holds an array of multisig cosignatory modifications and a single multisig minimum cosignatories modification inside the transaction. * A multisig aggregate modification transaction can be wrapped by a multisig transaction. */ export declare class MultisigAggregateModificationTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ fee: number; /** * Value indicating the relative change of the minimum cosignatories. */ readonly relativeChange?: number; /** * The JSON array of multisig modifications. */ readonly modifications: CosignatoryModification[]; /** * Create a MultisigAggregateModificationTransaction object * @param timeWindow * @param modifications * @param relativeChange * @returns {MultisigAggregateModificationTransaction} */ static create(timeWindow: TimeWindow, modifications: CosignatoryModification[], relativeChange?: number): MultisigAggregateModificationTransaction; } /** * The type of modification. Possible values are: * 1: Add a new cosignatory. * 2: Delete an existing cosignatory. */ export declare enum CosignatoryModificationAction { ADD = 1, DELETE = 2, } export declare class CosignatoryModification { readonly cosignatoryAccount: PublicAccount; readonly action: CosignatoryModificationAction; /** * constructor * @param cosignatoryAccount * @param action */ constructor(cosignatoryAccount: PublicAccount, action: CosignatoryModificationAction); } MultisigSignatureTransaction /** * Multisig signature transactions are part of the NEM's multisig account system. Multisig signature transactions are included in the corresponding multisig transaction and are the way a cosignatory of a multisig account can sign a multisig transaction for that account. */ export declare class MultisigSignatureTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The address of the corresponding multisig account. */ readonly otherAccount: Address; /** * The hash of the inner transaction of the corresponding multisig transaction. */ readonly otherHash: HashData; /** * Create a MultisigSignatureTransaction object * @param timeWindow * @param otherAccount * @param otherHash * @returns {MultisigSignatureTransaction} */ static create(timeWindow: TimeWindow, otherAccount: Address, otherHash: HashData): MultisigSignatureTransaction; } SignedTransaction /** * SignedTransaction object is used to transfer the transaction data and the signature to NIS in order to initiate and broadcast a transaction. */ export interface SignedTransaction { /** * The transaction data as string. */ readonly data: string; /** * The signature for the transaction as hexadecimal string. */ readonly signature: string; } NemAnnounceResult export declare enum TypeNemAnnounceResult { Validation = 1, HeartBeat = 2, Status = 4, } export declare type CodeNemAnnounceResult = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19; /** * The NemAnnounceResult extends the NemRequestResult by supplying the additional fields 'transactionHash' and in case of a multisig transaction 'innerTransactionHash'. */ export declare class NemAnnounceResult { /** * The type is dependent on the request which was answered. */ readonly type: TypeNemAnnounceResult; /** * The meaning of the code is dependent on the type. */ readonly code: CodeNemAnnounceResult; /** * Error or success message */ readonly message: string; /** * The JSON hash object of the transaction. */ readonly transactionHash: HashData; /** * The JSON hash object of the inner transaction or null if the transaction is not a multisig transaction. */ readonly innerTransactionHash: HashData; }","title":"Initiating transactions requests"},{"location":"documentation/transaction/#initiating-transactions-requests","text":"Transactions are the way of transferring NEM and/or messages from one account to another. Once a transaction is initiated, it is still unconfirmed and thus not yet accepted by the network. At this point, it is not yet clear if it will get included in a block. Never rely on a transaction which has the state 'unconfirmed'. Once it is included in a block, the transaction gets processed and, in case of a transfer transaction, the amount stated in the transaction gets transferred from the sender's account to the recipient's account. Additionally, the transaction fee is deducted from the sender's account. The transaction is said to have 0 confirmations at this point. When another block is added to the blockchain the transaction has 1 confirmation. The next block added to the chain will give it 2 confirmations and so on. Cryptocurrencies have the ability to roll back part of the blockchain. This is essential for being able to resolve forks of the blockchain. There is, however, a maximum number of blocks that can be rolled back, which is called the \"rewrite limit\". Hence, forks can only be resolved up to a certain depth too. NEM has a rewrite limit of 360 blocks. Once a transaction has more than 360 confirmations, it cannot be reversed. In real life, forks that are deeper than 20 blocks do not happen, unless there was some severe problem with the blockchain due to a bug in the code or an attack of some kind. Official Source","title":"Initiating transactions requests"},{"location":"documentation/transaction/#transactionhttp-definition","text":"export declare class TransactionHttp extends HttpEndpoint { constructor(nodes?: ServerConfig[]); /** * Send the signed transaction * @param transaction * @returns Observable<NemAnnounceResult> */ announceTransaction(transaction: SignedTransaction): Observable<NemAnnounceResult>; /** * Receive a transaction by its hash * @param {string} hash - transaction hash * @returns Observable<Transaction> */ getByHash(hash: string): Observable<Transaction>; }","title":"TransactionHttp definition"},{"location":"documentation/transaction/#transactionhttp-usage","text":"import { AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, SignedTransaction } from \"nem-library\"; import {XEM} from \"nem-library/dist/src/models/mosaic/XEM\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY; const cosignerAccount = Account.createWithPrivateKey(privateKey); const transferTransaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(2), EmptyMessage ); const multisigTransaction = MultisigTransaction.create( TimeWindow.createWithDeadline(), transferTransaction, PublicAccount.createWithPublicKey(multisigAccountPublicKey) ); const transactionHttp = new TransactionHttp(); const signedTransaction: SignedTransaction = cosignerAccount.signTransaction(multisigTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Output NemAnnounceResult { type: 1, code: 1, message: 'SUCCESS', transactionHash: { data: '56b4d3e38cb5b707d4b96776116396c2885fd09be6945637f5657204528001b7' }, innerTransactionHash: { data: 'a61ce8d0df9aac98ae68e7d88a2f2bb453deb202fd95cf3cf375fde35e4e6794' } } Run the code","title":"TransactionHttp usage"},{"location":"documentation/transaction/#models","text":"","title":"Models"},{"location":"documentation/transaction/#timewindow","text":"export declare class TimeWindow { static timestampNemesisBlock: number; /** * The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block. * If a transaction does not get included in a block before the deadline is reached, it is deleted. */ deadline: LocalDateTime; /** * The number of seconds elapsed since the creation of the nemesis block. */ timeStamp: LocalDateTime; /** * @param deadline * @param chronoUnit * @returns {TimeWindow} */ static createWithDeadline(deadline?: number, chronoUnit?: ChronoUnit): TimeWindow; }","title":"TimeWindow"},{"location":"documentation/transaction/#transactioninfo","text":"export declare class TransactionInfo { /** * The height of the block in which the transaction was included. */ readonly height: number; /** * The id of the transaction. */ readonly id: number; /** * The transaction hash. */ readonly hash: HashData; /** * constructor * @param height * @param id * @param hash */ constructor(height: number, id: number, hash: HashData); } export declare class MultisigTransactionInfo extends TransactionInfo { /** * The hash of the inner transaction. This entry is only available for multisig transactions. */ readonly innerHash: HashData; /** * constructor * @param height * @param id * @param hash * @param innerHash */ constructor(height: number, id: number, hash: HashData, innerHash: HashData); }","title":"TransactionInfo"},{"location":"documentation/transaction/#transactiontypes","text":"/** * Static class containing transaction type constants. */ export declare class TransactionTypes { /** * Transfer Transaction * @type {number} */ static readonly TRANSFER: number; /** * Importance transfer transaction. * @type {number} */ static readonly IMPORTANCE_TRANSFER: number; /** * A new asset transaction. * @type {number} */ static readonly ASSET_NEW: number; /** * An asset ask transaction. * @type {number} */ static readonly ASSET_ASK: number; /** * An asset bid transaction. * @type {number} */ static readonly ASSET_BID: number; /** * A snapshot transaction. * @type {number} */ static readonly SNAPSHOT: number; /** * A multisig change transaction (e.g. announce an account as multi-sig). * @type {number} */ static readonly MULTISIG_AGGREGATE_MODIFICATION: number; /** * A multisig signature transaction. * @type {number} */ static readonly MULTISIG_SIGNATURE: number; /** * A multisig transaction. * @type {number} */ static readonly MULTISIG: number; /** * A provision namespace transaction. * @type {number} */ static readonly PROVISION_NAMESPACE: number; /** * A mosaic definition creation transaction. * @type {number} */ static readonly MOSAIC_DEFINITION_CREATION: number; /** * A mosaic supply change transaction. * @type {number} */ static readonly MOSAIC_SUPPLY_CHANGE: number; /** * Gets all multisig embeddable types. * @returns {number[]} */ static getMultisigEmbeddableTypes(): number[]; /** * Gets all block embeddable types. * @returns {number[]} */ static getBlockEmbeddableTypes(): number[]; /** * Gets all active types. * @returns {number[]} */ static getActiveTypes(): number[]; }","title":"TransactionTypes"},{"location":"documentation/transaction/#transaction","text":"/** * An abstract transaction class that serves as the base class of all NEM transactions. */ export declare abstract class Transaction { /** * The transaction type. */ readonly type: number; /** * The version of the structure. */ readonly version: number; /** * The transaction signature (missing if part of a multisig transaction). */ readonly signature?: string; /** * The public account of the transaction creator. */ public signer?: PublicAccount; /** * TimeWindow */ readonly timeWindow: TimeWindow; /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly abstract fee: number; /** * Transactions meta data object contains additional information about the transaction. */ protected readonly transactionInfo?: TransactionInfo; /** * Checks if the transaction has been confirmed and included in a block */ isConfirmed(): boolean; /** * Get transaction info */ getTransactionInfo(): TransactionInfo; }","title":"Transaction"},{"location":"documentation/transaction/#transfertransaction","text":"/** * Transfer transactions contain data about transfers of XEM or mosaics to another account. */ export declare class TransferTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The address of the recipient. */ readonly recipient: Address; /** * The xem of XEM that is transferred from sender to recipient. */ private readonly _xem; /** * Optionally a transaction can contain a message. In this case the transaction contains a message substructure. If not the field is null. */ readonly message: PlainMessage | EncryptedMessage; /** * The array of Mosaic objects. */ private readonly _mosaics?; /** * in case that the transfer transaction contains mosaics, it throws an error * @returns {XEM} */ xem(): XEM; /** * in case that the transfer transaction does not contain mosaics, it throws an error * @returns {Mosaic[]} */ mosaics(): Mosaic[]; /** * * @returns {boolean} */ containsMosaics(): boolean; /** * all the Mosaic Identifiers of the attached mosaics * @returns {MosaicId[]} */ mosaicIds(): MosaicId[]; /** * Create a TransferTransaction object * @param timeWindow * @param recipient * @param xem * @param message * @returns {TransferTransaction} */ static create(timeWindow: TimeWindow, recipient: Address, xem: XEM, message: PlainMessage | EncryptedMessage): TransferTransaction; /** * Create a TransferTransaction object * @param timeWindow * @param recipient * @param mosaics * @param message * @returns {TransferTransaction} */ static createWithMosaics(timeWindow: TimeWindow, recipient: Address, mosaics: MosaicTransferable[], message: PlainMessage | EncryptedMessage): TransferTransaction; }","title":"TransferTransaction"},{"location":"documentation/transaction/#message","text":"/** * Message model */ export declare abstract class Message { /** * Message payload */ readonly payload: string; }","title":"Message"},{"location":"documentation/transaction/#plainmessage","text":"/** * Plain Message model */ export declare class PlainMessage extends Message { /** * Create new constructor * @returns {boolean} */ static create(message: string): PlainMessage; /** * Message string * @returns {string} */ plain(): string; } export declare const EmptyMessage: PlainMessage;","title":"PlainMessage"},{"location":"documentation/transaction/#encryptedmessage","text":"/** * Encrypted Message model */ export declare class EncryptedMessage extends Message { readonly recipientPublicAccount?: PublicAccount; }","title":"EncryptedMessage"},{"location":"documentation/transaction/#importancetransfertransaction","text":"export declare enum ImportanceMode { Activate = 1, Deactivate = 2, } /** * NIS has the ability to transfer the importance of one account to another account for harvesting. * The account receiving the importance is called the remote account. * Importance transfer transactions are part of the secure harvesting feature of NEM. * Once an importance transaction has been included in a block it needs 6 hours to become active. */ export declare class ImportanceTransferTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The public key of the receiving account as hexadecimal string. */ readonly remoteAccount: PublicAccount; /** * The mode, activate or deactivate */ readonly mode: ImportanceMode; /** * Create a ImportanceTransferTransaction object * @param timeWindow * @param mode * @param remoteAccount * @returns {ImportanceTransferTransaction} */ static create(timeWindow: TimeWindow, mode: ImportanceMode, remoteAccount: PublicAccount): ImportanceTransferTransaction; }","title":"ImportanceTransferTransaction"},{"location":"documentation/transaction/#provisionnamespacetransaction","text":"/** * Accounts can rent a namespace for one year and after a year renew the contract. This is done via a ProvisionNamespaceTransaction. */ export declare class ProvisionNamespaceTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The Address to which the rental fee is transferred. */ readonly rentalFeeSink: Address; /** * The fee for renting the namespace. */ readonly rentalFee: number; /** * The parent namespace. This can be undefined if the transaction rents a root namespace. */ readonly parent?: string; /** * The new part which is concatenated to the parent with a '.' as separator. */ readonly newPart: string; /** * Create a ProvisionNamespaceTransaction object * @param timeWindow * @param newPart * @param parent * @returns {ProvisionNamespaceTransaction} */ static create(timeWindow: TimeWindow, newPart: string, parent?: string): ProvisionNamespaceTransaction; /** * * @param {TimeWindow} timeWindow * @param {string} namespaceName - Root namespace provision * @returns {ProvisionNamespaceTransaction} */ static createRoot(timeWindow: TimeWindow, namespaceName: string): ProvisionNamespaceTransaction; /** * * @param {TimeWindow} timeWindow * @param {string }parentNamespace * @param {string} newNamespaceName * @returns {ProvisionNamespaceTransaction} */ static createSub(timeWindow: TimeWindow, parentNamespace: string, newNamespaceName: string): ProvisionNamespaceTransaction; }","title":"ProvisionNamespaceTransaction"},{"location":"documentation/transaction/#mosaicdefinitioncreationtransaction","text":"/** * Before a mosaic can be created or transferred, a corresponding definition of the mosaic has to be created and published to the network. * This is done via a mosaic definition creation transaction. */ export declare class MosaicDefinitionCreationTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The fee for the creation of the mosaic. */ readonly creationFee: number; /** * The public account to which the creation fee is tranferred. */ readonly creationFeeSink: Address; /** * The actual mosaic definition. */ readonly mosaicDefinition: MosaicDefinition; /** * Create a MosaicDefinitionCreationTransaction object * @param timeWindow * @param mosaicDefinition * @returns {MosaicDefinitionCreationTransaction} */ static create(timeWindow: TimeWindow, mosaicDefinition: MosaicDefinition): MosaicDefinitionCreationTransaction; }","title":"MosaicDefinitionCreationTransaction"},{"location":"documentation/transaction/#mosaicsupplychangetransaction","text":"export declare enum MosaicSupplyType { Increase = 1, Decrease = 2, } /** * In case a mosaic definition has the property 'supplyMutable' set to true, the creator of the mosaic definition can change the supply, i.e. increase or decrease the supply. */ export declare class MosaicSupplyChangeTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The mosaic id. */ readonly mosaicId: MosaicId; /** * The supply type. */ readonly supplyType: MosaicSupplyType; /** * The supply change in units for the mosaic. */ readonly delta: number; /** * Create a MosaicSupplyChangeTransaction object * @param timeWindow * @param mosaicId * @param supplyType * @param delta * @returns {MosaicSupplyChangeTransaction} */ static create(timeWindow: TimeWindow, mosaicId: MosaicId, supplyType: MosaicSupplyType, delta: number): MosaicSupplyChangeTransaction; }","title":"MosaicSupplyChangeTransaction"},{"location":"documentation/transaction/#multisigtransaction","text":"/** * Multisig transaction are the only way to make transaction from a multisig account to another account. * A multisig transaction carries another transaction inside (often referred to as \"inner\" transaction). * The inner transaction can be a transfer, an importance transfer or an aggregate modification transaction. * A multisig transaction also has multisig signature transactions from the cosignatories of the multisig account inside. */ export declare class MultisigTransaction extends Transaction { /** * The fee for the transaction. */ readonly fee: number; /** * The JSON array of MulsigSignatureTransaction objects. */ readonly signatures: MultisigSignatureTransaction[]; /** * The inner transaction. The inner transaction can be a transfer transaction, an importance transfer transaction or a multisig aggregate modification transaction. * The inner transaction does not have a valid signature. */ readonly otherTransaction: Transaction; /** * Hash data */ readonly hashData?: HashData; /** * Check if transaction is pending to sign * @returns {boolean} */ isPendingToSign(): boolean; /** * Create a MultisigTransaction object * @param timeWindow * @param otherTrans * @param multisig * @returns {MultisigTransaction} */ static create(timeWindow: TimeWindow, otherTrans: Transaction, multisig: PublicAccount): MultisigTransaction; }","title":"MultisigTransaction"},{"location":"documentation/transaction/#multisigaggregatemodificationtransaction","text":"/** * Multisig aggregate modification transactions are part of the NEM's multisig account system. * A multisig aggregate modification transaction holds an array of multisig cosignatory modifications and a single multisig minimum cosignatories modification inside the transaction. * A multisig aggregate modification transaction can be wrapped by a multisig transaction. */ export declare class MultisigAggregateModificationTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ fee: number; /** * Value indicating the relative change of the minimum cosignatories. */ readonly relativeChange?: number; /** * The JSON array of multisig modifications. */ readonly modifications: CosignatoryModification[]; /** * Create a MultisigAggregateModificationTransaction object * @param timeWindow * @param modifications * @param relativeChange * @returns {MultisigAggregateModificationTransaction} */ static create(timeWindow: TimeWindow, modifications: CosignatoryModification[], relativeChange?: number): MultisigAggregateModificationTransaction; } /** * The type of modification. Possible values are: * 1: Add a new cosignatory. * 2: Delete an existing cosignatory. */ export declare enum CosignatoryModificationAction { ADD = 1, DELETE = 2, } export declare class CosignatoryModification { readonly cosignatoryAccount: PublicAccount; readonly action: CosignatoryModificationAction; /** * constructor * @param cosignatoryAccount * @param action */ constructor(cosignatoryAccount: PublicAccount, action: CosignatoryModificationAction); }","title":"MultisigAggregateModificationTransaction"},{"location":"documentation/transaction/#multisigsignaturetransaction","text":"/** * Multisig signature transactions are part of the NEM's multisig account system. Multisig signature transactions are included in the corresponding multisig transaction and are the way a cosignatory of a multisig account can sign a multisig transaction for that account. */ export declare class MultisigSignatureTransaction extends Transaction { /** * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority. */ readonly fee: number; /** * The address of the corresponding multisig account. */ readonly otherAccount: Address; /** * The hash of the inner transaction of the corresponding multisig transaction. */ readonly otherHash: HashData; /** * Create a MultisigSignatureTransaction object * @param timeWindow * @param otherAccount * @param otherHash * @returns {MultisigSignatureTransaction} */ static create(timeWindow: TimeWindow, otherAccount: Address, otherHash: HashData): MultisigSignatureTransaction; }","title":"MultisigSignatureTransaction"},{"location":"documentation/transaction/#signedtransaction","text":"/** * SignedTransaction object is used to transfer the transaction data and the signature to NIS in order to initiate and broadcast a transaction. */ export interface SignedTransaction { /** * The transaction data as string. */ readonly data: string; /** * The signature for the transaction as hexadecimal string. */ readonly signature: string; }","title":"SignedTransaction"},{"location":"documentation/transaction/#nemannounceresult","text":"export declare enum TypeNemAnnounceResult { Validation = 1, HeartBeat = 2, Status = 4, } export declare type CodeNemAnnounceResult = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19; /** * The NemAnnounceResult extends the NemRequestResult by supplying the additional fields 'transactionHash' and in case of a multisig transaction 'innerTransactionHash'. */ export declare class NemAnnounceResult { /** * The type is dependent on the request which was answered. */ readonly type: TypeNemAnnounceResult; /** * The meaning of the code is dependent on the type. */ readonly code: CodeNemAnnounceResult; /** * Error or success message */ readonly message: string; /** * The JSON hash object of the transaction. */ readonly transactionHash: HashData; /** * The JSON hash object of the inner transaction or null if the transaction is not a multisig transaction. */ readonly innerTransactionHash: HashData; }","title":"NemAnnounceResult"},{"location":"documentation/wallet/","text":"Wallets SimpleWallet definition /** * Simple wallet model generates a private key from a PRNG */ export declare class SimpleWallet extends Wallet { /** * The encripted private key and information to decrypt it */ readonly encryptedPrivateKey: EncryptedPrivateKey; /** * Create a SimpleWallet * @param name * @param password * @returns {SimpleWallet} */ static create(name: string, password: Password): SimpleWallet; /** * Create a SimpleWallet from private key * @param name * @param network * @param password * @param privateKey * @returns {SimpleWallet} */ static createWithPrivateKey(name: string, password: Password, privateKey: string): SimpleWallet; /** * Open a wallet and generate an Account * @param password * @returns {Account} */ open(password: Password): Account; /** * Receives the Private Key for the Wallet * @param {Password} password * @returns {string} */ unlockPrivateKey(password: Password): string; /** * Converts SimpleWallet into writable string to persist into a file * @returns {string} */ writeWLTFile(): string; /** * Reads the WLT content and converts it into a SimpleWallet * @param {string} wlt * @returns {SimpleWallet} */ static readFromWLT(wlt: string): SimpleWallet; } SimpleWallet usage /** * nem-library 0.3.0 */ import {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const password = new Password(\"password\"); const simpleWallet = SimpleWallet.create(\"simple wallet\", password); console.log(simpleWallet); Output SimpleWallet { name: 'simple wallet', network: 152, address: Address { value: 'TBSICCK3PJZDWQ4JCPWT55IRBWEQMRSABQ3QJHE4', networkType: 152 }, creationDate: LocalDateTime { _date: LocalDate { _year: 2017, _month: 7, _day: 24 }, _time: LocalTime { _hour: 16, _minute: 44, _second: 14, _nano: 870000000 } }, encryptedPrivateKey: EncryptedPrivateKey { encryptedKey: '2cb583e61208964d465955cc35c86c9e83733a10adc40cee6b8c650478ffe3667ccb70328a0dc2c67de9770806040580', iv: 'c192d9a501c7dde5c7e05186c93b63da' } } Run the code BrainWallet definition /** * Brain wallet derived the private key from the brainPassword, hashing the brainPassword multiple times, therefore it's crucial to select a SAFE brainPassword. */ export declare class BrainWallet extends Wallet { /** * Create a BrainWallet * @param name * @param password * @returns {BrainWallet} */ static create(name: string, password: BrainPassword): BrainWallet; /** * Open a wallet and generate an Account * @param password * @returns {Account} */ open(password: BrainPassword): Account; /** * Receives the Private Key for the Wallet * @param {Password} password * @returns {string} */ unlockPrivateKey(password: Password): string; /** * Converts BrainWallet into writable string to persist into a file * @returns {string} */ writeWLTFile(): string; /** * Reads the WLT content and converts it into a BrainWallet * @param {string} wlt * @returns {BrainWallet} */ static readFromWLT(wlt: string): BrainWallet; } BrainWallet usage /** * nem-library 0.3.0 */ import {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const brainPassword = new BrainPassword(\"entertain destruction sassy impartial morning electric limit glib bait grape icy measure\") const brainWallet = BrainWallet.create(\"brain wallet\", brainPassword); console.log(brainWallet); Output BrainWallet { name: 'brain wallet', network: 152, address: Address { value: 'TBUWTIIYM2BFFAE3JOEW3LGG5X3QTO7L2RWGZ6XV', networkType: 152 }, creationDate: LocalDateTime { _date: LocalDate { _year: 2017, _month: 7, _day: 24 }, _time: LocalTime { _hour: 16, _minute: 44, _second: 42, _nano: 402000000 } } } Run the code Models Wallet export enum WalletType { SIMPLE, BRAIN } /** * Wallet base model */ export declare abstract class Wallet { /** * The wallet's name */ readonly name: string; /** * The wallet's network */ readonly network: NetworkTypes; /** * The wallet's address */ readonly address: Address; /** * The wallet's creation date */ readonly creationDate: LocalDateTime; /** * Abstract open wallet method returning an account from current wallet. * @param password */ abstract open(password: Password): Account; /** * Given a WLT string, retusn the WalletType * @param {string} wlt * @returns {WalletType} */ static walletTypeGivenWLT(wlt: string): WalletType; } Password /** * Password model */ export declare class Password { /** * Password value */ readonly value: string; /** * Create a password with at least 8 characters * @param password */ constructor(password: string); } BrainPassword /** * Brain password is an extended version of Password. With the brain password we derive the private key in BrainWallets. */ export declare class BrainPassword extends Password { /** * Constructor * @param password - password must be secure, the password must be at least a 12 random words password. */ constructor(password: string); } EncryptedPrivateKey /** * EncryptedPrivateKey model */ export declare class EncryptedPrivateKey { /** * Encrypted private key data */ readonly encryptedKey: string; /** * Initialization vector used in the decrypt process */ readonly iv: string; }","title":"Wallets"},{"location":"documentation/wallet/#wallets","text":"","title":"Wallets"},{"location":"documentation/wallet/#simplewallet-definition","text":"/** * Simple wallet model generates a private key from a PRNG */ export declare class SimpleWallet extends Wallet { /** * The encripted private key and information to decrypt it */ readonly encryptedPrivateKey: EncryptedPrivateKey; /** * Create a SimpleWallet * @param name * @param password * @returns {SimpleWallet} */ static create(name: string, password: Password): SimpleWallet; /** * Create a SimpleWallet from private key * @param name * @param network * @param password * @param privateKey * @returns {SimpleWallet} */ static createWithPrivateKey(name: string, password: Password, privateKey: string): SimpleWallet; /** * Open a wallet and generate an Account * @param password * @returns {Account} */ open(password: Password): Account; /** * Receives the Private Key for the Wallet * @param {Password} password * @returns {string} */ unlockPrivateKey(password: Password): string; /** * Converts SimpleWallet into writable string to persist into a file * @returns {string} */ writeWLTFile(): string; /** * Reads the WLT content and converts it into a SimpleWallet * @param {string} wlt * @returns {SimpleWallet} */ static readFromWLT(wlt: string): SimpleWallet; }","title":"SimpleWallet definition"},{"location":"documentation/wallet/#simplewallet-usage","text":"/** * nem-library 0.3.0 */ import {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const password = new Password(\"password\"); const simpleWallet = SimpleWallet.create(\"simple wallet\", password); console.log(simpleWallet); Output SimpleWallet { name: 'simple wallet', network: 152, address: Address { value: 'TBSICCK3PJZDWQ4JCPWT55IRBWEQMRSABQ3QJHE4', networkType: 152 }, creationDate: LocalDateTime { _date: LocalDate { _year: 2017, _month: 7, _day: 24 }, _time: LocalTime { _hour: 16, _minute: 44, _second: 14, _nano: 870000000 } }, encryptedPrivateKey: EncryptedPrivateKey { encryptedKey: '2cb583e61208964d465955cc35c86c9e83733a10adc40cee6b8c650478ffe3667ccb70328a0dc2c67de9770806040580', iv: 'c192d9a501c7dde5c7e05186c93b63da' } } Run the code","title":"SimpleWallet usage"},{"location":"documentation/wallet/#brainwallet-definition","text":"/** * Brain wallet derived the private key from the brainPassword, hashing the brainPassword multiple times, therefore it's crucial to select a SAFE brainPassword. */ export declare class BrainWallet extends Wallet { /** * Create a BrainWallet * @param name * @param password * @returns {BrainWallet} */ static create(name: string, password: BrainPassword): BrainWallet; /** * Open a wallet and generate an Account * @param password * @returns {Account} */ open(password: BrainPassword): Account; /** * Receives the Private Key for the Wallet * @param {Password} password * @returns {string} */ unlockPrivateKey(password: Password): string; /** * Converts BrainWallet into writable string to persist into a file * @returns {string} */ writeWLTFile(): string; /** * Reads the WLT content and converts it into a BrainWallet * @param {string} wlt * @returns {BrainWallet} */ static readFromWLT(wlt: string): BrainWallet; }","title":"BrainWallet definition"},{"location":"documentation/wallet/#brainwallet-usage","text":"/** * nem-library 0.3.0 */ import {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const brainPassword = new BrainPassword(\"entertain destruction sassy impartial morning electric limit glib bait grape icy measure\") const brainWallet = BrainWallet.create(\"brain wallet\", brainPassword); console.log(brainWallet); Output BrainWallet { name: 'brain wallet', network: 152, address: Address { value: 'TBUWTIIYM2BFFAE3JOEW3LGG5X3QTO7L2RWGZ6XV', networkType: 152 }, creationDate: LocalDateTime { _date: LocalDate { _year: 2017, _month: 7, _day: 24 }, _time: LocalTime { _hour: 16, _minute: 44, _second: 42, _nano: 402000000 } } } Run the code","title":"BrainWallet usage"},{"location":"documentation/wallet/#models","text":"","title":"Models"},{"location":"documentation/wallet/#wallet","text":"export enum WalletType { SIMPLE, BRAIN } /** * Wallet base model */ export declare abstract class Wallet { /** * The wallet's name */ readonly name: string; /** * The wallet's network */ readonly network: NetworkTypes; /** * The wallet's address */ readonly address: Address; /** * The wallet's creation date */ readonly creationDate: LocalDateTime; /** * Abstract open wallet method returning an account from current wallet. * @param password */ abstract open(password: Password): Account; /** * Given a WLT string, retusn the WalletType * @param {string} wlt * @returns {WalletType} */ static walletTypeGivenWLT(wlt: string): WalletType; }","title":"Wallet"},{"location":"documentation/wallet/#password","text":"/** * Password model */ export declare class Password { /** * Password value */ readonly value: string; /** * Create a password with at least 8 characters * @param password */ constructor(password: string); }","title":"Password"},{"location":"documentation/wallet/#brainpassword","text":"/** * Brain password is an extended version of Password. With the brain password we derive the private key in BrainWallets. */ export declare class BrainPassword extends Password { /** * Constructor * @param password - password must be secure, the password must be at least a 12 random words password. */ constructor(password: string); }","title":"BrainPassword"},{"location":"documentation/wallet/#encryptedprivatekey","text":"/** * EncryptedPrivateKey model */ export declare class EncryptedPrivateKey { /** * Encrypted private key data */ readonly encryptedKey: string; /** * Initialization vector used in the decrypt process */ readonly iv: string; }","title":"EncryptedPrivateKey"},{"location":"guide/account/","text":"How to receive all transactions for an account import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.allTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .subscribe(allTransactions => { console.log(allTransactions); }); Source code How to receive all transactions for an account paginated /** * nem-library 0.3.0 */ import { AccountHttp, Address, NEMLibrary, NetworkTypes } from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let address = new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"); let accountHttp = new AccountHttp(); let pageable = accountHttp.allTransactionsPaginated(address); pageable.subscribe(transactions => { // do something with the info }); pageable.nextPage(); // Fetch the nexts 25 transactions Source code How to receive incoming transactions for an account import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.incomingTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .subscribe(x => { console.log(x); }); Source code How to receive outgoing transactions for an account import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.outgoingTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .subscribe(x => { console.log(x); }); Source code How to get the unconfirmed transactions for an account import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.unconfirmedTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .subscribe(x => { console.log(x); }); Source code How to get Account harvested blocks info paginated import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.getAccountImportances() .subscribe(x => { console.log(x); }); Source code How to get Account Importances import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.getAccountImportances() .subscribe(x => { console.log(x); }); Source code How to convert a Normal Account into Multisig Account import { AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM, MultisigAggregateModificationTransaction, CosignatoryModification, CosignatoryModificationAction } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transactionHttp = new TransactionHttp(); // Replace with the private key of the account that you want to convert into multisig const privateKey: string = process.env.PRIVATE_KEY; const cosignatory1PublicKey: string = process.env.COSIGNATORY_1_PUBLIC_KEY; const cosignatory2PublicKey: string = process.env.COSIGNATORY_2_PUBLIC_KEY; const account = Account.createWithPrivateKey(privateKey); const cosignatory1 = PublicAccount.createWithPublicKey(cosignatory1PublicKey); const cosignatory2 = PublicAccount.createWithPublicKey(cosignatory2PublicKey); const convertIntoMultisigTransaction = MultisigAggregateModificationTransaction.create( TimeWindow.createWithDeadline(), [ new CosignatoryModification(cosignatory1, CosignatoryModificationAction.ADD), new CosignatoryModification(cosignatory2, CosignatoryModificationAction.ADD), ], 2 ); const signedTransaction = account.signTransaction(convertIntoMultisigTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe(x => console.log(x)); Source code How to enable harvesting import { NEMLibrary, NetworkTypes, Account, TimeWindow, PublicAccount, TransactionHttp, ImportanceMode, ImportanceTransferTransaction, AccountHttp } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const delegateAccountHarvestingPrivateKey: string = process.env.HARVESTING_PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const delegatedAccount = Account.createWithPublicKey(delegateAccountHarvestingPrivateKey); const importanceTransferTransaction = ImportanceTransferTransaction.create( TimeWindow.createWithDeadline(), ImportanceMode.Activate, PublicAccount.createWithPublicKey(delegatedAccount.publicKey) ); const signedTransaction = account.signTransaction(importanceTransferTransaction); const transactionHttp = new TransactionHttp(); transactionHttp.announceTransaction(signedTransaction).subscribe(x => console.log(x)); // Wait aproximately 6h for you delegated account to be active const accountHttp = new AccountHttp(); // Testnet supernode const supernodeDomain = \"188.68.50.161\"; accountHttp.unlockHarvesting(supernodeDomain, delegateAccountHarvestingPrivateKey).subscribe(success => console.log(success)); Source code How receive all transactions The sample shows how to fetch all the transactions for an account, emulating a loop or a recursive function. import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); const address = new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"); let pagedTransactions = accountHttp.allTransactionsPaginated(address, undefined, 100); let time = 0; pagedTransactions.subscribe(x => { console.log(\"TIME \", ++time); console.log(\"transactions size\", x.length); // Fetch the next 100 transactions pagedTransactions.nextPage(); }, err => { console.log(\"error\"); }, () => { // when this lambda is called, it means all transactions have been fetched console.log(\"complete\"); }); Source code How to sign unconfirmed multisig transactions /** * nem-library 0.3.7 */ import { AccountHttp, TransactionHttp, Address, NEMLibrary, NetworkTypes, Account, Transaction, TransactionTypes, MultisigTransaction, MultisigSignatureTransaction, TimeWindow, PublicAccount } from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let accountHttp = new AccountHttp(); let transactionHttp = new TransactionHttp(); let account = Account.createWithPrivateKey(\"\"); accountHttp.unconfirmedTransactions(account.address) // Convert result Transaction[] into Transaction .flatMap(x => x ) // just return the Multisig Transactions .filter(transaction => transaction.type == TransactionTypes.MULTISIG) // Convert the multisig transaction into MultisigSignatureTransaction .map((transaction: MultisigTransaction): MultisigSignatureTransaction => MultisigSignatureTransaction.create( TimeWindow.createWithDeadline(), transaction.otherTransaction.signer!.address, transaction.hashData! )) // Sign the transaction .map(transaction => account.signTransaction(transaction)) // announce the transaction to be included in a block .flatMap(signedTransaction => transactionHttp.announceTransaction(signedTransaction)) .subscribe(result => { // Listen the success console.log(result); }, err => { // Know if something has gone wrong console.error(err) }); Source code","title":"Account"},{"location":"guide/account/#how-to-receive-all-transactions-for-an-account","text":"import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.allTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .subscribe(allTransactions => { console.log(allTransactions); }); Source code","title":"How to receive all transactions for an account"},{"location":"guide/account/#how-to-receive-incoming-transactions-for-an-account","text":"import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.incomingTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .subscribe(x => { console.log(x); }); Source code","title":"How to receive incoming transactions for an account"},{"location":"guide/account/#how-to-receive-outgoing-transactions-for-an-account","text":"import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.outgoingTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .subscribe(x => { console.log(x); }); Source code","title":"How to receive outgoing transactions for an account"},{"location":"guide/account/#how-to-get-the-unconfirmed-transactions-for-an-account","text":"import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.unconfirmedTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .subscribe(x => { console.log(x); }); Source code","title":"How to get the unconfirmed transactions for an account"},{"location":"guide/account/#how-to-get-account-harvested-blocks-info-paginated","text":"import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.getAccountImportances() .subscribe(x => { console.log(x); }); Source code","title":"How to get Account harvested blocks info paginated"},{"location":"guide/account/#how-to-get-account-importances","text":"import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.getAccountImportances() .subscribe(x => { console.log(x); }); Source code","title":"How to get Account Importances"},{"location":"guide/account/#how-to-convert-a-normal-account-into-multisig-account","text":"import { AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM, MultisigAggregateModificationTransaction, CosignatoryModification, CosignatoryModificationAction } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transactionHttp = new TransactionHttp(); // Replace with the private key of the account that you want to convert into multisig const privateKey: string = process.env.PRIVATE_KEY; const cosignatory1PublicKey: string = process.env.COSIGNATORY_1_PUBLIC_KEY; const cosignatory2PublicKey: string = process.env.COSIGNATORY_2_PUBLIC_KEY; const account = Account.createWithPrivateKey(privateKey); const cosignatory1 = PublicAccount.createWithPublicKey(cosignatory1PublicKey); const cosignatory2 = PublicAccount.createWithPublicKey(cosignatory2PublicKey); const convertIntoMultisigTransaction = MultisigAggregateModificationTransaction.create( TimeWindow.createWithDeadline(), [ new CosignatoryModification(cosignatory1, CosignatoryModificationAction.ADD), new CosignatoryModification(cosignatory2, CosignatoryModificationAction.ADD), ], 2 ); const signedTransaction = account.signTransaction(convertIntoMultisigTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe(x => console.log(x)); Source code","title":"How to convert a Normal Account into Multisig Account"},{"location":"guide/account/#how-to-enable-harvesting","text":"import { NEMLibrary, NetworkTypes, Account, TimeWindow, PublicAccount, TransactionHttp, ImportanceMode, ImportanceTransferTransaction, AccountHttp } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const delegateAccountHarvestingPrivateKey: string = process.env.HARVESTING_PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const delegatedAccount = Account.createWithPublicKey(delegateAccountHarvestingPrivateKey); const importanceTransferTransaction = ImportanceTransferTransaction.create( TimeWindow.createWithDeadline(), ImportanceMode.Activate, PublicAccount.createWithPublicKey(delegatedAccount.publicKey) ); const signedTransaction = account.signTransaction(importanceTransferTransaction); const transactionHttp = new TransactionHttp(); transactionHttp.announceTransaction(signedTransaction).subscribe(x => console.log(x)); // Wait aproximately 6h for you delegated account to be active const accountHttp = new AccountHttp(); // Testnet supernode const supernodeDomain = \"188.68.50.161\"; accountHttp.unlockHarvesting(supernodeDomain, delegateAccountHarvestingPrivateKey).subscribe(success => console.log(success)); Source code","title":"How to enable harvesting"},{"location":"guide/account/#how-receive-all-transactions","text":"The sample shows how to fetch all the transactions for an account, emulating a loop or a recursive function. import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); const address = new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"); let pagedTransactions = accountHttp.allTransactionsPaginated(address, undefined, 100); let time = 0; pagedTransactions.subscribe(x => { console.log(\"TIME \", ++time); console.log(\"transactions size\", x.length); // Fetch the next 100 transactions pagedTransactions.nextPage(); }, err => { console.log(\"error\"); }, () => { // when this lambda is called, it means all transactions have been fetched console.log(\"complete\"); }); Source code","title":"How receive all transactions"},{"location":"guide/account/#how-to-sign-unconfirmed-multisig-transactions","text":"/** * nem-library 0.3.7 */ import { AccountHttp, TransactionHttp, Address, NEMLibrary, NetworkTypes, Account, Transaction, TransactionTypes, MultisigTransaction, MultisigSignatureTransaction, TimeWindow, PublicAccount } from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let accountHttp = new AccountHttp(); let transactionHttp = new TransactionHttp(); let account = Account.createWithPrivateKey(\"\"); accountHttp.unconfirmedTransactions(account.address) // Convert result Transaction[] into Transaction .flatMap(x => x ) // just return the Multisig Transactions .filter(transaction => transaction.type == TransactionTypes.MULTISIG) // Convert the multisig transaction into MultisigSignatureTransaction .map((transaction: MultisigTransaction): MultisigSignatureTransaction => MultisigSignatureTransaction.create( TimeWindow.createWithDeadline(), transaction.otherTransaction.signer!.address, transaction.hashData! )) // Sign the transaction .map(transaction => account.signTransaction(transaction)) // announce the transaction to be included in a block .flatMap(signedTransaction => transactionHttp.announceTransaction(signedTransaction)) .subscribe(result => { // Listen the success console.log(result); }, err => { // Know if something has gone wrong console.error(err) }); Source code","title":"How to sign unconfirmed multisig transactions"},{"location":"guide/blockchain/","text":"Blockchain How to get a Block by Height import {BlockHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const blockHttp = new BlockHttp(); blockHttp.getBlockByHeight(1033023).subscribe(block => { console.log(block); }); Source code How to get Last block of the blockchain import {ChainHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const chainHttp = new ChainHttp(); chainHttp.getBlockchainLastBlock().subscribe(block => { console.log(block); }); Source code","title":"Blockchain"},{"location":"guide/blockchain/#blockchain","text":"","title":"Blockchain"},{"location":"guide/blockchain/#how-to-get-a-block-by-height","text":"import {BlockHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const blockHttp = new BlockHttp(); blockHttp.getBlockByHeight(1033023).subscribe(block => { console.log(block); }); Source code","title":"How to get a Block by Height"},{"location":"guide/blockchain/#how-to-get-last-block-of-the-blockchain","text":"import {ChainHttp, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const chainHttp = new ChainHttp(); chainHttp.getBlockchainLastBlock().subscribe(block => { console.log(block); }); Source code","title":"How to get Last block of the blockchain"},{"location":"guide/listener/","text":"How to create a listener for account information /** * nem-library 0.3.0 */ import {AccountListener, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\"); let listener = new AccountListener().given(address); listener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code How to create a listener for new blocks information /** * nem-library 0.3.0 */ import {BlockchainListener, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let blockchainListener = new BlockchainListener().newBlock(); blockchainListener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code How to create a listener for new blockchain height information /** * nem-library 0.3.0 */ import {BlockchainListener, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let blockchainListener = new BlockchainListener().newHeight(); blockchainListener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code How to create a listener for unconfirmed transactions information /** * nem-library 0.3.0 */ import {Address, NEMLibrary, NetworkTypes, UnconfirmedTransactionListener} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\"); let unconfirmedTransactionListener = new UnconfirmedTransactionListener().given(address); unconfirmedTransactionListener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code How to create a listener for confirmed transactions information /** * nem-library 0.3.0 */ import {Address, ConfirmedTransactionListener, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\"); let confirmedTransactionListener = new ConfirmedTransactionListener().given(address); confirmedTransactionListener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code","title":"Listener"},{"location":"guide/listener/#how-to-create-a-listener-for-account-information","text":"/** * nem-library 0.3.0 */ import {AccountListener, Address, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\"); let listener = new AccountListener().given(address); listener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code","title":"How to create a listener for account information"},{"location":"guide/listener/#how-to-create-a-listener-for-new-blocks-information","text":"/** * nem-library 0.3.0 */ import {BlockchainListener, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let blockchainListener = new BlockchainListener().newBlock(); blockchainListener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code","title":"How to create a listener for new blocks information"},{"location":"guide/listener/#how-to-create-a-listener-for-new-blockchain-height-information","text":"/** * nem-library 0.3.0 */ import {BlockchainListener, NEMLibrary, NetworkTypes} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); let blockchainListener = new BlockchainListener().newHeight(); blockchainListener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code","title":"How to create a listener for new blockchain height information"},{"location":"guide/listener/#how-to-create-a-listener-for-unconfirmed-transactions-information","text":"/** * nem-library 0.3.0 */ import {Address, NEMLibrary, NetworkTypes, UnconfirmedTransactionListener} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\"); let unconfirmedTransactionListener = new UnconfirmedTransactionListener().given(address); unconfirmedTransactionListener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code","title":"How to create a listener for unconfirmed transactions information"},{"location":"guide/listener/#how-to-create-a-listener-for-confirmed-transactions-information","text":"/** * nem-library 0.3.0 */ import {Address, ConfirmedTransactionListener, NEMLibrary, NetworkTypes} from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const address = new Address(\"TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\"); let confirmedTransactionListener = new ConfirmedTransactionListener().given(address); confirmedTransactionListener.subscribe(x => { console.log(x); }, err => { console.log(err); }); Source code","title":"How to create a listener for confirmed transactions information"},{"location":"guide/mosaic/","text":"How to create a Mosaic import { NEMLibrary, NetworkTypes, TimeWindow, Account, TransactionHttp, MosaicDefinitionCreationTransaction, MosaicDefinition, PublicAccount, MosaicId, MosaicProperties, MosaicLevy, MosaicLevyType } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const transactionHttp = new TransactionHttp(); const mosaicDefinitionTransaction = MosaicDefinitionCreationTransaction.create( TimeWindow.createWithDeadline(), new MosaicDefinition( PublicAccount.createWithPublicKey(account.publicKey), new MosaicId(\"new-namespace\", \"new-mosaic\"), \"mosaic description\", new MosaicProperties(0, 9000000, true, true), new MosaicLevy( MosaicLevyType.Percentil, account.address, new MosaicId(\"nem\", \"xem\"), 2 ) ) ); const signedTransaction = account.signTransaction(mosaicDefinitionTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Source code How to get Namespace Mosaic Definitions import { NEMLibrary, NetworkTypes, MosaicHttp, TransactionTypes } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const mosaicHttp = new MosaicHttp(); const namespace = \"new-namespace\"; mosaicHttp.getAllMosaicsGivenNamespace(namespace).subscribe(mosaicDefinitions => console.log(mosaicDefinitions)); Source code","title":"Mosaic"},{"location":"guide/mosaic/#how-to-create-a-mosaic","text":"import { NEMLibrary, NetworkTypes, TimeWindow, Account, TransactionHttp, MosaicDefinitionCreationTransaction, MosaicDefinition, PublicAccount, MosaicId, MosaicProperties, MosaicLevy, MosaicLevyType } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const transactionHttp = new TransactionHttp(); const mosaicDefinitionTransaction = MosaicDefinitionCreationTransaction.create( TimeWindow.createWithDeadline(), new MosaicDefinition( PublicAccount.createWithPublicKey(account.publicKey), new MosaicId(\"new-namespace\", \"new-mosaic\"), \"mosaic description\", new MosaicProperties(0, 9000000, true, true), new MosaicLevy( MosaicLevyType.Percentil, account.address, new MosaicId(\"nem\", \"xem\"), 2 ) ) ); const signedTransaction = account.signTransaction(mosaicDefinitionTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Source code","title":"How to create a Mosaic"},{"location":"guide/mosaic/#how-to-get-namespace-mosaic-definitions","text":"import { NEMLibrary, NetworkTypes, MosaicHttp, TransactionTypes } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const mosaicHttp = new MosaicHttp(); const namespace = \"new-namespace\"; mosaicHttp.getAllMosaicsGivenNamespace(namespace).subscribe(mosaicDefinitions => console.log(mosaicDefinitions)); Source code","title":"How to get Namespace Mosaic Definitions"},{"location":"guide/namespace/","text":"How to create a Namespace import{ NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const transactionHttp = new TransactionHttp(); const namespace = \"new-namespace\"; const provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create( TimeWindow.createWithDeadline(), namespace ); const signedTransaction = account.signTransaction(provisionNamespaceTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Source code How to create a Sub-Namespace import { NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const transactionHttp = new TransactionHttp(); const namespace = \"new-namespace\"; const subnamespace = \"subnamespace\"; const provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create( TimeWindow.createWithDeadline(), subnamespace, namespace ); const signedTransaction = account.signTransaction(provisionNamespaceTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Source code How to know if a Namespace exists import { NEMLibrary, NetworkTypes, NamespaceHttp } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const namespaceHttp = new NamespaceHttp(); const namespace = \"new-namespace\"; namespaceHttp.getNamespace(namespace).subscribe(namespace => console.log(namespace)); Source code How to know the owner of a Namespace import { NEMLibrary, NetworkTypes, NamespaceHttp } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const namespaceHttp = new NamespaceHttp(); const namespace = \"new-namespace\"; namespaceHttp.getNamespace(namespace).subscribe(namespace => console.log(namespace)); Source code","title":"Namespace"},{"location":"guide/namespace/#how-to-create-a-namespace","text":"import{ NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const transactionHttp = new TransactionHttp(); const namespace = \"new-namespace\"; const provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create( TimeWindow.createWithDeadline(), namespace ); const signedTransaction = account.signTransaction(provisionNamespaceTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Source code","title":"How to create a Namespace"},{"location":"guide/namespace/#how-to-create-a-sub-namespace","text":"import { NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const transactionHttp = new TransactionHttp(); const namespace = \"new-namespace\"; const subnamespace = \"subnamespace\"; const provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create( TimeWindow.createWithDeadline(), subnamespace, namespace ); const signedTransaction = account.signTransaction(provisionNamespaceTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Source code","title":"How to create a Sub-Namespace"},{"location":"guide/namespace/#how-to-know-if-a-namespace-exists","text":"import { NEMLibrary, NetworkTypes, NamespaceHttp } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const namespaceHttp = new NamespaceHttp(); const namespace = \"new-namespace\"; namespaceHttp.getNamespace(namespace).subscribe(namespace => console.log(namespace)); Source code","title":"How to know if a Namespace exists"},{"location":"guide/namespace/#how-to-know-the-owner-of-a-namespace","text":"import { NEMLibrary, NetworkTypes, NamespaceHttp } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const namespaceHttp = new NamespaceHttp(); const namespace = \"new-namespace\"; namespaceHttp.getNamespace(namespace).subscribe(namespace => console.log(namespace)); Source code","title":"How to know the owner of a Namespace"},{"location":"guide/node/","text":"How to get NEM Node information import {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const nodeHttp = new NodeHttp(); nodeHttp.getNodeInfo().subscribe(node => console.log(node)); Source code How to get extended information about a NEM Node import {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const nodeHttp = new NodeHttp(); nodeHttp.getNisNodeInfo().subscribe(nisNodeInfo => console.log(nisNodeInfo)); Source code How to get all active nodes import {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const nodeHttp = new NodeHttp(); nodeHttp.getActiveNodes().subscribe(nodes => console.log(nodes)); Source code","title":"Node"},{"location":"guide/node/#how-to-get-nem-node-information","text":"import {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const nodeHttp = new NodeHttp(); nodeHttp.getNodeInfo().subscribe(node => console.log(node)); Source code","title":"How to get NEM Node information"},{"location":"guide/node/#how-to-get-extended-information-about-a-nem-node","text":"import {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const nodeHttp = new NodeHttp(); nodeHttp.getNisNodeInfo().subscribe(nisNodeInfo => console.log(nisNodeInfo)); Source code","title":"How to get extended information about a NEM Node"},{"location":"guide/node/#how-to-get-all-active-nodes","text":"import {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const nodeHttp = new NodeHttp(); nodeHttp.getActiveNodes().subscribe(nodes => console.log(nodes)); Source code","title":"How to get all active nodes"},{"location":"guide/overview/","text":"Working examples The guide section shows some How to use the NEM Library. You can find the code examples pre-configured and ready to use at github.com/aleixmorgadas/nem-library-examples TimeWindow concept The TimeWindow concept is related with the Transactions. A transaction has as TimeWindow where it can be included in a block, once the deadline of the TimeWindow is after the Node timestamp, the transaction is rejected.","title":"Working examples"},{"location":"guide/overview/#working-examples","text":"The guide section shows some How to use the NEM Library. You can find the code examples pre-configured and ready to use at github.com/aleixmorgadas/nem-library-examples","title":"Working examples"},{"location":"guide/overview/#timewindow-concept","text":"The TimeWindow concept is related with the Transactions. A transaction has as TimeWindow where it can be included in a block, once the deadline of the TimeWindow is after the Node timestamp, the transaction is rejected.","title":"TimeWindow concept"},{"location":"guide/transaction/","text":"How to create a Transfer Transaction import { NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transferTransaction: Transaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(2), EmptyMessage ); Source code How to sign a Transaction import { AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transactionHttp = new TransactionHttp(); // Replace with a cosignatory private key const privateKey: string = process.env.PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const transferTransaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(2), EmptyMessage ); const signedTransaction = account.signTransaction(transferTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Source code How to create a Transfer Transaction with a Message /** * nem-library 0.3.0 */ import { NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow, XEM, PlainMessage } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transferTransaction: Transaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(0), PlainMessage.create(\"a transaction\") ); Source code How to create a Transfer Transaction with an Encrypted Message /** * nem-library 0.3.0 */ import { NEMLibrary, NetworkTypes, Account, TransferTransaction, TimeWindow, TransactionHttp, XEM, PublicAccount } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transactionHttp = new TransactionHttp(); // Replace with a cosignatory private key const privateKey: string = process.env.PRIVATE_KEY; const recipientPublicAccount = PublicAccount.createWithPublicKey(\"b254d8b2b00e1b1266eb54a6931cd7c1b0f307e41d9ebb01f025f4933758f0be\"); const account = Account.createWithPrivateKey(privateKey); const encryptedMessage = account.encryptMessage(\"a transaction\", recipientPublicAccount); const transferTransaction = TransferTransaction.create( TimeWindow.createWithDeadline(), recipientPublicAccount.address, new XEM(2), encryptedMessage ); Source code How to create a Transfer Transaction with Mosaics /** * nem-library 0.5.1 */ import { NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow, MosaicHttp, TransactionHttp, Account, EmptyMessage } from \"nem-library\"; import {Observable} from \"rxjs/Observable\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); // Replace with a cosignatory private key const privateKey: string = process.env.PRIVATE_KEY; const transactionHttp = new TransactionHttp(); const mosaicHttp = new MosaicHttp(); const account = Account.createWithPrivateKey(privateKey); Observable.from([ {namespace: \"mynamespace\", mosaic: \"mosaic1\", quantity: 10}, {namespace: \"mynamespace\", mosaic: \"mosaic2\", quantity: 10}, {namespace: \"mynamespace\", mosaic: \"mosaic3\", quantity: 10} ]).flatMap(_ => mosaicHttp.getMosaicTransferableWithAmount(_.namespace, _.mosaic, _.quantity)) .toArray() .map(mosaics => TransferTransaction.createWithMosaics( TimeWindow.createWithDeadline(), new Address(\"TBV7LE4TFDEMGVOON5MYOK2P7TU2KEKLMHOLHQT6\"), mosaics, EmptyMessage ) ) .map(transaction => account.signTransaction(transaction)) .flatMap(signedTransaction => transactionHttp.announceTransaction(signedTransaction)) .subscribe(nemAnnounceResult => { console.log(nemAnnounceResult); }) Source code How to create a MultiSig Transaction import { NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, Transaction, XEM } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); // Replace with the multisig account const multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY; const transferTransaction: Transaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(2), EmptyMessage ); const multisigTransaction: MultisigTransaction = MultisigTransaction.create( TimeWindow.createWithDeadline(), transferTransaction, PublicAccount.createWithPublicKey(multisigAccountPublicKey) ); Source code How to filter Transactions by type import { AccountHttp, Address, MultisigTransaction, NEMLibrary, NetworkTypes, Transaction, TransactionTypes } from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.allTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .map((transactions: Transaction[]): MultisigTransaction[] => { console.log(\">>>>>>>>>>>>\"); console.log(\"All Transactions\", transactions); return <MultisigTransaction[]>transactions.filter(x => x.type == TransactionTypes.MULTISIG) }) .subscribe((x: MultisigTransaction[]) => { console.log(\"\\n\\n>>>>>>>>>>>>\"); console.log(\"Just Multisig\", x) }); Source code","title":"Transaction"},{"location":"guide/transaction/#how-to-create-a-transfer-transaction","text":"import { NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transferTransaction: Transaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(2), EmptyMessage ); Source code","title":"How to create a Transfer Transaction"},{"location":"guide/transaction/#how-to-sign-a-transaction","text":"import { AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transactionHttp = new TransactionHttp(); // Replace with a cosignatory private key const privateKey: string = process.env.PRIVATE_KEY; const account = Account.createWithPrivateKey(privateKey); const transferTransaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(2), EmptyMessage ); const signedTransaction = account.signTransaction(transferTransaction); transactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x)); Source code","title":"How to sign a Transaction"},{"location":"guide/transaction/#how-to-create-a-transfer-transaction-with-a-message","text":"/** * nem-library 0.3.0 */ import { NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow, XEM, PlainMessage } from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transferTransaction: Transaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(0), PlainMessage.create(\"a transaction\") ); Source code","title":"How to create a Transfer Transaction with a Message"},{"location":"guide/transaction/#how-to-create-a-transfer-transaction-with-an-encrypted-message","text":"/** * nem-library 0.3.0 */ import { NEMLibrary, NetworkTypes, Account, TransferTransaction, TimeWindow, TransactionHttp, XEM, PublicAccount } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const transactionHttp = new TransactionHttp(); // Replace with a cosignatory private key const privateKey: string = process.env.PRIVATE_KEY; const recipientPublicAccount = PublicAccount.createWithPublicKey(\"b254d8b2b00e1b1266eb54a6931cd7c1b0f307e41d9ebb01f025f4933758f0be\"); const account = Account.createWithPrivateKey(privateKey); const encryptedMessage = account.encryptMessage(\"a transaction\", recipientPublicAccount); const transferTransaction = TransferTransaction.create( TimeWindow.createWithDeadline(), recipientPublicAccount.address, new XEM(2), encryptedMessage ); Source code","title":"How to create a Transfer Transaction with an Encrypted Message"},{"location":"guide/transaction/#how-to-create-a-transfer-transaction-with-mosaics","text":"/** * nem-library 0.5.1 */ import { NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow, MosaicHttp, TransactionHttp, Account, EmptyMessage } from \"nem-library\"; import {Observable} from \"rxjs/Observable\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); // Replace with a cosignatory private key const privateKey: string = process.env.PRIVATE_KEY; const transactionHttp = new TransactionHttp(); const mosaicHttp = new MosaicHttp(); const account = Account.createWithPrivateKey(privateKey); Observable.from([ {namespace: \"mynamespace\", mosaic: \"mosaic1\", quantity: 10}, {namespace: \"mynamespace\", mosaic: \"mosaic2\", quantity: 10}, {namespace: \"mynamespace\", mosaic: \"mosaic3\", quantity: 10} ]).flatMap(_ => mosaicHttp.getMosaicTransferableWithAmount(_.namespace, _.mosaic, _.quantity)) .toArray() .map(mosaics => TransferTransaction.createWithMosaics( TimeWindow.createWithDeadline(), new Address(\"TBV7LE4TFDEMGVOON5MYOK2P7TU2KEKLMHOLHQT6\"), mosaics, EmptyMessage ) ) .map(transaction => account.signTransaction(transaction)) .flatMap(signedTransaction => transactionHttp.announceTransaction(signedTransaction)) .subscribe(nemAnnounceResult => { console.log(nemAnnounceResult); }) Source code","title":"How to create a Transfer Transaction with Mosaics"},{"location":"guide/transaction/#how-to-create-a-multisig-transaction","text":"import { NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow, EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, Transaction, XEM } from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); // Replace with the multisig account const multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY; const transferTransaction: Transaction = TransferTransaction.create( TimeWindow.createWithDeadline(), new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"), new XEM(2), EmptyMessage ); const multisigTransaction: MultisigTransaction = MultisigTransaction.create( TimeWindow.createWithDeadline(), transferTransaction, PublicAccount.createWithPublicKey(multisigAccountPublicKey) ); Source code","title":"How to create a MultiSig Transaction"},{"location":"guide/transaction/#how-to-filter-transactions-by-type","text":"import { AccountHttp, Address, MultisigTransaction, NEMLibrary, NetworkTypes, Transaction, TransactionTypes } from \"nem-library\"; NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const accountHttp = new AccountHttp(); accountHttp.allTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\")) .map((transactions: Transaction[]): MultisigTransaction[] => { console.log(\">>>>>>>>>>>>\"); console.log(\"All Transactions\", transactions); return <MultisigTransaction[]>transactions.filter(x => x.type == TransactionTypes.MULTISIG) }) .subscribe((x: MultisigTransaction[]) => { console.log(\"\\n\\n>>>>>>>>>>>>\"); console.log(\"Just Multisig\", x) }); Source code","title":"How to filter Transactions by type"},{"location":"guide/wallet/","text":"How to create a Simple Wallet /** * nem-library 0.3.0 */ import {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const password = new Password(\"password\"); const simpleWallet = SimpleWallet.create(\"simple wallet\", password); Source code How to create a Brain Wallet /** * nem-library 0.3.0 */ import {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const brainPassword = new BrainPassword(\"entertain destruction sassy impartial morning electric limit glib bait grape icy measure\") const brainWallet = BrainWallet.create(\"brain wallet\", brainPassword); Source code How to create a Simple Wallet from a private key /** * nem-library 0.3.0 */ import {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const password = new Password(\"password\"); const simpleWallet = SimpleWallet.createWithPrivateKey(\"simple wallet\", password, privateKey); Source code How to open a Wallet /** * nem-library 0.3.0 */ import {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const password = new Password(\"password\"); const simpleWallet = SimpleWallet.createWithPrivateKey(\"simple wallet\", password, privateKey); const account = simpleWallet.open(password); Source code","title":"Wallet"},{"location":"guide/wallet/#how-to-create-a-simple-wallet","text":"/** * nem-library 0.3.0 */ import {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const password = new Password(\"password\"); const simpleWallet = SimpleWallet.create(\"simple wallet\", password); Source code","title":"How to create a Simple Wallet"},{"location":"guide/wallet/#how-to-create-a-brain-wallet","text":"/** * nem-library 0.3.0 */ import {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \"nem-library\"; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const brainPassword = new BrainPassword(\"entertain destruction sassy impartial morning electric limit glib bait grape icy measure\") const brainWallet = BrainWallet.create(\"brain wallet\", brainPassword); Source code","title":"How to create a Brain Wallet"},{"location":"guide/wallet/#how-to-create-a-simple-wallet-from-a-private-key","text":"/** * nem-library 0.3.0 */ import {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const password = new Password(\"password\"); const simpleWallet = SimpleWallet.createWithPrivateKey(\"simple wallet\", password, privateKey); Source code","title":"How to create a Simple Wallet from a private key"},{"location":"guide/wallet/#how-to-open-a-wallet","text":"/** * nem-library 0.3.0 */ import {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\"; declare let process: any; // Initialize NEMLibrary for TEST_NET Network NEMLibrary.bootstrap(NetworkTypes.TEST_NET); const privateKey: string = process.env.PRIVATE_KEY; const password = new Password(\"password\"); const simpleWallet = SimpleWallet.createWithPrivateKey(\"simple wallet\", password, privateKey); const account = simpleWallet.open(password); Source code","title":"How to open a Wallet"}]}