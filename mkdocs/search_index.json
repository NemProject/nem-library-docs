{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\nNEM Library is an abstraction for \nNEM Blockchain\n using a \nReactive\n approach\nfor creating Blockchain applications.\n\n\n\n\nSource Code Repository on GitHub\n\n\nstable version 0.10.0\n\n\nCheck the \nnpm repostory\n for the latest updates\n\n\nInstallation\n\n\nnpm install nem-library rxjs --save\n\n\n\n\nNEM Library is build with \nTypeScript Language\n, so be sure that you have \nthe latest version installed.\n\n\nWe recommend to use TypeScript instead of JavaScript for building applications for \n\nNEM Blockchain\n due the type  system and how the nem-library is meant \nto be used, without counting other great benefits that TypeScript provides.\n\n\nnpm install -g typescript\n\n\n\n\nMINIMUM TypeScript version 2.4.X\n\n\n\n\nPlatforms supported\n\n\n\n\n\n\n\n\nPlatform\n\n\nVersion\n\n\n\n\n\n\n\n\n\n\nTypeScript\n\n\n>= 2.4.0\n\n\n\n\n\n\nNodeJS\n\n\n>= 6.11.1 (but 8.x.x is recommended)\n\n\n\n\n\n\nAngular\n\n\n>= 4.2\n\n\n\n\n\n\nIonic\n\n\n>= 4.0\n\n\n\n\n\n\nFirefox\n\n\n>= 53.0\n\n\n\n\n\n\nChrome\n\n\n>= 58.0.3029.81\n\n\n\n\n\n\nChromium\n\n\n>= 59.0.3071.86\n\n\n\n\n\n\nOpera\n\n\n>= 46.0.2597.46\n\n\n\n\n\n\nEdge\n\n\n>= 40.15063.0.0\n\n\n\n\n\n\nSafari\n\n\n>= 10.0\n\n\n\n\n\n\nAndroid\n\n\n>= 5.0.0\n\n\n\n\n\n\niOS\n\n\n>= 9.3.5\n\n\n\n\n\n\n\n\nBecause of Ionic generates mobile applications, Android and iOS, the support is provided.\n\nRemark that \nWindows Phone\n is not supported yet.\n\n\n\n\nTypeScript compiler options\n\n\nUntil nem-library upgrade into \nRxJS 6.0\n, \n\"noStrictGenericChecks\"\n has to be set to true in \ntsconfig.json\n file.\n\n\n{\n  \"compilerOptions\": {\n    // ...\n    \"noStrictGenericChecks\": true\n  }\n}\n\n\n\n\nUsage\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nChangelog\n\n\n0.10.0\n\n\nBREAKING CHANGES\n\n\n\n\nAccountHttp\n: pagination replaced function arguements by QueryParams\n\n\n\n\n0.9.0\n\n\nBREAKING CHANGES\n\n\n\n\nTransferTransaction\n: amount and mosaic fields are now private, you have to use xem() and mosaic() methods instead\n\n\nAccountHttp\n: replaced function arguements by QueryParams & changed the order of the params in some cases\n\n\n\n\nNEW FEATURES\n\n\n\n\nTransferTransaction\n: added containMosaic method to verify if the Transfer Transaction contains mosaics\n\n\nAddress now accepts lowercase\n\n\nMosaicId.toString() returns the same as MosaicId.description()\n\n\n\n\n0.8.2\n\n\n\n\nQRService: Added address and transaction generate and decrypt QR code\n\n\n\n\n0.8.0\n\n\n\n\nWallet: Added \nunlockPrivateKey(password: Password): string\n method.\n\n\nCreated \nQRService\n\n\n\n\n0.7.0\n\n\n\n\nAdded statics to XEM Mosaic model\n\n\nAdded optional levy to MosaicTransferable\n\n\nCreated MosaicService to calculate levy value of a Mosaic\n\n\nMosaicId has equals & description methods\n\n\nFIXED issue TransferTransaction. When sending mosaics and message wrong fee calculation.\n\n\n\n\n0.6.0\n\n\n\n\nConnection Pool\n\n\nCreated \nAccountOwnedMosaicService\n\n\nFIXED issue with Mosaics. Now a Mosaic can be created without a Levy\n\n\n\n\n0.5.1\n\n\nBREAKING CHANGES\n\n\n\n\nWhere you had \nXEM(3)\n now you should add the \nnew\n apperator first -> \nnew XEM(3)\n\n\nWhere you had \nmosaicHttp.getMosaicDefinitions\n, now you should call \nmosaicHttp.getAllMosaicsGivenNamespace\n\n\n\n\nNEW FEATURES\n\n\n\n\nTransactionHttp: Added getByHash method that returns a particular Transaction\n\n\nBrainPassword must be at least a 12 word password to avoid collitions\n\n\nSimpleWallet has readFromWLT & writeWLTFile methods to persist it\n\n\nBrainWallet has readFromWLT & writeWLTFile methods to persist it\n\n\nWallet has static walletTypeGivenWLT(wlt: string): WalletType method\n\n\nCreated WalletType enum\n\n\nMosaicHttp added getMosaicDefinition method\n\n\nMosaicHttp added getMosaicTransferableWithAmount method\n\n\nCreated EcobitEco Mosaic model\n\n\nCreated DimToken Mosaic model\n\n\nCreated DimCoin Mosaic model\n\n\n\n\n0.4.0\n\n\n\n\nPagable\n extends Subject\n\n\nOutgoingTransactionsPageable extends Pageable<>\n\n\nAllTransactionsPageable extends Pageable<>\n\n\nAccount decryptMessage method now returns PlainMessage: \nNo compatible with previus version\n\n\nProvisionNamespaceTransaction added static createSub(timeWindow: TimeWindow, parentNamespace: string, newNamespaceName: string): ProvisionNamespaceTransaction;\n\n\nProvisionNamespaceTransaction added static method createRoot(timeWindow: TimeWindow, namespaceName: string): ProvisionNamespaceTransaction;\n\n\nPlainMessage return the text decoded if it is encoded in UTF8, else plain payload\n\n\n\n\n0.3.8\n\n\n\n\nListeners allow HTTPS protocol\n\n\n\n\n0.3.7\n\n\n\n\nCompiled JS is es5\n\n\nAddress trims the input\n\n\n\n\n0.3.6\n\n\nReleased 29 July 2017\n\n\n\n\nFIXED Listeners reconnection\n\n\n\n\n0.3.5\n\n\nReleased 28 July 2017\n\n\n\n\nFIXED ConfirmedTransactionListener: It emitted the same object three times.\n\n\n\n\n0.3.4\n\n\nReleased 26 July 2017\n\n\n\n\nAccountHttp.allTransactions\n: Accepts pageSize as optional parameter. Between 5 and 100, default 10\n\n\nAccountHttp.allTransactionsPaginated\n: Accepts pageSize as optional parameter. Between 5 and 100, default 10\n\n\nAccountHttp.incomingTransactions\n: Accepts pageSize as optional parameter. Between 5 and 100, default 10\n\n\nAccountHttp.incomingTransactionsPaginated\n: Accepts pageSize as optional parameter. Between 5 and 100, default 10\n\n\nAccountHttp.outgoingTransactions\n: Accepts pageSize as optional parameter. Between 5 and 100, default 10\n\n\nAccountHttp.outgoingTransactionsPaginated\n: Accepts pageSize as optional parameter. Between 5 and 100, default 10\n\n\n\n\n0.3.3\n\n\nReleased 26 July 2017\n\n\n\n\nExported interface \nPageable\n\n\n\n\n0.3.2\n\n\nReleased 26 July 2017\n\n\n\n\nFIX Listeners on Browsers\n\n\nTransaction Model\n: Changed \nsigner\n field type from \nstring\n to \nPublic Account\n\n\nBlock Model\n: Changed \nsigner\n field type from \nstring\n to \nPublic Account\n\n\nNodeIdentity Model\n: Replaced \npublickey: string\n field to \npublicAccount: PublicAccount\n\n\n\n\n0.3.1\n\n\nReleased 24 July 2017\n\n\n0.3.0-RC4\n\n\n\n\nEncrypted Message\n\n\n\n\n0.3.0-RC1\n\n\n\n\nPagination\n\n\nListeners\n\n\nWallets\n\n\n\n\n0.2.34\n\n\nStable version",
            "title": "Home"
        },
        {
            "location": "/#introduction",
            "text": "NEM Library is an abstraction for  NEM Blockchain  using a  Reactive  approach\nfor creating Blockchain applications.   Source Code Repository on GitHub",
            "title": "Introduction"
        },
        {
            "location": "/#stable-version-0100",
            "text": "Check the  npm repostory  for the latest updates",
            "title": "stable version 0.10.0"
        },
        {
            "location": "/#installation",
            "text": "npm install nem-library rxjs --save  NEM Library is build with  TypeScript Language , so be sure that you have \nthe latest version installed.  We recommend to use TypeScript instead of JavaScript for building applications for  NEM Blockchain  due the type  system and how the nem-library is meant \nto be used, without counting other great benefits that TypeScript provides.  npm install -g typescript  MINIMUM TypeScript version 2.4.X",
            "title": "Installation"
        },
        {
            "location": "/#platforms-supported",
            "text": "Platform  Version      TypeScript  >= 2.4.0    NodeJS  >= 6.11.1 (but 8.x.x is recommended)    Angular  >= 4.2    Ionic  >= 4.0    Firefox  >= 53.0    Chrome  >= 58.0.3029.81    Chromium  >= 59.0.3071.86    Opera  >= 46.0.2597.46    Edge  >= 40.15063.0.0    Safari  >= 10.0    Android  >= 5.0.0    iOS  >= 9.3.5     Because of Ionic generates mobile applications, Android and iOS, the support is provided. \nRemark that  Windows Phone  is not supported yet.",
            "title": "Platforms supported"
        },
        {
            "location": "/#typescript-compiler-options",
            "text": "Until nem-library upgrade into  RxJS 6.0 ,  \"noStrictGenericChecks\"  has to be set to true in  tsconfig.json  file.  {\n  \"compilerOptions\": {\n    // ...\n    \"noStrictGenericChecks\": true\n  }\n}",
            "title": "TypeScript compiler options"
        },
        {
            "location": "/#usage",
            "text": "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
            "title": "Usage"
        },
        {
            "location": "/#changelog",
            "text": "",
            "title": "Changelog"
        },
        {
            "location": "/#0100",
            "text": "BREAKING CHANGES   AccountHttp : pagination replaced function arguements by QueryParams",
            "title": "0.10.0"
        },
        {
            "location": "/#090",
            "text": "BREAKING CHANGES   TransferTransaction : amount and mosaic fields are now private, you have to use xem() and mosaic() methods instead  AccountHttp : replaced function arguements by QueryParams & changed the order of the params in some cases   NEW FEATURES   TransferTransaction : added containMosaic method to verify if the Transfer Transaction contains mosaics  Address now accepts lowercase  MosaicId.toString() returns the same as MosaicId.description()",
            "title": "0.9.0"
        },
        {
            "location": "/#082",
            "text": "QRService: Added address and transaction generate and decrypt QR code",
            "title": "0.8.2"
        },
        {
            "location": "/#080",
            "text": "Wallet: Added  unlockPrivateKey(password: Password): string  method.  Created  QRService",
            "title": "0.8.0"
        },
        {
            "location": "/#070",
            "text": "Added statics to XEM Mosaic model  Added optional levy to MosaicTransferable  Created MosaicService to calculate levy value of a Mosaic  MosaicId has equals & description methods  FIXED issue TransferTransaction. When sending mosaics and message wrong fee calculation.",
            "title": "0.7.0"
        },
        {
            "location": "/#060",
            "text": "Connection Pool  Created  AccountOwnedMosaicService  FIXED issue with Mosaics. Now a Mosaic can be created without a Levy",
            "title": "0.6.0"
        },
        {
            "location": "/#051",
            "text": "BREAKING CHANGES   Where you had  XEM(3)  now you should add the  new  apperator first ->  new XEM(3)  Where you had  mosaicHttp.getMosaicDefinitions , now you should call  mosaicHttp.getAllMosaicsGivenNamespace   NEW FEATURES   TransactionHttp: Added getByHash method that returns a particular Transaction  BrainPassword must be at least a 12 word password to avoid collitions  SimpleWallet has readFromWLT & writeWLTFile methods to persist it  BrainWallet has readFromWLT & writeWLTFile methods to persist it  Wallet has static walletTypeGivenWLT(wlt: string): WalletType method  Created WalletType enum  MosaicHttp added getMosaicDefinition method  MosaicHttp added getMosaicTransferableWithAmount method  Created EcobitEco Mosaic model  Created DimToken Mosaic model  Created DimCoin Mosaic model",
            "title": "0.5.1"
        },
        {
            "location": "/#040",
            "text": "Pagable  extends Subject  OutgoingTransactionsPageable extends Pageable<>  AllTransactionsPageable extends Pageable<>  Account decryptMessage method now returns PlainMessage:  No compatible with previus version  ProvisionNamespaceTransaction added static createSub(timeWindow: TimeWindow, parentNamespace: string, newNamespaceName: string): ProvisionNamespaceTransaction;  ProvisionNamespaceTransaction added static method createRoot(timeWindow: TimeWindow, namespaceName: string): ProvisionNamespaceTransaction;  PlainMessage return the text decoded if it is encoded in UTF8, else plain payload",
            "title": "0.4.0"
        },
        {
            "location": "/#038",
            "text": "Listeners allow HTTPS protocol",
            "title": "0.3.8"
        },
        {
            "location": "/#037",
            "text": "Compiled JS is es5  Address trims the input",
            "title": "0.3.7"
        },
        {
            "location": "/#036",
            "text": "Released 29 July 2017   FIXED Listeners reconnection",
            "title": "0.3.6"
        },
        {
            "location": "/#035",
            "text": "Released 28 July 2017   FIXED ConfirmedTransactionListener: It emitted the same object three times.",
            "title": "0.3.5"
        },
        {
            "location": "/#034",
            "text": "Released 26 July 2017   AccountHttp.allTransactions : Accepts pageSize as optional parameter. Between 5 and 100, default 10  AccountHttp.allTransactionsPaginated : Accepts pageSize as optional parameter. Between 5 and 100, default 10  AccountHttp.incomingTransactions : Accepts pageSize as optional parameter. Between 5 and 100, default 10  AccountHttp.incomingTransactionsPaginated : Accepts pageSize as optional parameter. Between 5 and 100, default 10  AccountHttp.outgoingTransactions : Accepts pageSize as optional parameter. Between 5 and 100, default 10  AccountHttp.outgoingTransactionsPaginated : Accepts pageSize as optional parameter. Between 5 and 100, default 10",
            "title": "0.3.4"
        },
        {
            "location": "/#033",
            "text": "Released 26 July 2017   Exported interface  Pageable",
            "title": "0.3.3"
        },
        {
            "location": "/#032",
            "text": "Released 26 July 2017   FIX Listeners on Browsers  Transaction Model : Changed  signer  field type from  string  to  Public Account  Block Model : Changed  signer  field type from  string  to  Public Account  NodeIdentity Model : Replaced  publickey: string  field to  publicAccount: PublicAccount",
            "title": "0.3.2"
        },
        {
            "location": "/#031",
            "text": "Released 24 July 2017",
            "title": "0.3.1"
        },
        {
            "location": "/#030-rc4",
            "text": "Encrypted Message",
            "title": "0.3.0-RC4"
        },
        {
            "location": "/#030-rc1",
            "text": "Pagination  Listeners  Wallets",
            "title": "0.3.0-RC1"
        },
        {
            "location": "/#0234",
            "text": "Stable version",
            "title": "0.2.34"
        },
        {
            "location": "/documentation/architecture/",
            "text": "Architecture\n\n\nNEM Library works perfect in a \nmultitier architecture\n, because \nit is the layer between your business logic and the data tier. It enables the developers focus on the product rather than the \nNEM Blockchain specific API details due its higher abstraction.\n\n\n\n\n\n\nNEM Blockchain\n: Persistent layer.\n\n\nNEM Library\n: Abstraction layer.\n\n\nYour Application\n: Where the business logic resides.\n\n\nFinal Users\n: People who benefit the NEM Blockchain Technology.\n\n\n\n\nNEM Library has a functional programming approach to deal with the immutability of the NEM Blockchain. So, the developer will find\nhimself/herself comfortable with the easy way to fetch the state, and create new Transactions in order to change that state.\n\n\n\n\nBrief description of NEM Library organization\n\n\nNEM Library follows the next rules:\n\n\n\n\n\n\nInfrastructure\n: The HTTP requests are done following the \nRepository Pattern\n, and they return NEM Domain immutable \nmodels via the \nObservable Pattern\n. So, the state fetched from the NEM Blockchain cannot be changed via code. \n\n\n\n\n\n\nNEM Domain models\n: The NEM Domain models are \nimmutable\n by definition, the developer cannot change its attributes. \nInstead, the developer have to create new Transactions and dispatch them to NEM Blockchain via TransactionHTTP, in order to change the NEM Blockchain state.\n\n\n\n\n\n\nCharacteristics\n\n\n\n\n\n\nStandardized Contracts\n: Guaranteeing interoperability and harmonization of data models.\n\n\n\n\n\n\nLoose Coupling\n: Reducing the degree of component coupling fosters.\n\n\n\n\n\n\nAbstraction\n: Increasing long-term consistency of interoperability and allowing underlying components to evolve independently.\n\n\n\n\n\n\nReusability\n: Enabling high-level interoperability between modules and potential component consumers.\n\n\n\n\n\n\nStateless\n: Increasing availability and scalability of components allowing them to interoperate more frequent and reliable.\n\n\n\n\n\n\nComposability\n: For components to be effectively composable they must be interoperable.\n\n\n\n\n\n\nA key objective is for interoperability to become a natural design of the NEM Library, \nideally to extend that components to work with other products or systems.\n\n\nReactive\n\n\nNEM Library uses \nRxJS\n as Reactive Library. See its docs \nhere\n\n\n\n\n\n\nFunctional\n: Developers can avoid intricate stateful programs using clean input/output functions over\nobservable streams.\n\n\n\n\n\n\nLess is more\n:ReactiveX's operators often reduce what was once an elaborate challenge into a few lines\nof code.\n\n\n\n\n\n\nAsync error handling\n: Traditional try/catch is powerless for errors handling in asynchronous computations, but\nReactiveX will offer developers the proper tools to handling these sort of errors.\n\n\n\n\n\n\nConcurrency made easy\n: Observables and Schedulers in ReactiveX allow the programmer to abstract away\nlow-level threading, synchronization, and concurrency issues.\n\n\n\n\n\n\nFrontend\n: Simple manipulation of UI events and API responses on the Web using RxJS\n\n\n\n\n\n\nBackend\n: Embrace ReactiveX's asynchronicity, enabling concurrency and implementation independence.\n\n\n\n\n\n\nConnection Pool\n: NEM Library will offer a Connection Pool feature that will distribute load throughout the\nnetwork ensuring maintained connectivity, higher speeds and higher availability.",
            "title": "Architecture"
        },
        {
            "location": "/documentation/architecture/#architecture",
            "text": "NEM Library works perfect in a  multitier architecture , because \nit is the layer between your business logic and the data tier. It enables the developers focus on the product rather than the \nNEM Blockchain specific API details due its higher abstraction.    NEM Blockchain : Persistent layer.  NEM Library : Abstraction layer.  Your Application : Where the business logic resides.  Final Users : People who benefit the NEM Blockchain Technology.   NEM Library has a functional programming approach to deal with the immutability of the NEM Blockchain. So, the developer will find\nhimself/herself comfortable with the easy way to fetch the state, and create new Transactions in order to change that state.",
            "title": "Architecture"
        },
        {
            "location": "/documentation/architecture/#brief-description-of-nem-library-organization",
            "text": "NEM Library follows the next rules:    Infrastructure : The HTTP requests are done following the  Repository Pattern , and they return NEM Domain immutable \nmodels via the  Observable Pattern . So, the state fetched from the NEM Blockchain cannot be changed via code.     NEM Domain models : The NEM Domain models are  immutable  by definition, the developer cannot change its attributes. \nInstead, the developer have to create new Transactions and dispatch them to NEM Blockchain via TransactionHTTP, in order to change the NEM Blockchain state.",
            "title": "Brief description of NEM Library organization"
        },
        {
            "location": "/documentation/architecture/#characteristics",
            "text": "Standardized Contracts : Guaranteeing interoperability and harmonization of data models.    Loose Coupling : Reducing the degree of component coupling fosters.    Abstraction : Increasing long-term consistency of interoperability and allowing underlying components to evolve independently.    Reusability : Enabling high-level interoperability between modules and potential component consumers.    Stateless : Increasing availability and scalability of components allowing them to interoperate more frequent and reliable.    Composability : For components to be effectively composable they must be interoperable.    A key objective is for interoperability to become a natural design of the NEM Library, \nideally to extend that components to work with other products or systems.",
            "title": "Characteristics"
        },
        {
            "location": "/documentation/architecture/#reactive",
            "text": "NEM Library uses  RxJS  as Reactive Library. See its docs  here    Functional : Developers can avoid intricate stateful programs using clean input/output functions over\nobservable streams.    Less is more :ReactiveX's operators often reduce what was once an elaborate challenge into a few lines\nof code.    Async error handling : Traditional try/catch is powerless for errors handling in asynchronous computations, but\nReactiveX will offer developers the proper tools to handling these sort of errors.    Concurrency made easy : Observables and Schedulers in ReactiveX allow the programmer to abstract away\nlow-level threading, synchronization, and concurrency issues.    Frontend : Simple manipulation of UI events and API responses on the Web using RxJS    Backend : Embrace ReactiveX's asynchronicity, enabling concurrency and implementation independence.    Connection Pool : NEM Library will offer a Connection Pool feature that will distribute load throughout the\nnetwork ensuring maintained connectivity, higher speeds and higher availability.",
            "title": "Reactive"
        },
        {
            "location": "/documentation/overview/",
            "text": "Installation\n\n\nStep1\n: Add nem-library dependency to \npackage.json\n\n\n$> npm install nem-library --save\n\n\n\n\nStep2\n: Setup phase\n\n\nIn your application startup file, initialize NEMLibrary.\n\n\nimport { NEMLibrary, NetworkTypes } from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\n\n\n\nYour application can have two modes, \nNetworkTypes.TEST_NET\n and \nNetworkTypes.MAIN_NET\n.\nDepending on the environment that you want to use, you should call the bootstrap method, with \nMAIN_NET\n\nor \nTEST_NET\n.\n\n\nBecause the application should have a unique environment, calling \nNEMLibrary.bootstrap(_)\n multiple times will throw an \nError\n.\nIn case you need to change between environments in runtime, call \nNEMLibrary.reset()\n first.\n\n\nConfigure endpoints\n\n\nEach infrastructure endpoints share the same constructor.\n\n\n// Using custom NIS Node\nconst accountHttp = new AccountHttp([{\n    protocol: \"http\",\n    domain: \"104.128.226.60\",\n    port: \"7890\"\n}]);\n\n// Using default NIS Node\nconst accountHttpWithDefaultConfig = new AccountHttp();\n\n\n\n\nThe default values are:\n\n\nTEST NET\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nprotocol\n\n\nhttp\n\n\n\n\n\n\ndomain\n\n\nbigalice2.nem.ninja\n\n\n\n\n\n\nport\n\n\n7890\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nprotocol\n\n\nhttps\n\n\n\n\n\n\ndomain\n\n\npretestnet1.nem.ninja\n\n\n\n\n\n\nport\n\n\n7778\n\n\n\n\n\n\n\n\nMAIN NET\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nprotocol\n\n\nhttp\n\n\n\n\n\n\ndomain\n\n\nalice6.nem.ninja\n\n\n\n\n\n\nport\n\n\n7890\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nprotocol\n\n\nhttps\n\n\n\n\n\n\ndomain\n\n\nnis2.wnsl.biz\n\n\n\n\n\n\nport\n\n\n7779",
            "title": "Overview"
        },
        {
            "location": "/documentation/overview/#installation",
            "text": "Step1 : Add nem-library dependency to  package.json  $> npm install nem-library --save  Step2 : Setup phase  In your application startup file, initialize NEMLibrary.  import { NEMLibrary, NetworkTypes } from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);  Your application can have two modes,  NetworkTypes.TEST_NET  and  NetworkTypes.MAIN_NET .\nDepending on the environment that you want to use, you should call the bootstrap method, with  MAIN_NET \nor  TEST_NET .  Because the application should have a unique environment, calling  NEMLibrary.bootstrap(_)  multiple times will throw an  Error .\nIn case you need to change between environments in runtime, call  NEMLibrary.reset()  first.",
            "title": "Installation"
        },
        {
            "location": "/documentation/overview/#configure-endpoints",
            "text": "Each infrastructure endpoints share the same constructor.  // Using custom NIS Node\nconst accountHttp = new AccountHttp([{\n    protocol: \"http\",\n    domain: \"104.128.226.60\",\n    port: \"7890\"\n}]);\n\n// Using default NIS Node\nconst accountHttpWithDefaultConfig = new AccountHttp();  The default values are:  TEST NET     Parameter  Value      protocol  http    domain  bigalice2.nem.ninja    port  7890        Parameter  Value      protocol  https    domain  pretestnet1.nem.ninja    port  7778     MAIN NET     Parameter  Value      protocol  http    domain  alice6.nem.ninja    port  7890        Parameter  Value      protocol  https    domain  nis2.wnsl.biz    port  7779",
            "title": "Configure endpoints"
        },
        {
            "location": "/documentation/connection_pool/",
            "text": "Connection Pool\n\n\nNEM Library handles the connections to the NEM Nodes (NIS) automatically.\n\n\nHow to use it\n\n\nWe use \nAccountHttp\n for this example, but it works for every \n*Http\n class.\n\n\nAll \n*Http\n classes already use the Connection Pool by default. If no argument is passed into its constructor, the default NIS nodes will be used.\nIf you like to use your own NIS nodes, you could specify an array with the domain information.\n\n\nFurthermore, the Connection Pool allows you to specify the protocol that you like to use in the second constructor argument.\n\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n// Creates an AccountHttp instance with a pool of NIS nodes for TEST_NET\nconst accountHttpWithDefaultNodes = new AccountHttp();\n\n// Using an AccountHttp with a custom NIS nodes\nconst accountHttpWithCustomNodes = new AccountHttp([\n    {protocol: \"http\", domain: \"192.3.61.243\", port: 7890},\n    {protocol: \"http\", domain: \"23.228.67.85\", port: 7890}\n]);\n\n\n\n\nIn case you want to use a specific protocol, for example \nHTTPS\n, you can specify your preferred protocol in the \nAccountHttp\n constructor.\n\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\nconst accountHttpWithDefaultNodes = new AccountHttp(undefined, \"https\");\n\n\n\n\nHow it works\n\n\n\n\n\n\nThe NEM Library starts the request to a NIS node.\n\n\nIf the request is successfull, the result is returned. If not, step 3.\n\n\nThe connection pool handles the connection error and tries the next available server.",
            "title": "Connection pool"
        },
        {
            "location": "/documentation/connection_pool/#connection-pool",
            "text": "NEM Library handles the connections to the NEM Nodes (NIS) automatically.",
            "title": "Connection Pool"
        },
        {
            "location": "/documentation/connection_pool/#how-to-use-it",
            "text": "We use  AccountHttp  for this example, but it works for every  *Http  class.  All  *Http  classes already use the Connection Pool by default. If no argument is passed into its constructor, the default NIS nodes will be used.\nIf you like to use your own NIS nodes, you could specify an array with the domain information.  Furthermore, the Connection Pool allows you to specify the protocol that you like to use in the second constructor argument.  NEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n// Creates an AccountHttp instance with a pool of NIS nodes for TEST_NET\nconst accountHttpWithDefaultNodes = new AccountHttp();\n\n// Using an AccountHttp with a custom NIS nodes\nconst accountHttpWithCustomNodes = new AccountHttp([\n    {protocol: \"http\", domain: \"192.3.61.243\", port: 7890},\n    {protocol: \"http\", domain: \"23.228.67.85\", port: 7890}\n]);  In case you want to use a specific protocol, for example  HTTPS , you can specify your preferred protocol in the  AccountHttp  constructor.  NEMLibrary.bootstrap(NetworkTypes.TEST_NET);\nconst accountHttpWithDefaultNodes = new AccountHttp(undefined, \"https\");",
            "title": "How to use it"
        },
        {
            "location": "/documentation/connection_pool/#how-it-works",
            "text": "The NEM Library starts the request to a NIS node.  If the request is successfull, the result is returned. If not, step 3.  The connection pool handles the connection error and tries the next available server.",
            "title": "How it works"
        },
        {
            "location": "/documentation/account/",
            "text": "Account related requests\n\n\nThis chapter will guide you through the process of retrieving account information from a NEM Infrastructure Server (NIS). The information that can be retrieved is the durable account data, its meta data and information about transactions and harvested blocks.\n\n\nNIS supports two different kind of accounts: normal accounts and multsig (short for: multi signature) accounts:\n\n\nNormal accounts:\n\n\nNormal accounts are created and controlled by a private key. Any action for the account like sending NEM to another account via a transfer transaction is signed with this private key. If an attacker gains knowledge of the private key, he/she can rob the account. The private key must therefore be kept secret by all means.\n\n\nMultisig accounts:\n\n\nMultisig accounts can be created by converting a normal account to a multisig account via a aggregate modification transaction. This adds cosignatories to the account. After that modification, only the cosignatories can initiate an action for the account. Any action must be signed by all cosignatories. This makes a multisig account significantly more secure than a normal account. When a single cosignatory private key is gained by an attacker, the attacker still can`t initiate any action on the account since all cosignatories must sign. It is strongly recommended to convert any account holding a significantly high amount of NEM into a multisig account with at least 3 cosignatories. Once converted to a multisig account, the original private key for the account plays no role any more.\n\n\nOfficial Source\n\n\nKeypair concept\n\n\nNEM Library replaces the Keypair model, which usually holds the public and private key, with the \nAccount\n model. The reason is that we aim to keep the private key as secret as possible, just providing a set of methods where the private key is involved.\n\n\nAccountHttp definition\n\n\nexport declare class AccountHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n    /**\n     * Gets an AccountInfoWithMetaData for an account.\n     * @param address - Address\n     * @return Observable<AccountInfoWithMetaData>\n     */\n    getFromAddress(address: Address): Observable<AccountInfoWithMetaData>;\n    /**\n     * Gets an AccountInfoWithMetaData for an account with publicKey\n     * @param publicKey - NEM\n     * @return Observable<AccountInfoWithMetaData>\n     */\n    getFromPublicKey(publicKey: string): Observable<AccountInfoWithMetaData>;\n    /**\n     * Given a delegate (formerly known as remote) account's address, gets the AccountMetaDataPair for the account for which the given account is the delegate account.\n     * If the given account address is not a delegate account for any account, the request returns the AccountMetaDataPair for the given address.\n     * @param address - Address\n     * @return Observable<AccountInfoWithMetaData>\n     */\n    getOriginalAccountDataFromDelegatedAccountAddress(address: Address): Observable<AccountInfoWithMetaData>;\n    /**\n     * retrieve the original account data by providing the public key of the delegate account.\n     * @param publicKey - string\n     * @return Observable<AccountInfoWithMetaData>\n     */\n    getOriginalAccountDataFromDelegatedAccountPublicKey(publicKey: string): Observable<AccountInfoWithMetaData>;\n    /**\n     * Gets the AccountMetaData from an account.\n     * @param address - NEM Address\n     * @return Observable<AccountStatus>\n     */\n    status(address: Address): Observable<AccountStatus>;\n    /**\n     * A transaction is said to be incoming with respect to an account if the account is the recipient of the transaction.\n     * In the same way outgoing transaction are the transactions where the account is the sender of the transaction.\n     * Unconfirmed transactions are those transactions that have not yet been included in a block.\n     * Unconfirmed transactions are not guaranteed to be included in any block\n     * @param address - The address of the account.\n     * @param params\n     */\n    incomingTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>;\n    /**\n     * Paginaged version of incomingTransactions request\n     * @param address\n     * @param params\n     */\n    incomingTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>;\n    /**\n     * Gets an array of transaction meta data pairs where the recipient has the address given as parameter to the request.\n     * A maximum of 25 transaction meta data pairs is returned. For details about sorting and discussion of the second parameter see Incoming transactions.\n     * @param address - The address of the account.\n     * @param params\n     */\n    outgoingTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>;\n    /**\n     * Paginaged version of outgoingTransactions request\n     * @param address\n     * @param params\n     * @param params\n     */\n    outgoingTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>;\n    /**\n     * Gets an array of transaction meta data pairs for which an account is the sender or receiver.\n     * A maximum of 25 transaction meta data pairs is returned.\n     * For details about sorting and discussion of the second parameter see Incoming transactions.\n     * @param address - The address of the account.\n     * @param params\n     */\n    allTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>;\n    /**\n     * Paginaged version of allTransactions request\n     * @param address\n     * @param params\n     */\n    allTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>;\n    /**\n     * Gets the array of transactions for which an account is the sender or receiver and which have not yet been included in a block\n     * @param address - NEM Address\n     * @return Observable<Transaction[]>\n     */\n    unconfirmedTransactions(address: Address): Observable<Transaction[]>;\n    /**\n     * Gets an array of harvest info objects for an account.\n     * @param address - Address\n     * @param id - string (optional)\n     * @return Observable<AccountHarvestInfo[]>\n     */\n    getHarvestInfoDataForAnAccount(address: Address, id?: string): Observable<AccountHarvestInfo[]>;\n    /**\n     * Paginaged version of allTransactions request\n     * @param address\n     * @param id\n     * @returns {HarvestInfoPageable}\n     */\n    getHarvestInfoDataForAnAccountPaginated(address: Address, id?: string): Pageable<AccountHarvestInfo[]>;\n    /**\n     * Gets an array of account importance view model objects.\n     * @return Observable<AccountImportanceInfo[]>\n     */\n    getAccountImportances(): Observable<AccountImportanceInfo[]>;\n    /**\n     * Gets an array of namespace objects for a given account address.\n     * The parent parameter is optional. If supplied, only sub-namespaces of the parent namespace are returned.\n     * @param address - Address\n     * @param parent - The optional parent namespace id.\n     * @param id - The optional namespace database id up to which namespaces are returned.\n     * @param pageSize - The (optional) number of namespaces to be returned.\n     * @return Observable<Namespace[]>\n     */\n    getNamespaceOwnedByAddress(address: Address, parent?: string, pageSize?: number, id?: string): Observable<Namespace[]>;\n    /**\n     * Gets an array of mosaic definition objects for a given account address. The parent parameter is optional.\n     * If supplied, only mosaic definitions for the given parent namespace are returned.\n     * The id parameter is optional and allows retrieving mosaic definitions in batches of 25 mosaic definitions.\n     * @param address - The address of the account.\n     * @param parent - The optional parent namespace id.\n     * @param id - The optional mosaic definition database id up to which mosaic definitions are returned.\n     * @return Observable<MosaicDefinition[]>\n     */\n    getMosaicCreatedByAddress(address: Address, parent?: string, id?: string): Observable<MosaicDefinition[]>;\n    /**\n     * Gets an array of mosaic objects for a given account address.\n     * @param address - Address\n     * @return Observable<Mosaic[]>\n     */\n    getMosaicOwnedByAddress(address: Address): Observable<Mosaic[]>;\n    /**\n     * Unlocks an account (starts harvesting).\n     * @param host - string\n     * @param privateKey - string\n     * @return Observable<boolean>\n     */\n    unlockHarvesting(host: string, privateKey: string): Observable<boolean>;\n    /**\n     * Locks an account (stops harvesting).\n     * @param host - string\n     * @param privateKey - string\n     * @return Observable<boolean>\n     */\n    lockHarvesting(host: string, privateKey: string): Observable<boolean>;\n    /**\n     * Each node can allow users to harvest with their delegated key on that node.\n     * The NIS configuration has entries for configuring the maximum number of allowed harvesters and optionally allow harvesting only for certain account addresses.\n     * The unlock info gives information about the maximum number of allowed harvesters and how many harvesters are already using the node.\n     * @return Observable<NodeHarvestInfo>\n     */\n    unlockInfo(): Observable<NodeHarvestInfo>;\n    /**\n     * Gets historical information for an account.\n     * @param address - The address of the account.\n     * @param startHeight - The block height from which on the data should be supplied.\n     * @param endHeight - The block height up to which the data should be supplied. The end height must be greater than or equal to the start height.\n     * @param increment - The value by which the height is incremented between each data point. The value must be greater than 0. NIS can supply up to 1000 data points with one request. Requesting more than 1000 data points results in an error.\n     * @return Observable<AccountHistoricalInfo[]>\n     */\n    getHistoricalAccountData(address: Address, startHeight: number, endHeight: number, increment: number): Observable<AccountHistoricalInfo[]>;\n}\n\n\n\n\n\nQueryParams\n\n\nexport interface QueryParams {\n    /**\n     * (Optional) The xem of transactions returned. Between 5 and 100, otherwise 10\n     */\n    pageSize?: number;\n    /**\n     * (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned.\n     */\n    hash?: string;\n    /**\n     * (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash.\n     */\n    id?: string;\n}\n\n\n\n\nAccountHttp usage\n\n\nimport {AccountHttp, NEMLibrary, NetworkTypes, Address} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"\");\n\nconst accountHttp = new AccountHttp();\naccountHttp.getFromAddress(address).subscribe(accountInfoWithMetaData => {\n    console.log(accountInfoWithMetaData);\n});\n\n\n\n\nOutput:\n\n\nAccountInfoWithMetaData {\n  balance: \n   Balance {\n     balance: 50481110745315,\n     vestedBalance: 50480744575985,\n     unvestedBalance: 366169330 },\n  importance: 0.005735794657626706,\n  publicAccount: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C',\n        networkType: 152 },\n     publicKey: '74375c15c6ce6bdbde59be88a069745a0de34444ea933f8c9f46ef407cf30196' },\n  harvestedBlocks: 116319,\n  cosignatoriesCount: undefined,\n  minCosignatories: undefined,\n  status: 'UNLOCKED',\n  remoteStatus: 'INACTIVE',\n  cosignatoryOf: [],\n  cosignatories: [] }\n\n\n\n\nRun the code\n\n\nModels\n\n\n Account\n\n\n/**\n * Account model\n */\nexport declare class Account extends PublicAccount {\n\n    private readonly privateKey;\n    /**\n     * Sign a transaction\n     * @param transaction\n     * @returns {{data: any, signature: string}}\n     */\n    signTransaction(transaction: Transaction): SignedTransaction;\n\n    /**\n     * constructor with private key\n     * @param privateKey\n     * @returns {Account}\n     */\n    static createWithPrivateKey(privateKey: string): Account;\n\n    /**\n     * Create a new encrypted Message\n     * @param message\n     * @param recipientPublicAccount\n     * @returns {EncryptedMessage}\n     */\n    encryptMessage(message: string, recipientPublicAccount: PublicAccount): EncryptedMessage;\n\n    /**\n     * Decrypts an encrypted message\n     * @param encryptedMessage\n     * @param recipientPublicAccount\n     * @returns {PlainMessage}\n     */\n    decryptMessage(encryptedMessage: EncryptedMessage, recipientPublicAccount: PublicAccount): PlainMessage;\n}\n\n\n\n\nPublicAccount\n\n\n\n/**\n * Public account\n */\nexport declare class PublicAccount {\n\n    readonly address: Address;\n    readonly publicKey: string;\n\n    /**\n     * @returns {boolean}\n     */\n    hasPublicKey(): boolean;\n\n    /**\n     * Creates a new PublicAccount from a public key\n     * @param publicKey\n     * @returns {PublicAccount}\n     */\n    static createWithPublicKey(publicKey: string): PublicAccount;\n}\n\n\n\n\nAddress\n\n\n/**\n * Address model\n */\nexport declare class Address {\n\n    private readonly value;\n    private readonly networkType;\n    constructor(address: string);\n\n    /**\n     * Get address in plain format ex: TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C\n     * @returns {string}\n     */\n    plain(): string;\n\n    /**\n     * Get address in pretty format ex: TALICE-ROONSJ-CPHC63-F52V6F-Y3SDMS-VAEUGH-MB7C\n     * @returns {string}\n     */\n    pretty(): string;\n\n    /**\n     * Address network\n     * @returns {number}\n     */\n    network(): NetworkTypes;\n}\n\n\n\n\n\nBalance\n\n\n/**\n * Balance model\n */\nexport declare class Balance {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: number;\n\n    /**\n     * The vested part of the balance of the account in micro NEM.\n     */\n    readonly vestedBalance: number;\n\n    /**\n     * The unvested part of the balance of the account in micro NEM.\n     */\n    readonly unvestedBalance: number;\n}\n\n\n\n\n\nAccountInfo\n\n\nexport declare enum RemoteStatus {\n    REMOTE = \"REMOTE\",\n    ACTIVATING = \"ACTIVATING\",\n    ACTIVE = \"ACTIVE\",\n    DEACTIVATING = \"DEACTIVATING\",\n    INACTIVE = \"INACTIVE\",\n}\nexport declare enum Status {\n    UNKNOWN = \"UNKNOWN\",\n    LOCKED = \"LOCKED\",\n    UNLOCKED = \"UNLOCKED\",\n}\n\n/**\n * The account structure describes basic information for an account.\n */\nexport declare class AccountInfo {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: Balance;\n\n    /**\n     * The importance of the account.\n     */\n    readonly importance: number;\n\n    /**\n     * The public key of the account.\n     */\n    readonly publicAccount: PublicAccount;\n\n    /**\n     * The number blocks that the account already harvested.\n     */\n    readonly harvestedBlocks: number;\n\n    /**\n     * Total number of cosignatories\n     */\n    readonly cosignatoriesCount?: number;\n\n    /**\n     * Minimum number of cosignatories needed for a transaction to be processed\n     */\n    readonly minCosignatories?: number;\n}\n\nexport declare class AccountInfoWithMetaData extends AccountInfo {\n\n    /**\n     * The harvesting status of a queried account\n     */\n    readonly status: Status;\n\n    /**\n     * The status of remote harvesting of a queried account\n     */\n    readonly remoteStatus: RemoteStatus;\n\n    /**\n     * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array.\n     */\n    readonly cosignatoryOf: AccountInfo[];\n\n    /**\n     * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account.\n     */\n    readonly cosignatories: AccountInfo[];\n}\n\nexport declare class AccountStatus {\n\n    /**\n     * The harvesting status of a queried account\n     */\n    readonly status: Status;\n\n    /**\n     * The status of remote harvesting of a queried account\n     */\n    readonly remoteStatus: RemoteStatus;\n\n    /**\n     * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array.\n     */\n    readonly cosignatoryOf: AccountInfo[];\n\n    /**\n     * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account.\n     */\n    readonly cosignatories: AccountInfo[];\n}\n\n\n\n\n\nAccountHarvestInfo\n\n\n/**\n * A HarvestInfo object contains information about a block that an account harvested.\n */\nexport declare class AccountHarvestInfo {\n\n    /**\n     * The number of seconds elapsed since the creation of the nemesis block.\n     */\n    readonly timeStamp: number;\n\n    /**\n     * The database id for the harvested block.\n     */\n    readonly id: number;\n\n    /**\n     * The block difficulty. The initial difficulty was set to 100000000000000. The block difficulty is always between one tenth and ten times the initial difficulty.\n     */\n    readonly difficulty: number;\n\n    /**\n     * The total fee collected by harvesting the block.\n     */\n    readonly totalFee: number;\n\n    /**\n     * The height of the harvested block.\n     */\n    readonly height: number;\n}\n\n\n\n\n\nAccountHistoricalInfo\n\n\n/**\n * Nodes can support a feature for retrieving historical data of accounts.\n * If this is supported, it returns an array of AccountHistoricalInfo\n */\nexport declare class AccountHistoricalInfo {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: Balance;\n\n    /**\n     * The importance of the account.\n     */\n    readonly importance: number;\n\n    /**\n     * The public key of the account.\n     */\n    readonly address: Address;\n\n    /**\n     * The page rank part of the importance.\n     */\n    readonly pageRank: number;\n}\n\n\n\n\nAccountImportanceInfo\n\n\n/**\n * Each account is assigned an importance in the NEM network. The ability of an account to generate new blocks is proportional to its importance. The importance is a number between 0 and 1.\n */\nexport declare class AccountImportanceInfo {\n\n    /**\n     * The address of the account.\n     */\n    readonly address: Address;\n\n    /**\n     * Substructure that describes the importance of the account.\n     */\n    readonly importance: AccountImportanceData;\n}\n\n/**\n * Substructure that describes the importance of the account.\n */\nexport declare class AccountImportanceData {\n    /**\n     * Indicates if the fields \"score\", \"ev\" and \"height\" are available.isSet can have the values 0 or 1. In case isSet is 0 the fields are not available.\n     */\n    readonly isSet: number;\n\n    /**\n     * The importance of the account. The importance ranges between 0 and 1.\n     */\n    readonly score?: number;\n\n    /**\n     * The page rank portion of the importance. The page rank ranges between 0 and 1.\n     */\n    readonly ev?: number;\n\n    /**\n     * The height at which the importance calculation was performed.\n     */\n    readonly height?: number;\n}\n\n\n\n\n\nNodeHarvestInfo\n\n\nexport declare class NodeHarvestInfo {\n\n    /**\n     * Maximum unlocked slots\n     */\n    readonly maxUnlocked: number;\n\n    /**\n     * Number of slots unlocked\n     */\n    readonly numUnlocked: number;\n}\n\n\n\n\n\nPageable\n\n\n/**\n * Pageable class\n */\nexport declare class Pageable<T> extends Subject<T> {\n    /**\n     * Execute next page\n     */\n    nextPage(): void;\n}",
            "title": "Account"
        },
        {
            "location": "/documentation/account/#account-related-requests",
            "text": "This chapter will guide you through the process of retrieving account information from a NEM Infrastructure Server (NIS). The information that can be retrieved is the durable account data, its meta data and information about transactions and harvested blocks.  NIS supports two different kind of accounts: normal accounts and multsig (short for: multi signature) accounts:  Normal accounts:  Normal accounts are created and controlled by a private key. Any action for the account like sending NEM to another account via a transfer transaction is signed with this private key. If an attacker gains knowledge of the private key, he/she can rob the account. The private key must therefore be kept secret by all means.  Multisig accounts:  Multisig accounts can be created by converting a normal account to a multisig account via a aggregate modification transaction. This adds cosignatories to the account. After that modification, only the cosignatories can initiate an action for the account. Any action must be signed by all cosignatories. This makes a multisig account significantly more secure than a normal account. When a single cosignatory private key is gained by an attacker, the attacker still can`t initiate any action on the account since all cosignatories must sign. It is strongly recommended to convert any account holding a significantly high amount of NEM into a multisig account with at least 3 cosignatories. Once converted to a multisig account, the original private key for the account plays no role any more.  Official Source",
            "title": "Account related requests"
        },
        {
            "location": "/documentation/account/#keypair-concept",
            "text": "NEM Library replaces the Keypair model, which usually holds the public and private key, with the  Account  model. The reason is that we aim to keep the private key as secret as possible, just providing a set of methods where the private key is involved.",
            "title": "Keypair concept"
        },
        {
            "location": "/documentation/account/#accounthttp-definition",
            "text": "export declare class AccountHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n    /**\n     * Gets an AccountInfoWithMetaData for an account.\n     * @param address - Address\n     * @return Observable<AccountInfoWithMetaData>\n     */\n    getFromAddress(address: Address): Observable<AccountInfoWithMetaData>;\n    /**\n     * Gets an AccountInfoWithMetaData for an account with publicKey\n     * @param publicKey - NEM\n     * @return Observable<AccountInfoWithMetaData>\n     */\n    getFromPublicKey(publicKey: string): Observable<AccountInfoWithMetaData>;\n    /**\n     * Given a delegate (formerly known as remote) account's address, gets the AccountMetaDataPair for the account for which the given account is the delegate account.\n     * If the given account address is not a delegate account for any account, the request returns the AccountMetaDataPair for the given address.\n     * @param address - Address\n     * @return Observable<AccountInfoWithMetaData>\n     */\n    getOriginalAccountDataFromDelegatedAccountAddress(address: Address): Observable<AccountInfoWithMetaData>;\n    /**\n     * retrieve the original account data by providing the public key of the delegate account.\n     * @param publicKey - string\n     * @return Observable<AccountInfoWithMetaData>\n     */\n    getOriginalAccountDataFromDelegatedAccountPublicKey(publicKey: string): Observable<AccountInfoWithMetaData>;\n    /**\n     * Gets the AccountMetaData from an account.\n     * @param address - NEM Address\n     * @return Observable<AccountStatus>\n     */\n    status(address: Address): Observable<AccountStatus>;\n    /**\n     * A transaction is said to be incoming with respect to an account if the account is the recipient of the transaction.\n     * In the same way outgoing transaction are the transactions where the account is the sender of the transaction.\n     * Unconfirmed transactions are those transactions that have not yet been included in a block.\n     * Unconfirmed transactions are not guaranteed to be included in any block\n     * @param address - The address of the account.\n     * @param params\n     */\n    incomingTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>;\n    /**\n     * Paginaged version of incomingTransactions request\n     * @param address\n     * @param params\n     */\n    incomingTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>;\n    /**\n     * Gets an array of transaction meta data pairs where the recipient has the address given as parameter to the request.\n     * A maximum of 25 transaction meta data pairs is returned. For details about sorting and discussion of the second parameter see Incoming transactions.\n     * @param address - The address of the account.\n     * @param params\n     */\n    outgoingTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>;\n    /**\n     * Paginaged version of outgoingTransactions request\n     * @param address\n     * @param params\n     * @param params\n     */\n    outgoingTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>;\n    /**\n     * Gets an array of transaction meta data pairs for which an account is the sender or receiver.\n     * A maximum of 25 transaction meta data pairs is returned.\n     * For details about sorting and discussion of the second parameter see Incoming transactions.\n     * @param address - The address of the account.\n     * @param params\n     */\n    allTransactions(address: Address, params?: QueryParams): Observable<Transaction[]>;\n    /**\n     * Paginaged version of allTransactions request\n     * @param address\n     * @param params\n     */\n    allTransactionsPaginated(address: Address, params?: QueryParams): Pageable<Transaction[]>;\n    /**\n     * Gets the array of transactions for which an account is the sender or receiver and which have not yet been included in a block\n     * @param address - NEM Address\n     * @return Observable<Transaction[]>\n     */\n    unconfirmedTransactions(address: Address): Observable<Transaction[]>;\n    /**\n     * Gets an array of harvest info objects for an account.\n     * @param address - Address\n     * @param id - string (optional)\n     * @return Observable<AccountHarvestInfo[]>\n     */\n    getHarvestInfoDataForAnAccount(address: Address, id?: string): Observable<AccountHarvestInfo[]>;\n    /**\n     * Paginaged version of allTransactions request\n     * @param address\n     * @param id\n     * @returns {HarvestInfoPageable}\n     */\n    getHarvestInfoDataForAnAccountPaginated(address: Address, id?: string): Pageable<AccountHarvestInfo[]>;\n    /**\n     * Gets an array of account importance view model objects.\n     * @return Observable<AccountImportanceInfo[]>\n     */\n    getAccountImportances(): Observable<AccountImportanceInfo[]>;\n    /**\n     * Gets an array of namespace objects for a given account address.\n     * The parent parameter is optional. If supplied, only sub-namespaces of the parent namespace are returned.\n     * @param address - Address\n     * @param parent - The optional parent namespace id.\n     * @param id - The optional namespace database id up to which namespaces are returned.\n     * @param pageSize - The (optional) number of namespaces to be returned.\n     * @return Observable<Namespace[]>\n     */\n    getNamespaceOwnedByAddress(address: Address, parent?: string, pageSize?: number, id?: string): Observable<Namespace[]>;\n    /**\n     * Gets an array of mosaic definition objects for a given account address. The parent parameter is optional.\n     * If supplied, only mosaic definitions for the given parent namespace are returned.\n     * The id parameter is optional and allows retrieving mosaic definitions in batches of 25 mosaic definitions.\n     * @param address - The address of the account.\n     * @param parent - The optional parent namespace id.\n     * @param id - The optional mosaic definition database id up to which mosaic definitions are returned.\n     * @return Observable<MosaicDefinition[]>\n     */\n    getMosaicCreatedByAddress(address: Address, parent?: string, id?: string): Observable<MosaicDefinition[]>;\n    /**\n     * Gets an array of mosaic objects for a given account address.\n     * @param address - Address\n     * @return Observable<Mosaic[]>\n     */\n    getMosaicOwnedByAddress(address: Address): Observable<Mosaic[]>;\n    /**\n     * Unlocks an account (starts harvesting).\n     * @param host - string\n     * @param privateKey - string\n     * @return Observable<boolean>\n     */\n    unlockHarvesting(host: string, privateKey: string): Observable<boolean>;\n    /**\n     * Locks an account (stops harvesting).\n     * @param host - string\n     * @param privateKey - string\n     * @return Observable<boolean>\n     */\n    lockHarvesting(host: string, privateKey: string): Observable<boolean>;\n    /**\n     * Each node can allow users to harvest with their delegated key on that node.\n     * The NIS configuration has entries for configuring the maximum number of allowed harvesters and optionally allow harvesting only for certain account addresses.\n     * The unlock info gives information about the maximum number of allowed harvesters and how many harvesters are already using the node.\n     * @return Observable<NodeHarvestInfo>\n     */\n    unlockInfo(): Observable<NodeHarvestInfo>;\n    /**\n     * Gets historical information for an account.\n     * @param address - The address of the account.\n     * @param startHeight - The block height from which on the data should be supplied.\n     * @param endHeight - The block height up to which the data should be supplied. The end height must be greater than or equal to the start height.\n     * @param increment - The value by which the height is incremented between each data point. The value must be greater than 0. NIS can supply up to 1000 data points with one request. Requesting more than 1000 data points results in an error.\n     * @return Observable<AccountHistoricalInfo[]>\n     */\n    getHistoricalAccountData(address: Address, startHeight: number, endHeight: number, increment: number): Observable<AccountHistoricalInfo[]>;\n}",
            "title": "AccountHttp definition"
        },
        {
            "location": "/documentation/account/#queryparams",
            "text": "export interface QueryParams {\n    /**\n     * (Optional) The xem of transactions returned. Between 5 and 100, otherwise 10\n     */\n    pageSize?: number;\n    /**\n     * (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned.\n     */\n    hash?: string;\n    /**\n     * (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash.\n     */\n    id?: string;\n}",
            "title": "QueryParams"
        },
        {
            "location": "/documentation/account/#accounthttp-usage",
            "text": "import {AccountHttp, NEMLibrary, NetworkTypes, Address} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"\");\n\nconst accountHttp = new AccountHttp();\naccountHttp.getFromAddress(address).subscribe(accountInfoWithMetaData => {\n    console.log(accountInfoWithMetaData);\n});  Output:  AccountInfoWithMetaData {\n  balance: \n   Balance {\n     balance: 50481110745315,\n     vestedBalance: 50480744575985,\n     unvestedBalance: 366169330 },\n  importance: 0.005735794657626706,\n  publicAccount: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C',\n        networkType: 152 },\n     publicKey: '74375c15c6ce6bdbde59be88a069745a0de34444ea933f8c9f46ef407cf30196' },\n  harvestedBlocks: 116319,\n  cosignatoriesCount: undefined,\n  minCosignatories: undefined,\n  status: 'UNLOCKED',\n  remoteStatus: 'INACTIVE',\n  cosignatoryOf: [],\n  cosignatories: [] }  Run the code",
            "title": "AccountHttp usage"
        },
        {
            "location": "/documentation/account/#models",
            "text": "",
            "title": "Models"
        },
        {
            "location": "/documentation/account/#publicaccount",
            "text": "/**\n * Public account\n */\nexport declare class PublicAccount {\n\n    readonly address: Address;\n    readonly publicKey: string;\n\n    /**\n     * @returns {boolean}\n     */\n    hasPublicKey(): boolean;\n\n    /**\n     * Creates a new PublicAccount from a public key\n     * @param publicKey\n     * @returns {PublicAccount}\n     */\n    static createWithPublicKey(publicKey: string): PublicAccount;\n}",
            "title": "PublicAccount"
        },
        {
            "location": "/documentation/account/#address",
            "text": "/**\n * Address model\n */\nexport declare class Address {\n\n    private readonly value;\n    private readonly networkType;\n    constructor(address: string);\n\n    /**\n     * Get address in plain format ex: TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C\n     * @returns {string}\n     */\n    plain(): string;\n\n    /**\n     * Get address in pretty format ex: TALICE-ROONSJ-CPHC63-F52V6F-Y3SDMS-VAEUGH-MB7C\n     * @returns {string}\n     */\n    pretty(): string;\n\n    /**\n     * Address network\n     * @returns {number}\n     */\n    network(): NetworkTypes;\n}",
            "title": "Address"
        },
        {
            "location": "/documentation/account/#balance",
            "text": "/**\n * Balance model\n */\nexport declare class Balance {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: number;\n\n    /**\n     * The vested part of the balance of the account in micro NEM.\n     */\n    readonly vestedBalance: number;\n\n    /**\n     * The unvested part of the balance of the account in micro NEM.\n     */\n    readonly unvestedBalance: number;\n}",
            "title": "Balance"
        },
        {
            "location": "/documentation/account/#accountinfo",
            "text": "export declare enum RemoteStatus {\n    REMOTE = \"REMOTE\",\n    ACTIVATING = \"ACTIVATING\",\n    ACTIVE = \"ACTIVE\",\n    DEACTIVATING = \"DEACTIVATING\",\n    INACTIVE = \"INACTIVE\",\n}\nexport declare enum Status {\n    UNKNOWN = \"UNKNOWN\",\n    LOCKED = \"LOCKED\",\n    UNLOCKED = \"UNLOCKED\",\n}\n\n/**\n * The account structure describes basic information for an account.\n */\nexport declare class AccountInfo {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: Balance;\n\n    /**\n     * The importance of the account.\n     */\n    readonly importance: number;\n\n    /**\n     * The public key of the account.\n     */\n    readonly publicAccount: PublicAccount;\n\n    /**\n     * The number blocks that the account already harvested.\n     */\n    readonly harvestedBlocks: number;\n\n    /**\n     * Total number of cosignatories\n     */\n    readonly cosignatoriesCount?: number;\n\n    /**\n     * Minimum number of cosignatories needed for a transaction to be processed\n     */\n    readonly minCosignatories?: number;\n}\n\nexport declare class AccountInfoWithMetaData extends AccountInfo {\n\n    /**\n     * The harvesting status of a queried account\n     */\n    readonly status: Status;\n\n    /**\n     * The status of remote harvesting of a queried account\n     */\n    readonly remoteStatus: RemoteStatus;\n\n    /**\n     * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array.\n     */\n    readonly cosignatoryOf: AccountInfo[];\n\n    /**\n     * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account.\n     */\n    readonly cosignatories: AccountInfo[];\n}\n\nexport declare class AccountStatus {\n\n    /**\n     * The harvesting status of a queried account\n     */\n    readonly status: Status;\n\n    /**\n     * The status of remote harvesting of a queried account\n     */\n    readonly remoteStatus: RemoteStatus;\n\n    /**\n     * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array.\n     */\n    readonly cosignatoryOf: AccountInfo[];\n\n    /**\n     * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account.\n     */\n    readonly cosignatories: AccountInfo[];\n}",
            "title": "AccountInfo"
        },
        {
            "location": "/documentation/account/#accountharvestinfo",
            "text": "/**\n * A HarvestInfo object contains information about a block that an account harvested.\n */\nexport declare class AccountHarvestInfo {\n\n    /**\n     * The number of seconds elapsed since the creation of the nemesis block.\n     */\n    readonly timeStamp: number;\n\n    /**\n     * The database id for the harvested block.\n     */\n    readonly id: number;\n\n    /**\n     * The block difficulty. The initial difficulty was set to 100000000000000. The block difficulty is always between one tenth and ten times the initial difficulty.\n     */\n    readonly difficulty: number;\n\n    /**\n     * The total fee collected by harvesting the block.\n     */\n    readonly totalFee: number;\n\n    /**\n     * The height of the harvested block.\n     */\n    readonly height: number;\n}",
            "title": "AccountHarvestInfo"
        },
        {
            "location": "/documentation/account/#accounthistoricalinfo",
            "text": "/**\n * Nodes can support a feature for retrieving historical data of accounts.\n * If this is supported, it returns an array of AccountHistoricalInfo\n */\nexport declare class AccountHistoricalInfo {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: Balance;\n\n    /**\n     * The importance of the account.\n     */\n    readonly importance: number;\n\n    /**\n     * The public key of the account.\n     */\n    readonly address: Address;\n\n    /**\n     * The page rank part of the importance.\n     */\n    readonly pageRank: number;\n}",
            "title": "AccountHistoricalInfo"
        },
        {
            "location": "/documentation/account/#accountimportanceinfo",
            "text": "/**\n * Each account is assigned an importance in the NEM network. The ability of an account to generate new blocks is proportional to its importance. The importance is a number between 0 and 1.\n */\nexport declare class AccountImportanceInfo {\n\n    /**\n     * The address of the account.\n     */\n    readonly address: Address;\n\n    /**\n     * Substructure that describes the importance of the account.\n     */\n    readonly importance: AccountImportanceData;\n}\n\n/**\n * Substructure that describes the importance of the account.\n */\nexport declare class AccountImportanceData {\n    /**\n     * Indicates if the fields \"score\", \"ev\" and \"height\" are available.isSet can have the values 0 or 1. In case isSet is 0 the fields are not available.\n     */\n    readonly isSet: number;\n\n    /**\n     * The importance of the account. The importance ranges between 0 and 1.\n     */\n    readonly score?: number;\n\n    /**\n     * The page rank portion of the importance. The page rank ranges between 0 and 1.\n     */\n    readonly ev?: number;\n\n    /**\n     * The height at which the importance calculation was performed.\n     */\n    readonly height?: number;\n}",
            "title": "AccountImportanceInfo"
        },
        {
            "location": "/documentation/account/#nodeharvestinfo",
            "text": "export declare class NodeHarvestInfo {\n\n    /**\n     * Maximum unlocked slots\n     */\n    readonly maxUnlocked: number;\n\n    /**\n     * Number of slots unlocked\n     */\n    readonly numUnlocked: number;\n}",
            "title": "NodeHarvestInfo"
        },
        {
            "location": "/documentation/account/#pageable",
            "text": "/**\n * Pageable class\n */\nexport declare class Pageable<T> extends Subject<T> {\n    /**\n     * Execute next page\n     */\n    nextPage(): void;\n}",
            "title": "Pageable"
        },
        {
            "location": "/documentation/transaction/",
            "text": "Initiating transactions requests\n\n\nTransactions are the way of transferring NEM and/or messages from one account to another. Once a transaction is initiated, it is still unconfirmed and thus not yet accepted by the network. At this point, it is not yet clear if it will get included in a block. Never rely on a transaction which has the state 'unconfirmed'. Once it is included in a block, the transaction gets processed and, in case of a transfer transaction, the amount stated in the transaction gets transferred from the sender's account to the recipient's account. Additionally, the transaction fee is deducted from the sender's account. The transaction is said to have 0 confirmations at this point. When another block is added to the blockchain the transaction has 1 confirmation. The next block added to the chain will give it 2 confirmations and so on.\n\n\nCryptocurrencies have the ability to roll back part of the blockchain. This is essential for being able to resolve forks of the blockchain. There is, however, a maximum number of blocks that can be rolled back, which is called the \"rewrite limit\". Hence, forks can only be resolved up to a certain depth too. NEM has a rewrite limit of 360 blocks. Once a transaction has more than 360 confirmations, it cannot be reversed. In real life, forks that are deeper than 20 blocks do not happen, unless there was some severe problem with the blockchain due to a bug in the code or an attack of some kind.\n\n\nOfficial Source\n\n\nTransactionHttp definition\n\n\nexport declare class TransactionHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Send the signed transaction\n     * @param transaction\n     * @returns Observable<NemAnnounceResult>\n     */\n    announceTransaction(transaction: SignedTransaction): Observable<NemAnnounceResult>;\n\n    /**\n    * Receive a transaction by its hash\n    * @param {string} hash - transaction hash\n    * @returns Observable<Transaction>\n    */\n    getByHash(hash: string): Observable<Transaction>;\n}\n\n\n\n\nTransactionHttp usage\n\n\nimport {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, SignedTransaction\n} from \"nem-library\";\nimport {XEM} from \"nem-library/dist/src/models/mosaic/XEM\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY;\n\nconst cosignerAccount = Account.createWithPrivateKey(privateKey);\n\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(2),\n    EmptyMessage\n);\n\nconst multisigTransaction = MultisigTransaction.create(\n    TimeWindow.createWithDeadline(),\n    transferTransaction,\n    PublicAccount.createWithPublicKey(multisigAccountPublicKey)\n);\n\nconst transactionHttp = new TransactionHttp();\n\nconst signedTransaction: SignedTransaction = cosignerAccount.signTransaction(multisigTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));\n\n\n\n\nOutput\n\n\n\nNemAnnounceResult {\n  type: 1,\n  code: 1,\n  message: 'SUCCESS',\n  transactionHash: { data: '56b4d3e38cb5b707d4b96776116396c2885fd09be6945637f5657204528001b7' },\n  innerTransactionHash: { data: 'a61ce8d0df9aac98ae68e7d88a2f2bb453deb202fd95cf3cf375fde35e4e6794' } }\n\n\n\n\n\nRun the code\n\n\nModels\n\n\nTimeWindow\n\n\nexport declare class TimeWindow {\n    static timestampNemesisBlock: number;\n\n    /**\n     * The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block.\n     * If a transaction does not get included in a block before the deadline is reached, it is deleted.\n     */\n    deadline: LocalDateTime;\n\n    /**\n     * The number of seconds elapsed since the creation of the nemesis block.\n     */\n    timeStamp: LocalDateTime;\n\n    /**\n     * @param deadline\n     * @param chronoUnit\n     * @returns {TimeWindow}\n     */\n    static createWithDeadline(deadline?: number, chronoUnit?: ChronoUnit): TimeWindow;\n}\n\n\n\n\n\nTransactionInfo\n\n\nexport declare class TransactionInfo {\n\n    /**\n     * The height of the block in which the transaction was included.\n     */\n    readonly height: number;\n\n    /**\n     *  The id of the transaction.\n     */\n    readonly id: number;\n\n    /**\n     *  The transaction hash.\n     */\n    readonly hash: HashData;\n\n    /**\n     * constructor\n     * @param height\n     * @param id\n     * @param hash\n     */\n    constructor(height: number, id: number, hash: HashData);\n}\n\nexport declare class MultisigTransactionInfo extends TransactionInfo {\n\n    /**\n     * The hash of the inner transaction. This entry is only available for multisig transactions.\n     */\n    readonly innerHash: HashData;\n\n    /**\n     * constructor\n     * @param height\n     * @param id\n     * @param hash\n     * @param innerHash\n     */\n    constructor(height: number, id: number, hash: HashData, innerHash: HashData);\n}\n\n\n\n\n\nTransactionTypes\n\n\n/**\n * Static class containing transaction type constants.\n */\nexport declare class TransactionTypes {\n\n    /**\n     * Transfer Transaction\n     * @type {number}\n     */\n    static readonly TRANSFER: number;\n\n    /**\n     * Importance transfer transaction.\n     * @type {number}\n     */\n    static readonly IMPORTANCE_TRANSFER: number;\n\n    /**\n     * A new asset transaction.\n     * @type {number}\n     */\n    static readonly ASSET_NEW: number;\n\n    /**\n     * An asset ask transaction.\n     * @type {number}\n     */\n    static readonly ASSET_ASK: number;\n\n    /**\n     * An asset bid transaction.\n     * @type {number}\n     */\n    static readonly ASSET_BID: number;\n\n    /**\n     * A snapshot transaction.\n     * @type {number}\n     */\n    static readonly SNAPSHOT: number;\n\n    /**\n     * A multisig change transaction (e.g. announce an account as multi-sig).\n     * @type {number}\n     */\n    static readonly MULTISIG_AGGREGATE_MODIFICATION: number;\n\n    /**\n     * A multisig signature transaction.\n     * @type {number}\n     */\n    static readonly MULTISIG_SIGNATURE: number;\n\n    /**\n     * A multisig transaction.\n     * @type {number}\n     */\n    static readonly MULTISIG: number;\n\n    /**\n     * A provision namespace transaction.\n     * @type {number}\n     */\n    static readonly PROVISION_NAMESPACE: number;\n\n    /**\n     * A mosaic definition creation transaction.\n     * @type {number}\n     */\n    static readonly MOSAIC_DEFINITION_CREATION: number;\n\n    /**\n     * A mosaic supply change transaction.\n     * @type {number}\n     */\n    static readonly MOSAIC_SUPPLY_CHANGE: number;\n\n    /**\n     * Gets all multisig embeddable types.\n     * @returns {number[]}\n     */\n    static getMultisigEmbeddableTypes(): number[];\n\n    /**\n     * Gets all block embeddable types.\n     * @returns {number[]}\n     */\n    static getBlockEmbeddableTypes(): number[];\n\n    /**\n     * Gets all active types.\n     * @returns {number[]}\n     */\n    static getActiveTypes(): number[];\n}\n\n\n\n\n\nTransaction\n\n\n/**\n * An abstract transaction class that serves as the base class of all NEM transactions.\n */\nexport declare abstract class Transaction {\n\n    /**\n     * The transaction type.\n     */\n    readonly type: number;\n\n    /**\n     * The version of the structure.\n     */\n    readonly version: number;\n\n    /**\n     * The transaction signature (missing if part of a multisig transaction).\n     */\n    readonly signature?: string;\n\n    /**\n    * The public account of the transaction creator.\n    */\n    public signer?: PublicAccount;\n\n    /**\n     * TimeWindow\n     */\n    readonly timeWindow: TimeWindow;\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly abstract fee: number;\n\n    /**\n     * Transactions meta data object contains additional information about the transaction.\n     */\n    protected readonly transactionInfo?: TransactionInfo;\n\n    /**\n     * Checks if the transaction has been confirmed and included in a block\n     */\n    isConfirmed(): boolean;\n\n    /**\n     * Get transaction info\n     */\n    getTransactionInfo(): TransactionInfo;\n}\n\n\n\n\n\nTransferTransaction\n\n\n/**\n * Transfer transactions contain data about transfers of XEM or mosaics to another account.\n */\nexport declare class TransferTransaction extends Transaction {\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n    /**\n     * The address of the recipient.\n     */\n    readonly recipient: Address;\n    /**\n     * The xem of XEM that is transferred from sender to recipient.\n     */\n    private readonly _xem;\n    /**\n     * Optionally a transaction can contain a message. In this case the transaction contains a message substructure. If not the field is null.\n     */\n    readonly message: PlainMessage | EncryptedMessage;\n    /**\n     * The array of Mosaic objects.\n     */\n    private readonly _mosaics?;\n    /**\n     * in case that the transfer transaction contains mosaics, it throws an error\n     * @returns {XEM}\n     */\n    xem(): XEM;\n    /**\n     * in case that the transfer transaction does not contain mosaics, it throws an error\n     * @returns {Mosaic[]}\n     */\n    mosaics(): Mosaic[];\n    /**\n     *\n     * @returns {boolean}\n     */\n    containsMosaics(): boolean;\n    /**\n     * all the Mosaic Identifiers of the attached mosaics\n     * @returns {MosaicId[]}\n     */\n    mosaicIds(): MosaicId[];\n    /**\n     * Create a TransferTransaction object\n     * @param timeWindow\n     * @param recipient\n     * @param xem\n     * @param message\n     * @returns {TransferTransaction}\n     */\n    static create(timeWindow: TimeWindow, recipient: Address, xem: XEM, message: PlainMessage | EncryptedMessage): TransferTransaction;\n    /**\n     * Create a TransferTransaction object\n     * @param timeWindow\n     * @param recipient\n     * @param mosaics\n     * @param message\n     * @returns {TransferTransaction}\n     */\n    static createWithMosaics(timeWindow: TimeWindow, recipient: Address, mosaics: MosaicTransferable[], message: PlainMessage | EncryptedMessage): TransferTransaction;\n}\n\n\n\n\nMessage\n\n\n/**\n * Message model\n */\nexport declare abstract class Message {\n\n    /**\n     * Message payload\n     */\n    readonly payload: string;\n\n}\n\n\n\n\n\nPlainMessage\n\n\n/**\n * Plain Message model\n */\nexport declare class PlainMessage extends Message {\n\n    /**\n     * Create new constructor\n     * @returns {boolean}\n     */\n    static create(message: string): PlainMessage;\n\n    /**\n     * Message string\n     * @returns {string}\n     */\n    plain(): string;\n\n}\nexport declare const EmptyMessage: PlainMessage;\n\n\n\n\n\nEncryptedMessage\n\n\n/**\n * Encrypted Message model\n */\nexport declare class EncryptedMessage extends Message {\n    readonly recipientPublicAccount?: PublicAccount;\n}\n\n\n\n\n\n\nImportanceTransferTransaction\n\n\n\nexport declare enum ImportanceMode {\n    Activate = 1,\n    Deactivate = 2,\n}\n\n/**\n * NIS has the ability to transfer the importance of one account to another account for harvesting.\n * The account receiving the importance is called the remote account.\n * Importance transfer transactions are part of the secure harvesting feature of NEM.\n * Once an importance transaction has been included in a block it needs 6 hours to become active.\n */\nexport declare class ImportanceTransferTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The public key of the receiving account as hexadecimal string.\n     */\n    readonly remoteAccount: PublicAccount;\n\n    /**\n     * The mode, activate or deactivate\n     */\n    readonly mode: ImportanceMode;\n\n    /**\n     * Create a ImportanceTransferTransaction object\n     * @param timeWindow\n     * @param mode\n     * @param remoteAccount\n     * @returns {ImportanceTransferTransaction}\n     */\n    static create(timeWindow: TimeWindow, mode: ImportanceMode, remoteAccount: PublicAccount): ImportanceTransferTransaction;\n}\n\n\n\n\n\nProvisionNamespaceTransaction\n\n\n/**\n * Accounts can rent a namespace for one year and after a year renew the contract. This is done via a ProvisionNamespaceTransaction.\n */\nexport declare class ProvisionNamespaceTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The Address to which the rental fee is transferred.\n     */\n    readonly rentalFeeSink: Address;\n\n    /**\n     * The fee for renting the namespace.\n     */\n    readonly rentalFee: number;\n\n    /**\n     * The parent namespace. This can be undefined if the transaction rents a root namespace.\n     */\n    readonly parent?: string;\n\n    /**\n     * The new part which is concatenated to the parent with a '.' as separator.\n     */\n    readonly newPart: string;\n\n    /**\n     * Create a ProvisionNamespaceTransaction object\n     * @param timeWindow\n     * @param newPart\n     * @param parent\n     * @returns {ProvisionNamespaceTransaction}\n     */\n    static create(timeWindow: TimeWindow, newPart: string, parent?: string): ProvisionNamespaceTransaction;\n\n    /**\n   *\n   * @param {TimeWindow} timeWindow\n   * @param {string} namespaceName - Root namespace provision\n   * @returns {ProvisionNamespaceTransaction}\n   */\n  static createRoot(timeWindow: TimeWindow, namespaceName: string): ProvisionNamespaceTransaction;\n\n  /**\n   *\n   * @param {TimeWindow} timeWindow\n   * @param {string }parentNamespace\n   * @param {string} newNamespaceName\n   * @returns {ProvisionNamespaceTransaction}\n   */\n  static createSub(timeWindow: TimeWindow, parentNamespace: string, newNamespaceName: string): ProvisionNamespaceTransaction;\n}\n\n\n\n\nMosaicDefinitionCreationTransaction\n\n\n/**\n * Before a mosaic can be created or transferred, a corresponding definition of the mosaic has to be created and published to the network.\n * This is done via a mosaic definition creation transaction.\n */\nexport declare class MosaicDefinitionCreationTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The fee for the creation of the mosaic.\n     */\n    readonly creationFee: number;\n\n    /**\n     * The public account to which the creation fee is tranferred.\n     */\n    readonly creationFeeSink: Address;\n\n    /**\n     * The actual mosaic definition.\n     */\n    readonly mosaicDefinition: MosaicDefinition;\n\n    /**\n     * Create a MosaicDefinitionCreationTransaction object\n     * @param timeWindow\n     * @param mosaicDefinition\n     * @returns {MosaicDefinitionCreationTransaction}\n     */\n    static create(timeWindow: TimeWindow, mosaicDefinition: MosaicDefinition): MosaicDefinitionCreationTransaction;\n}\n\n\n\n\n\nMosaicSupplyChangeTransaction\n\n\nexport declare enum MosaicSupplyType {\n    Increase = 1,\n    Decrease = 2,\n}\n\n/**\n * In case a mosaic definition has the property 'supplyMutable' set to true, the creator of the mosaic definition can change the supply, i.e. increase or decrease the supply.\n */\nexport declare class MosaicSupplyChangeTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The mosaic id.\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The supply type.\n     */\n    readonly supplyType: MosaicSupplyType;\n\n    /**\n     * The supply change in units for the mosaic.\n     */\n    readonly delta: number;\n\n    /**\n     * Create a MosaicSupplyChangeTransaction object\n     * @param timeWindow\n     * @param mosaicId\n     * @param supplyType\n     * @param delta\n     * @returns {MosaicSupplyChangeTransaction}\n     */\n    static create(timeWindow: TimeWindow, mosaicId: MosaicId, supplyType: MosaicSupplyType, delta: number): MosaicSupplyChangeTransaction;\n}\n\n\n\n\n\nMultisigTransaction\n\n\n/**\n * Multisig transaction are the only way to make transaction from a multisig account to another account.\n * A multisig transaction carries another transaction inside (often referred to as \"inner\" transaction).\n * The inner transaction can be a transfer, an importance transfer or an aggregate modification transaction.\n * A multisig transaction also has multisig signature transactions from the cosignatories of the multisig account inside.\n */\nexport declare class MultisigTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction.\n     */\n    readonly fee: number;\n\n    /**\n     * The JSON array of MulsigSignatureTransaction objects.\n     */\n    readonly signatures: MultisigSignatureTransaction[];\n\n    /**\n     * The inner transaction. The inner transaction can be a transfer transaction, an importance transfer transaction or a multisig aggregate modification transaction.\n     * The inner transaction does not have a valid signature.\n     */\n    readonly otherTransaction: Transaction;\n\n    /**\n     * Hash data\n     */\n    readonly hashData?: HashData;\n\n    /**\n     * Check if transaction is pending to sign\n     * @returns {boolean}\n     */\n    isPendingToSign(): boolean;\n\n    /**\n     * Create a MultisigTransaction object\n     * @param timeWindow\n     * @param otherTrans\n     * @param multisig\n     * @returns {MultisigTransaction}\n     */\n    static create(timeWindow: TimeWindow, otherTrans: Transaction, multisig: PublicAccount): MultisigTransaction;\n}\n\n\n\n\n\nMultisigAggregateModificationTransaction\n\n\n/**\n * Multisig aggregate modification transactions are part of the NEM's multisig account system.\n * A multisig aggregate modification transaction holds an array of multisig cosignatory modifications and a single multisig minimum cosignatories modification inside the transaction.\n * A multisig aggregate modification transaction can be wrapped by a multisig transaction.\n */\nexport declare class MultisigAggregateModificationTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    fee: number;\n\n    /**\n     * Value indicating the relative change of the minimum cosignatories.\n     */\n    readonly relativeChange?: number;\n\n    /**\n     * The JSON array of multisig modifications.\n     */\n    readonly modifications: CosignatoryModification[];\n\n    /**\n     * Create a MultisigAggregateModificationTransaction object\n     * @param timeWindow\n     * @param modifications\n     * @param relativeChange\n     * @returns {MultisigAggregateModificationTransaction}\n     */\n    static create(timeWindow: TimeWindow, modifications: CosignatoryModification[], relativeChange?: number): MultisigAggregateModificationTransaction;\n}\n\n/**\n * The type of modification. Possible values are:\n * 1: Add a new cosignatory.\n * 2: Delete an existing cosignatory.\n */\nexport declare enum CosignatoryModificationAction {\n    ADD = 1,\n    DELETE = 2,\n}\n\nexport declare class CosignatoryModification {\n    readonly cosignatoryAccount: PublicAccount;\n    readonly action: CosignatoryModificationAction;\n\n    /**\n     * constructor\n     * @param cosignatoryAccount\n     * @param action\n     */\n    constructor(cosignatoryAccount: PublicAccount, action: CosignatoryModificationAction);\n}\n\n\n\n\n\nMultisigSignatureTransaction\n\n\n/**\n * Multisig signature transactions are part of the NEM's multisig account system. Multisig signature transactions are included in the corresponding multisig transaction and are the way a cosignatory of a multisig account can sign a multisig transaction for that account.\n */\nexport declare class MultisigSignatureTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The address of the corresponding multisig account.\n     */\n    readonly otherAccount: Address;\n\n    /**\n     * The hash of the inner transaction of the corresponding multisig transaction.\n     */\n    readonly otherHash: HashData;\n\n    /**\n     * Create a MultisigSignatureTransaction object\n     * @param timeWindow\n     * @param otherAccount\n     * @param otherHash\n     * @returns {MultisigSignatureTransaction}\n     */\n    static create(timeWindow: TimeWindow, otherAccount: Address, otherHash: HashData): MultisigSignatureTransaction;\n}\n\n\n\n\n\nSignedTransaction\n\n\n/**\n * SignedTransaction object is used to transfer the transaction data and the signature to NIS in order to initiate and broadcast a transaction.\n */\nexport interface SignedTransaction {\n\n    /**\n     * The transaction data as string.\n     */\n    readonly data: string;\n\n    /**\n     * The signature for the transaction as hexadecimal string.\n     */\n    readonly signature: string;\n}\n\n\n\n\n\nNemAnnounceResult\n\n\n\nexport declare enum TypeNemAnnounceResult {\n    Validation = 1,\n    HeartBeat = 2,\n    Status = 4,\n}\n\nexport declare type CodeNemAnnounceResult = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19;\n\n/**\n * The NemAnnounceResult extends the NemRequestResult by supplying the additional fields 'transactionHash' and in case of a multisig transaction 'innerTransactionHash'.\n */\nexport declare class NemAnnounceResult {\n\n    /**\n     * The type is dependent on the request which was answered.\n     */\n    readonly type: TypeNemAnnounceResult;\n\n    /**\n     * The meaning of the code is dependent on the type.\n     */\n    readonly code: CodeNemAnnounceResult;\n\n    /**\n     * Error or success message\n     */\n    readonly message: string;\n\n    /**\n     * The JSON hash object of the transaction.\n     */\n    readonly transactionHash: HashData;\n\n    /**\n     * The JSON hash object of the inner transaction or null if the transaction is not a multisig transaction.\n     */\n    readonly innerTransactionHash: HashData;\n}",
            "title": "Transaction"
        },
        {
            "location": "/documentation/transaction/#initiating-transactions-requests",
            "text": "Transactions are the way of transferring NEM and/or messages from one account to another. Once a transaction is initiated, it is still unconfirmed and thus not yet accepted by the network. At this point, it is not yet clear if it will get included in a block. Never rely on a transaction which has the state 'unconfirmed'. Once it is included in a block, the transaction gets processed and, in case of a transfer transaction, the amount stated in the transaction gets transferred from the sender's account to the recipient's account. Additionally, the transaction fee is deducted from the sender's account. The transaction is said to have 0 confirmations at this point. When another block is added to the blockchain the transaction has 1 confirmation. The next block added to the chain will give it 2 confirmations and so on.  Cryptocurrencies have the ability to roll back part of the blockchain. This is essential for being able to resolve forks of the blockchain. There is, however, a maximum number of blocks that can be rolled back, which is called the \"rewrite limit\". Hence, forks can only be resolved up to a certain depth too. NEM has a rewrite limit of 360 blocks. Once a transaction has more than 360 confirmations, it cannot be reversed. In real life, forks that are deeper than 20 blocks do not happen, unless there was some severe problem with the blockchain due to a bug in the code or an attack of some kind.  Official Source",
            "title": "Initiating transactions requests"
        },
        {
            "location": "/documentation/transaction/#transactionhttp-definition",
            "text": "export declare class TransactionHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Send the signed transaction\n     * @param transaction\n     * @returns Observable<NemAnnounceResult>\n     */\n    announceTransaction(transaction: SignedTransaction): Observable<NemAnnounceResult>;\n\n    /**\n    * Receive a transaction by its hash\n    * @param {string} hash - transaction hash\n    * @returns Observable<Transaction>\n    */\n    getByHash(hash: string): Observable<Transaction>;\n}",
            "title": "TransactionHttp definition"
        },
        {
            "location": "/documentation/transaction/#transactionhttp-usage",
            "text": "import {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, SignedTransaction\n} from \"nem-library\";\nimport {XEM} from \"nem-library/dist/src/models/mosaic/XEM\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY;\n\nconst cosignerAccount = Account.createWithPrivateKey(privateKey);\n\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(2),\n    EmptyMessage\n);\n\nconst multisigTransaction = MultisigTransaction.create(\n    TimeWindow.createWithDeadline(),\n    transferTransaction,\n    PublicAccount.createWithPublicKey(multisigAccountPublicKey)\n);\n\nconst transactionHttp = new TransactionHttp();\n\nconst signedTransaction: SignedTransaction = cosignerAccount.signTransaction(multisigTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));  Output  \nNemAnnounceResult {\n  type: 1,\n  code: 1,\n  message: 'SUCCESS',\n  transactionHash: { data: '56b4d3e38cb5b707d4b96776116396c2885fd09be6945637f5657204528001b7' },\n  innerTransactionHash: { data: 'a61ce8d0df9aac98ae68e7d88a2f2bb453deb202fd95cf3cf375fde35e4e6794' } }  Run the code",
            "title": "TransactionHttp usage"
        },
        {
            "location": "/documentation/transaction/#models",
            "text": "",
            "title": "Models"
        },
        {
            "location": "/documentation/transaction/#timewindow",
            "text": "export declare class TimeWindow {\n    static timestampNemesisBlock: number;\n\n    /**\n     * The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block.\n     * If a transaction does not get included in a block before the deadline is reached, it is deleted.\n     */\n    deadline: LocalDateTime;\n\n    /**\n     * The number of seconds elapsed since the creation of the nemesis block.\n     */\n    timeStamp: LocalDateTime;\n\n    /**\n     * @param deadline\n     * @param chronoUnit\n     * @returns {TimeWindow}\n     */\n    static createWithDeadline(deadline?: number, chronoUnit?: ChronoUnit): TimeWindow;\n}",
            "title": "TimeWindow"
        },
        {
            "location": "/documentation/transaction/#transactioninfo",
            "text": "export declare class TransactionInfo {\n\n    /**\n     * The height of the block in which the transaction was included.\n     */\n    readonly height: number;\n\n    /**\n     *  The id of the transaction.\n     */\n    readonly id: number;\n\n    /**\n     *  The transaction hash.\n     */\n    readonly hash: HashData;\n\n    /**\n     * constructor\n     * @param height\n     * @param id\n     * @param hash\n     */\n    constructor(height: number, id: number, hash: HashData);\n}\n\nexport declare class MultisigTransactionInfo extends TransactionInfo {\n\n    /**\n     * The hash of the inner transaction. This entry is only available for multisig transactions.\n     */\n    readonly innerHash: HashData;\n\n    /**\n     * constructor\n     * @param height\n     * @param id\n     * @param hash\n     * @param innerHash\n     */\n    constructor(height: number, id: number, hash: HashData, innerHash: HashData);\n}",
            "title": "TransactionInfo"
        },
        {
            "location": "/documentation/transaction/#transactiontypes",
            "text": "/**\n * Static class containing transaction type constants.\n */\nexport declare class TransactionTypes {\n\n    /**\n     * Transfer Transaction\n     * @type {number}\n     */\n    static readonly TRANSFER: number;\n\n    /**\n     * Importance transfer transaction.\n     * @type {number}\n     */\n    static readonly IMPORTANCE_TRANSFER: number;\n\n    /**\n     * A new asset transaction.\n     * @type {number}\n     */\n    static readonly ASSET_NEW: number;\n\n    /**\n     * An asset ask transaction.\n     * @type {number}\n     */\n    static readonly ASSET_ASK: number;\n\n    /**\n     * An asset bid transaction.\n     * @type {number}\n     */\n    static readonly ASSET_BID: number;\n\n    /**\n     * A snapshot transaction.\n     * @type {number}\n     */\n    static readonly SNAPSHOT: number;\n\n    /**\n     * A multisig change transaction (e.g. announce an account as multi-sig).\n     * @type {number}\n     */\n    static readonly MULTISIG_AGGREGATE_MODIFICATION: number;\n\n    /**\n     * A multisig signature transaction.\n     * @type {number}\n     */\n    static readonly MULTISIG_SIGNATURE: number;\n\n    /**\n     * A multisig transaction.\n     * @type {number}\n     */\n    static readonly MULTISIG: number;\n\n    /**\n     * A provision namespace transaction.\n     * @type {number}\n     */\n    static readonly PROVISION_NAMESPACE: number;\n\n    /**\n     * A mosaic definition creation transaction.\n     * @type {number}\n     */\n    static readonly MOSAIC_DEFINITION_CREATION: number;\n\n    /**\n     * A mosaic supply change transaction.\n     * @type {number}\n     */\n    static readonly MOSAIC_SUPPLY_CHANGE: number;\n\n    /**\n     * Gets all multisig embeddable types.\n     * @returns {number[]}\n     */\n    static getMultisigEmbeddableTypes(): number[];\n\n    /**\n     * Gets all block embeddable types.\n     * @returns {number[]}\n     */\n    static getBlockEmbeddableTypes(): number[];\n\n    /**\n     * Gets all active types.\n     * @returns {number[]}\n     */\n    static getActiveTypes(): number[];\n}",
            "title": "TransactionTypes"
        },
        {
            "location": "/documentation/transaction/#transaction",
            "text": "/**\n * An abstract transaction class that serves as the base class of all NEM transactions.\n */\nexport declare abstract class Transaction {\n\n    /**\n     * The transaction type.\n     */\n    readonly type: number;\n\n    /**\n     * The version of the structure.\n     */\n    readonly version: number;\n\n    /**\n     * The transaction signature (missing if part of a multisig transaction).\n     */\n    readonly signature?: string;\n\n    /**\n    * The public account of the transaction creator.\n    */\n    public signer?: PublicAccount;\n\n    /**\n     * TimeWindow\n     */\n    readonly timeWindow: TimeWindow;\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly abstract fee: number;\n\n    /**\n     * Transactions meta data object contains additional information about the transaction.\n     */\n    protected readonly transactionInfo?: TransactionInfo;\n\n    /**\n     * Checks if the transaction has been confirmed and included in a block\n     */\n    isConfirmed(): boolean;\n\n    /**\n     * Get transaction info\n     */\n    getTransactionInfo(): TransactionInfo;\n}",
            "title": "Transaction"
        },
        {
            "location": "/documentation/transaction/#transfertransaction",
            "text": "/**\n * Transfer transactions contain data about transfers of XEM or mosaics to another account.\n */\nexport declare class TransferTransaction extends Transaction {\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n    /**\n     * The address of the recipient.\n     */\n    readonly recipient: Address;\n    /**\n     * The xem of XEM that is transferred from sender to recipient.\n     */\n    private readonly _xem;\n    /**\n     * Optionally a transaction can contain a message. In this case the transaction contains a message substructure. If not the field is null.\n     */\n    readonly message: PlainMessage | EncryptedMessage;\n    /**\n     * The array of Mosaic objects.\n     */\n    private readonly _mosaics?;\n    /**\n     * in case that the transfer transaction contains mosaics, it throws an error\n     * @returns {XEM}\n     */\n    xem(): XEM;\n    /**\n     * in case that the transfer transaction does not contain mosaics, it throws an error\n     * @returns {Mosaic[]}\n     */\n    mosaics(): Mosaic[];\n    /**\n     *\n     * @returns {boolean}\n     */\n    containsMosaics(): boolean;\n    /**\n     * all the Mosaic Identifiers of the attached mosaics\n     * @returns {MosaicId[]}\n     */\n    mosaicIds(): MosaicId[];\n    /**\n     * Create a TransferTransaction object\n     * @param timeWindow\n     * @param recipient\n     * @param xem\n     * @param message\n     * @returns {TransferTransaction}\n     */\n    static create(timeWindow: TimeWindow, recipient: Address, xem: XEM, message: PlainMessage | EncryptedMessage): TransferTransaction;\n    /**\n     * Create a TransferTransaction object\n     * @param timeWindow\n     * @param recipient\n     * @param mosaics\n     * @param message\n     * @returns {TransferTransaction}\n     */\n    static createWithMosaics(timeWindow: TimeWindow, recipient: Address, mosaics: MosaicTransferable[], message: PlainMessage | EncryptedMessage): TransferTransaction;\n}",
            "title": "TransferTransaction"
        },
        {
            "location": "/documentation/transaction/#message",
            "text": "/**\n * Message model\n */\nexport declare abstract class Message {\n\n    /**\n     * Message payload\n     */\n    readonly payload: string;\n\n}",
            "title": "Message"
        },
        {
            "location": "/documentation/transaction/#plainmessage",
            "text": "/**\n * Plain Message model\n */\nexport declare class PlainMessage extends Message {\n\n    /**\n     * Create new constructor\n     * @returns {boolean}\n     */\n    static create(message: string): PlainMessage;\n\n    /**\n     * Message string\n     * @returns {string}\n     */\n    plain(): string;\n\n}\nexport declare const EmptyMessage: PlainMessage;",
            "title": "PlainMessage"
        },
        {
            "location": "/documentation/transaction/#encryptedmessage",
            "text": "/**\n * Encrypted Message model\n */\nexport declare class EncryptedMessage extends Message {\n    readonly recipientPublicAccount?: PublicAccount;\n}",
            "title": "EncryptedMessage"
        },
        {
            "location": "/documentation/transaction/#importancetransfertransaction",
            "text": "export declare enum ImportanceMode {\n    Activate = 1,\n    Deactivate = 2,\n}\n\n/**\n * NIS has the ability to transfer the importance of one account to another account for harvesting.\n * The account receiving the importance is called the remote account.\n * Importance transfer transactions are part of the secure harvesting feature of NEM.\n * Once an importance transaction has been included in a block it needs 6 hours to become active.\n */\nexport declare class ImportanceTransferTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The public key of the receiving account as hexadecimal string.\n     */\n    readonly remoteAccount: PublicAccount;\n\n    /**\n     * The mode, activate or deactivate\n     */\n    readonly mode: ImportanceMode;\n\n    /**\n     * Create a ImportanceTransferTransaction object\n     * @param timeWindow\n     * @param mode\n     * @param remoteAccount\n     * @returns {ImportanceTransferTransaction}\n     */\n    static create(timeWindow: TimeWindow, mode: ImportanceMode, remoteAccount: PublicAccount): ImportanceTransferTransaction;\n}",
            "title": "ImportanceTransferTransaction"
        },
        {
            "location": "/documentation/transaction/#provisionnamespacetransaction",
            "text": "/**\n * Accounts can rent a namespace for one year and after a year renew the contract. This is done via a ProvisionNamespaceTransaction.\n */\nexport declare class ProvisionNamespaceTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The Address to which the rental fee is transferred.\n     */\n    readonly rentalFeeSink: Address;\n\n    /**\n     * The fee for renting the namespace.\n     */\n    readonly rentalFee: number;\n\n    /**\n     * The parent namespace. This can be undefined if the transaction rents a root namespace.\n     */\n    readonly parent?: string;\n\n    /**\n     * The new part which is concatenated to the parent with a '.' as separator.\n     */\n    readonly newPart: string;\n\n    /**\n     * Create a ProvisionNamespaceTransaction object\n     * @param timeWindow\n     * @param newPart\n     * @param parent\n     * @returns {ProvisionNamespaceTransaction}\n     */\n    static create(timeWindow: TimeWindow, newPart: string, parent?: string): ProvisionNamespaceTransaction;\n\n    /**\n   *\n   * @param {TimeWindow} timeWindow\n   * @param {string} namespaceName - Root namespace provision\n   * @returns {ProvisionNamespaceTransaction}\n   */\n  static createRoot(timeWindow: TimeWindow, namespaceName: string): ProvisionNamespaceTransaction;\n\n  /**\n   *\n   * @param {TimeWindow} timeWindow\n   * @param {string }parentNamespace\n   * @param {string} newNamespaceName\n   * @returns {ProvisionNamespaceTransaction}\n   */\n  static createSub(timeWindow: TimeWindow, parentNamespace: string, newNamespaceName: string): ProvisionNamespaceTransaction;\n}",
            "title": "ProvisionNamespaceTransaction"
        },
        {
            "location": "/documentation/transaction/#mosaicdefinitioncreationtransaction",
            "text": "/**\n * Before a mosaic can be created or transferred, a corresponding definition of the mosaic has to be created and published to the network.\n * This is done via a mosaic definition creation transaction.\n */\nexport declare class MosaicDefinitionCreationTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The fee for the creation of the mosaic.\n     */\n    readonly creationFee: number;\n\n    /**\n     * The public account to which the creation fee is tranferred.\n     */\n    readonly creationFeeSink: Address;\n\n    /**\n     * The actual mosaic definition.\n     */\n    readonly mosaicDefinition: MosaicDefinition;\n\n    /**\n     * Create a MosaicDefinitionCreationTransaction object\n     * @param timeWindow\n     * @param mosaicDefinition\n     * @returns {MosaicDefinitionCreationTransaction}\n     */\n    static create(timeWindow: TimeWindow, mosaicDefinition: MosaicDefinition): MosaicDefinitionCreationTransaction;\n}",
            "title": "MosaicDefinitionCreationTransaction"
        },
        {
            "location": "/documentation/transaction/#mosaicsupplychangetransaction",
            "text": "export declare enum MosaicSupplyType {\n    Increase = 1,\n    Decrease = 2,\n}\n\n/**\n * In case a mosaic definition has the property 'supplyMutable' set to true, the creator of the mosaic definition can change the supply, i.e. increase or decrease the supply.\n */\nexport declare class MosaicSupplyChangeTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The mosaic id.\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The supply type.\n     */\n    readonly supplyType: MosaicSupplyType;\n\n    /**\n     * The supply change in units for the mosaic.\n     */\n    readonly delta: number;\n\n    /**\n     * Create a MosaicSupplyChangeTransaction object\n     * @param timeWindow\n     * @param mosaicId\n     * @param supplyType\n     * @param delta\n     * @returns {MosaicSupplyChangeTransaction}\n     */\n    static create(timeWindow: TimeWindow, mosaicId: MosaicId, supplyType: MosaicSupplyType, delta: number): MosaicSupplyChangeTransaction;\n}",
            "title": "MosaicSupplyChangeTransaction"
        },
        {
            "location": "/documentation/transaction/#multisigtransaction",
            "text": "/**\n * Multisig transaction are the only way to make transaction from a multisig account to another account.\n * A multisig transaction carries another transaction inside (often referred to as \"inner\" transaction).\n * The inner transaction can be a transfer, an importance transfer or an aggregate modification transaction.\n * A multisig transaction also has multisig signature transactions from the cosignatories of the multisig account inside.\n */\nexport declare class MultisigTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction.\n     */\n    readonly fee: number;\n\n    /**\n     * The JSON array of MulsigSignatureTransaction objects.\n     */\n    readonly signatures: MultisigSignatureTransaction[];\n\n    /**\n     * The inner transaction. The inner transaction can be a transfer transaction, an importance transfer transaction or a multisig aggregate modification transaction.\n     * The inner transaction does not have a valid signature.\n     */\n    readonly otherTransaction: Transaction;\n\n    /**\n     * Hash data\n     */\n    readonly hashData?: HashData;\n\n    /**\n     * Check if transaction is pending to sign\n     * @returns {boolean}\n     */\n    isPendingToSign(): boolean;\n\n    /**\n     * Create a MultisigTransaction object\n     * @param timeWindow\n     * @param otherTrans\n     * @param multisig\n     * @returns {MultisigTransaction}\n     */\n    static create(timeWindow: TimeWindow, otherTrans: Transaction, multisig: PublicAccount): MultisigTransaction;\n}",
            "title": "MultisigTransaction"
        },
        {
            "location": "/documentation/transaction/#multisigaggregatemodificationtransaction",
            "text": "/**\n * Multisig aggregate modification transactions are part of the NEM's multisig account system.\n * A multisig aggregate modification transaction holds an array of multisig cosignatory modifications and a single multisig minimum cosignatories modification inside the transaction.\n * A multisig aggregate modification transaction can be wrapped by a multisig transaction.\n */\nexport declare class MultisigAggregateModificationTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    fee: number;\n\n    /**\n     * Value indicating the relative change of the minimum cosignatories.\n     */\n    readonly relativeChange?: number;\n\n    /**\n     * The JSON array of multisig modifications.\n     */\n    readonly modifications: CosignatoryModification[];\n\n    /**\n     * Create a MultisigAggregateModificationTransaction object\n     * @param timeWindow\n     * @param modifications\n     * @param relativeChange\n     * @returns {MultisigAggregateModificationTransaction}\n     */\n    static create(timeWindow: TimeWindow, modifications: CosignatoryModification[], relativeChange?: number): MultisigAggregateModificationTransaction;\n}\n\n/**\n * The type of modification. Possible values are:\n * 1: Add a new cosignatory.\n * 2: Delete an existing cosignatory.\n */\nexport declare enum CosignatoryModificationAction {\n    ADD = 1,\n    DELETE = 2,\n}\n\nexport declare class CosignatoryModification {\n    readonly cosignatoryAccount: PublicAccount;\n    readonly action: CosignatoryModificationAction;\n\n    /**\n     * constructor\n     * @param cosignatoryAccount\n     * @param action\n     */\n    constructor(cosignatoryAccount: PublicAccount, action: CosignatoryModificationAction);\n}",
            "title": "MultisigAggregateModificationTransaction"
        },
        {
            "location": "/documentation/transaction/#multisigsignaturetransaction",
            "text": "/**\n * Multisig signature transactions are part of the NEM's multisig account system. Multisig signature transactions are included in the corresponding multisig transaction and are the way a cosignatory of a multisig account can sign a multisig transaction for that account.\n */\nexport declare class MultisigSignatureTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The address of the corresponding multisig account.\n     */\n    readonly otherAccount: Address;\n\n    /**\n     * The hash of the inner transaction of the corresponding multisig transaction.\n     */\n    readonly otherHash: HashData;\n\n    /**\n     * Create a MultisigSignatureTransaction object\n     * @param timeWindow\n     * @param otherAccount\n     * @param otherHash\n     * @returns {MultisigSignatureTransaction}\n     */\n    static create(timeWindow: TimeWindow, otherAccount: Address, otherHash: HashData): MultisigSignatureTransaction;\n}",
            "title": "MultisigSignatureTransaction"
        },
        {
            "location": "/documentation/transaction/#signedtransaction",
            "text": "/**\n * SignedTransaction object is used to transfer the transaction data and the signature to NIS in order to initiate and broadcast a transaction.\n */\nexport interface SignedTransaction {\n\n    /**\n     * The transaction data as string.\n     */\n    readonly data: string;\n\n    /**\n     * The signature for the transaction as hexadecimal string.\n     */\n    readonly signature: string;\n}",
            "title": "SignedTransaction"
        },
        {
            "location": "/documentation/transaction/#nemannounceresult",
            "text": "export declare enum TypeNemAnnounceResult {\n    Validation = 1,\n    HeartBeat = 2,\n    Status = 4,\n}\n\nexport declare type CodeNemAnnounceResult = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19;\n\n/**\n * The NemAnnounceResult extends the NemRequestResult by supplying the additional fields 'transactionHash' and in case of a multisig transaction 'innerTransactionHash'.\n */\nexport declare class NemAnnounceResult {\n\n    /**\n     * The type is dependent on the request which was answered.\n     */\n    readonly type: TypeNemAnnounceResult;\n\n    /**\n     * The meaning of the code is dependent on the type.\n     */\n    readonly code: CodeNemAnnounceResult;\n\n    /**\n     * Error or success message\n     */\n    readonly message: string;\n\n    /**\n     * The JSON hash object of the transaction.\n     */\n    readonly transactionHash: HashData;\n\n    /**\n     * The JSON hash object of the inner transaction or null if the transaction is not a multisig transaction.\n     */\n    readonly innerTransactionHash: HashData;\n}",
            "title": "NemAnnounceResult"
        },
        {
            "location": "/documentation/namespace/",
            "text": "Namespace related requests\n\n\nNEM supports the concept of namespaces which is the NEM analog of internet domain names. A namespace is an identification string that consists of one or more parts that are concatenated by dots, for example 'makoto.metals.silver'. All namespaces are unique and thus can only have one owner at a time. A namespace that has only one part is called a root namespace, otherwise sub-namespace. Root namespaces can be rented by accounts for the duration of one year. One month before the root namespace expires the rental contract can be renewed for another year. If a root namespace rental contract is renewed, all sub-namespaces are valid for another year as well. If the root namespace is not renewed, it exires together with all sub-namespaces. One month after a root namespace expires, another account is able to rent that root namespace. The new owner does not inherit the sub-namespaces from the previous owner however. An account can only rent a sub-namespace if it owns the corresponding root namespace.\n\n\nNamespaces have certain restrictions with respected to the characters being allowed in the parts as well as the length of a part. A root namespace may have a length of 16 characters while sub-namespaces may have a length of 64 characters.\n\n\nOfficial Source\n\n\nNamespaceHttp definition\n\n\nexport declare class NamespaceHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Gets the root namespaces. The requests supports paging, i.e. retrieving the root namespaces in batches of a specified size.\n     * @param id - The topmost namespace database id up to which root namespaces are returned. The parameter is optional. If not supplied the most recent rented root namespaces are returned.\n     * @param pageSize - (Optional) The number of namespace objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100.\n     * @returns Observable<Namespace[]>\n     */\n    getRootNamespaces(id: number, pageSize?: string): Observable<Namespace[]>;\n\n    /**\n     * Gets the namespace with given id.\n     * @param namespace - The namespace id.\n     * @returns Observable<Namespace>\n     */\n    getNamespace(namespace: string): Observable<Namespace>;\n}\n\n\n\n\n\nNamespaceHttp usage\n\n\nimport {NamespaceHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp();\nconst id = 12344;\n\nnamespaceHttp.getRootNamespaces(id).subscribe(namespaces => {\n    console.log(namespaces);\n});\n\n\n\n\nOutput\n\n\n[ Namespace {\n    name: 'ajkshgkerhkjerg',\n    owner:\n     Address {\n       value: 'TDQJM2LZPKM4WRI44CF5TEUHRES5JCWQ3YRKGKUB',\n       networkType: 152 },\n    height: 1034366,\n    id: 409 },\n  Namespace {\n    name: 'hitori',\n    owner:\n     Address {\n       value: 'TCIY4MHDHZJ42NGHQ67PJXSWHLFACNMJLSM56VE3',\n       networkType: 152 },\n    height: 1033761,\n    id: 408 },\n  Namespace {\n    name: 'vandelay',\n    owner:\n     Address {\n       value: 'TAB5AEUDM3ALLDRLRLNMQYQXJXJZUSMDSEN5TND5',\n       networkType: 152 },\n    height: 1032986,\n    id: 405 },\n  Namespace {\n    name: 'girish',\n    owner:\n     Address {\n       value: 'TAFHY34ZKCJIYI6LPEJXVOCMVK5QHQXJ5AAPO5RG',\n       networkType: 152 },\n    height: 1031091,\n    id: 403 },\n  Namespace {\n    name: 'multisigns',\n    owner:\n     Address {\n       value: 'TDAEIWWYWZRE3VSUHXG77L5TW22BHNGV5FAPH2XJ',\n       networkType: 152 },\n    height: 1029552,\n    id: 402 },\n  Namespace {\n    name: 'foobarltd',\n    owner:\n     Address {\n       value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH',\n       networkType: 152 },\n    height: 1029471,\n    id: 401 },\n  Namespace {\n    name: 'jabo',\n    owner:\n     Address {\n       value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH',\n       networkType: 152 },\n    height: 1029471,\n    id: 400 },\n  Namespace {\n    name: 'newpart',\n    owner:\n     Address {\n       value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA',\n       networkType: 152 },\n    height: 1028225,\n    id: 399 },\n  Namespace {\n    name: 'govegan',\n    owner:\n     Address {\n       value: 'TBXWZW35ZJDHLXYDQ6EQTWKHJSWQG2EQYWDRKXXU',\n       networkType: 152 },\n    height: 1027004,\n    id: 398 },\n  Namespace {\n    name: 'tescik11',\n    owner:\n     Address {\n       value: 'TCWHXK5EI3RJIUV5DXURIIEASECB57L4N5EEGI24',\n       networkType: 152 },\n    height: 1026918,\n    id: 397 },\n  Namespace {\n    name: 'fintech',\n    owner:\n     Address {\n       value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT',\n       networkType: 152 },\n    height: 1026764,\n    id: 396 },\n  Namespace {\n    name: 'kung',\n    owner:\n     Address {\n       value: 'TAU5HO3DRQZNELFEMZZTUKQEZGQ7IUAHKPO7OOLK',\n       networkType: 152 },\n    height: 1025402,\n    id: 395 },\n  Namespace {\n    name: 'dim',\n    owner:\n     Address {\n       value: 'TDXTBQUI5PCPHBZKTHBSLMCJGKDWV3RVHHOCPX2V',\n       networkType: 152 },\n    height: 1022794,\n    id: 393 },\n  Namespace {\n    name: 'multisig',\n    owner:\n     Address {\n       value: 'TAVBSWJV3XNA7MRVEH3XQQYRTJGXM3VRKCQDKHR7',\n       networkType: 152 },\n    height: 1021094,\n    id: 392 },\n  Namespace {\n    name: 'jeffmcdonald',\n    owner:\n     Address {\n       value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344',\n       networkType: 152 },\n    height: 1019783,\n    id: 391 },\n  Namespace {\n    name: 'lonwon',\n    owner:\n     Address {\n       value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344',\n       networkType: 152 },\n    height: 1019768,\n    id: 390 },\n  Namespace {\n    name: 'bok_tor',\n    owner:\n     Address {\n       value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT',\n       networkType: 152 },\n    height: 1018248,\n    id: 389 },\n  Namespace {\n    name: 'macy',\n    owner:\n     Address {\n       value: 'TCF2JGBTB7LM6Y3VP22DSSFRUGDYZYVQMUGDX4TL',\n       networkType: 152 },\n    height: 1018245,\n    id: 388 },\n  Namespace {\n    name: 'foo',\n    owner:\n     Address {\n       value: 'TAOMBDIWECBSP7QGEKGUE476QOCRRN6MEOSQQ4RP',\n       networkType: 152 },\n    height: 1017249,\n    id: 387 },\n  Namespace {\n    name: 'namespace_root1',\n    owner:\n     Address {\n       value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK',\n       networkType: 152 },\n    height: 1017028,\n    id: 385 },\n  Namespace {\n    name: 'root_namespace1',\n    owner:\n     Address {\n       value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK',\n       networkType: 152 },\n    height: 1017028,\n    id: 384 },\n  Namespace {\n    name: 'rivalkingdoms',\n    owner:\n     Address {\n       value: 'TCBAR5KG4HHTF3EBBCQETVYUJVONF7XKWSYCI2CA',\n       networkType: 152 },\n    height: 1016967,\n    id: 382 },\n  Namespace {\n    name: 'szpregel',\n    owner:\n     Address {\n       value: 'TDFPX267BPLVUB2VF3OY2LSACGSF4XWLVPUXY3FC',\n       networkType: 152 },\n    height: 1016780,\n    id: 381 },\n  Namespace {\n    name: 'marvel',\n    owner:\n     Address {\n       value: 'TDSPQOUYI6VBGD2SAERJ73ZYMNY5ACJSYNTZSUHP',\n       networkType: 152 },\n    height: 1016477,\n    id: 379 },\n  Namespace {\n    name: 'test',\n    owner:\n     Address {\n       value: 'TADEADUYY4FE5JSHL22VNASNYXYXEJVZ7BF2E3IO',\n       networkType: 152 },\n    height: 1015685,\n    id: 378 } ]\n\n\n\n\nRun the code\n\n\nModels\n\n\nNamespace\n\n\n/**\n * A namespace is the NEM version of a domain. You can rent a namespace for the duration of a year by paying a fee.\n * The naming of the parts of a namespace has certain restrictions, see the corresponding chapter on namespaces.\n */\nexport declare class Namespace {\n    /**\n     * The fully qualified name of the namespace, also named namespace id.\n     */\n    readonly name: string;\n\n    /**\n     * The owner of the namespace.\n     */\n    readonly owner: Address;\n\n    /**\n     * The height at which the ownership begins.\n     */\n    readonly height: number;\n\n    /**\n     * The database id for the namespace object.\n     */\n    readonly id?: number;\n\n}",
            "title": "Namespace"
        },
        {
            "location": "/documentation/namespace/#namespace-related-requests",
            "text": "NEM supports the concept of namespaces which is the NEM analog of internet domain names. A namespace is an identification string that consists of one or more parts that are concatenated by dots, for example 'makoto.metals.silver'. All namespaces are unique and thus can only have one owner at a time. A namespace that has only one part is called a root namespace, otherwise sub-namespace. Root namespaces can be rented by accounts for the duration of one year. One month before the root namespace expires the rental contract can be renewed for another year. If a root namespace rental contract is renewed, all sub-namespaces are valid for another year as well. If the root namespace is not renewed, it exires together with all sub-namespaces. One month after a root namespace expires, another account is able to rent that root namespace. The new owner does not inherit the sub-namespaces from the previous owner however. An account can only rent a sub-namespace if it owns the corresponding root namespace.  Namespaces have certain restrictions with respected to the characters being allowed in the parts as well as the length of a part. A root namespace may have a length of 16 characters while sub-namespaces may have a length of 64 characters.  Official Source",
            "title": "Namespace related requests"
        },
        {
            "location": "/documentation/namespace/#namespacehttp-definition",
            "text": "export declare class NamespaceHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Gets the root namespaces. The requests supports paging, i.e. retrieving the root namespaces in batches of a specified size.\n     * @param id - The topmost namespace database id up to which root namespaces are returned. The parameter is optional. If not supplied the most recent rented root namespaces are returned.\n     * @param pageSize - (Optional) The number of namespace objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100.\n     * @returns Observable<Namespace[]>\n     */\n    getRootNamespaces(id: number, pageSize?: string): Observable<Namespace[]>;\n\n    /**\n     * Gets the namespace with given id.\n     * @param namespace - The namespace id.\n     * @returns Observable<Namespace>\n     */\n    getNamespace(namespace: string): Observable<Namespace>;\n}",
            "title": "NamespaceHttp definition"
        },
        {
            "location": "/documentation/namespace/#namespacehttp-usage",
            "text": "import {NamespaceHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp();\nconst id = 12344;\n\nnamespaceHttp.getRootNamespaces(id).subscribe(namespaces => {\n    console.log(namespaces);\n});  Output  [ Namespace {\n    name: 'ajkshgkerhkjerg',\n    owner:\n     Address {\n       value: 'TDQJM2LZPKM4WRI44CF5TEUHRES5JCWQ3YRKGKUB',\n       networkType: 152 },\n    height: 1034366,\n    id: 409 },\n  Namespace {\n    name: 'hitori',\n    owner:\n     Address {\n       value: 'TCIY4MHDHZJ42NGHQ67PJXSWHLFACNMJLSM56VE3',\n       networkType: 152 },\n    height: 1033761,\n    id: 408 },\n  Namespace {\n    name: 'vandelay',\n    owner:\n     Address {\n       value: 'TAB5AEUDM3ALLDRLRLNMQYQXJXJZUSMDSEN5TND5',\n       networkType: 152 },\n    height: 1032986,\n    id: 405 },\n  Namespace {\n    name: 'girish',\n    owner:\n     Address {\n       value: 'TAFHY34ZKCJIYI6LPEJXVOCMVK5QHQXJ5AAPO5RG',\n       networkType: 152 },\n    height: 1031091,\n    id: 403 },\n  Namespace {\n    name: 'multisigns',\n    owner:\n     Address {\n       value: 'TDAEIWWYWZRE3VSUHXG77L5TW22BHNGV5FAPH2XJ',\n       networkType: 152 },\n    height: 1029552,\n    id: 402 },\n  Namespace {\n    name: 'foobarltd',\n    owner:\n     Address {\n       value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH',\n       networkType: 152 },\n    height: 1029471,\n    id: 401 },\n  Namespace {\n    name: 'jabo',\n    owner:\n     Address {\n       value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH',\n       networkType: 152 },\n    height: 1029471,\n    id: 400 },\n  Namespace {\n    name: 'newpart',\n    owner:\n     Address {\n       value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA',\n       networkType: 152 },\n    height: 1028225,\n    id: 399 },\n  Namespace {\n    name: 'govegan',\n    owner:\n     Address {\n       value: 'TBXWZW35ZJDHLXYDQ6EQTWKHJSWQG2EQYWDRKXXU',\n       networkType: 152 },\n    height: 1027004,\n    id: 398 },\n  Namespace {\n    name: 'tescik11',\n    owner:\n     Address {\n       value: 'TCWHXK5EI3RJIUV5DXURIIEASECB57L4N5EEGI24',\n       networkType: 152 },\n    height: 1026918,\n    id: 397 },\n  Namespace {\n    name: 'fintech',\n    owner:\n     Address {\n       value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT',\n       networkType: 152 },\n    height: 1026764,\n    id: 396 },\n  Namespace {\n    name: 'kung',\n    owner:\n     Address {\n       value: 'TAU5HO3DRQZNELFEMZZTUKQEZGQ7IUAHKPO7OOLK',\n       networkType: 152 },\n    height: 1025402,\n    id: 395 },\n  Namespace {\n    name: 'dim',\n    owner:\n     Address {\n       value: 'TDXTBQUI5PCPHBZKTHBSLMCJGKDWV3RVHHOCPX2V',\n       networkType: 152 },\n    height: 1022794,\n    id: 393 },\n  Namespace {\n    name: 'multisig',\n    owner:\n     Address {\n       value: 'TAVBSWJV3XNA7MRVEH3XQQYRTJGXM3VRKCQDKHR7',\n       networkType: 152 },\n    height: 1021094,\n    id: 392 },\n  Namespace {\n    name: 'jeffmcdonald',\n    owner:\n     Address {\n       value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344',\n       networkType: 152 },\n    height: 1019783,\n    id: 391 },\n  Namespace {\n    name: 'lonwon',\n    owner:\n     Address {\n       value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344',\n       networkType: 152 },\n    height: 1019768,\n    id: 390 },\n  Namespace {\n    name: 'bok_tor',\n    owner:\n     Address {\n       value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT',\n       networkType: 152 },\n    height: 1018248,\n    id: 389 },\n  Namespace {\n    name: 'macy',\n    owner:\n     Address {\n       value: 'TCF2JGBTB7LM6Y3VP22DSSFRUGDYZYVQMUGDX4TL',\n       networkType: 152 },\n    height: 1018245,\n    id: 388 },\n  Namespace {\n    name: 'foo',\n    owner:\n     Address {\n       value: 'TAOMBDIWECBSP7QGEKGUE476QOCRRN6MEOSQQ4RP',\n       networkType: 152 },\n    height: 1017249,\n    id: 387 },\n  Namespace {\n    name: 'namespace_root1',\n    owner:\n     Address {\n       value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK',\n       networkType: 152 },\n    height: 1017028,\n    id: 385 },\n  Namespace {\n    name: 'root_namespace1',\n    owner:\n     Address {\n       value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK',\n       networkType: 152 },\n    height: 1017028,\n    id: 384 },\n  Namespace {\n    name: 'rivalkingdoms',\n    owner:\n     Address {\n       value: 'TCBAR5KG4HHTF3EBBCQETVYUJVONF7XKWSYCI2CA',\n       networkType: 152 },\n    height: 1016967,\n    id: 382 },\n  Namespace {\n    name: 'szpregel',\n    owner:\n     Address {\n       value: 'TDFPX267BPLVUB2VF3OY2LSACGSF4XWLVPUXY3FC',\n       networkType: 152 },\n    height: 1016780,\n    id: 381 },\n  Namespace {\n    name: 'marvel',\n    owner:\n     Address {\n       value: 'TDSPQOUYI6VBGD2SAERJ73ZYMNY5ACJSYNTZSUHP',\n       networkType: 152 },\n    height: 1016477,\n    id: 379 },\n  Namespace {\n    name: 'test',\n    owner:\n     Address {\n       value: 'TADEADUYY4FE5JSHL22VNASNYXYXEJVZ7BF2E3IO',\n       networkType: 152 },\n    height: 1015685,\n    id: 378 } ]  Run the code",
            "title": "NamespaceHttp usage"
        },
        {
            "location": "/documentation/namespace/#models",
            "text": "",
            "title": "Models"
        },
        {
            "location": "/documentation/namespace/#namespace",
            "text": "/**\n * A namespace is the NEM version of a domain. You can rent a namespace for the duration of a year by paying a fee.\n * The naming of the parts of a namespace has certain restrictions, see the corresponding chapter on namespaces.\n */\nexport declare class Namespace {\n    /**\n     * The fully qualified name of the namespace, also named namespace id.\n     */\n    readonly name: string;\n\n    /**\n     * The owner of the namespace.\n     */\n    readonly owner: Address;\n\n    /**\n     * The height at which the ownership begins.\n     */\n    readonly height: number;\n\n    /**\n     * The database id for the namespace object.\n     */\n    readonly id?: number;\n\n}",
            "title": "Namespace"
        },
        {
            "location": "/documentation/mosaic/",
            "text": "Mosaic related requests\n\n\nNEM mosaics are assets that expose additional properties and other features. Each mosaic has an underlying mosaic definition. To be able to create a mosaic definition, an account must rent at least one root namespace which the mosaic definition can then refer to.\n\n\nOfficial Source\n\n\nMosaicHttp definition\n\n\nexport declare class MosaicHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Gets the mosaic definitions for a given namespace. The request supports paging.\n     * @param namespace\n     * @param id - The topmost mosaic definition database id up to which root mosaic definitions are returned. The parameter is optional. If not supplied the most recent mosaic definitiona are returned.\n     * @param pageSize - The number of mosaic definition objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100.\n     * @returns Observable<MosaicDefinition[]>\n     */\n    getAllMosaicsGivenNamespace(namespace: string, id?: number, pageSize?: number): Observable<MosaicDefinition[]>;\n\n    /**\n     * Return the Mosaic Definition given a namespace and mosaic. Throw exception if no mosaic is found\n     * @param {string} mosaicId\n     * @returns {Observable<MosaicDefinition>}\n     */\n    getMosaicDefinition(mosaicId: MosaicId): Observable<MosaicDefinition>;\n\n    /**\n     * Return a MosaicTransferable with the amount\n     * @param {string} mosaicId\n     * @param {number} amount\n     * @returns {Observable<MosaicTransferable>}\n     */\n    getMosaicTransferableWithAmount(mosaicId: MosaicId, amount: number): Observable<MosaicTransferable>;\n}\n\n\n\n\n\nMosaicHttp usage\n\n\nimport {MosaicHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst mosaicHttp = new MosaicHttp();\nconst namespace = \"server\";\n\nmosaicHttp.getAllMosaicsGivenNamespace(namespace).subscribe(mosaicDefinitions => {\n    console.log(mosaicDefinitions);\n});\n\n\n\n\nOutput\n\n\n[ MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'testmosaic' },\n    description: 'descritpio',\n    properties:\n     MosaicProperties {\n       initialSupply: 1000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: undefined,\n    metaId: 447 },\n  MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'alcapone' },\n    description: 'the one and only al capone',\n    properties:\n     MosaicProperties {\n       initialSupply: 10000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 385 },\n  MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' },\n    description: 'description',\n    properties:\n     MosaicProperties {\n       initialSupply: 100000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 384 } ]\n\n\n\n\nRun the code\n\n\nModels\n\n\nMosaicId\n\n\n/**\n * A mosaic id uniquely identifies an underlying mosaic definition.\n */\nexport declare class MosaicId {\n    /**\n     * The corresponding namespace id\n     */\n    readonly namespaceId: string;\n    /**\n     * The name of the mosaic definition.\n     */\n    readonly name: string;\n    /**\n     * constructor\n     * @param namespaceId\n     * @param name\n     */\n    constructor(namespaceId: string, name: string);\n    /**\n     * Compares mosaicIds for equality\n     * @param mosaicId\n     * @returns {boolean}\n     */\n    equals(mosaicId: MosaicId): boolean;\n    /**\n     * Mosaic Id description in format namespaceId:name ex: nem:xem\n     */\n    description(): string;\n}\n\n\n\n\n\n\nMosaic\n\n\n/**\n * A mosaic describes an instance of a mosaic definition. Mosaics can be transferred by means of a transfer transaction.\n */\nexport declare class Mosaic {\n\n    /**\n     * The mosaic id\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The mosaic quantity. The quantity is always given in smallest units for the mosaic, i.e. if it has a divisibility of 3 the quantity is given in millis.\n     */\n    readonly quantity: number;\n\n    /**\n     * constructor\n     * @param mosaicId\n     * @param quantity\n     */\n    constructor(mosaicId: MosaicId, quantity: number);\n}\n\n\n\n\n\nMosaicDefinition\n\n\n\n/**\n * A mosaic definition describes an asset class. Some fields are mandatory while others are optional.\n * The properties of a mosaic definition always have a default value and only need to be supplied if they differ from the default value.\n */\nexport declare class MosaicDefinition {\n\n    /**\n     *  The public key of the mosaic definition creator.\n     */\n    readonly creator: PublicAccount;\n\n    /**\n     * The mosaic id\n     */\n    readonly id: MosaicId;\n\n    /**\n     * The mosaic description. The description may have a length of up to 512 characters and cannot be empty.\n     */\n    readonly description: string;\n\n    /**\n    * Mosaic properties \n    */\n    readonly properties: MosaicProperties;\n\n    /**\n     * The optional levy for the mosaic. A creator can demand that each mosaic transfer induces an additional fee\n     */\n    readonly levy?: MosaicLevy;\n\n    /**\n     * The id for the mosaic definition object.\n     */\n    readonly metaId?: number;\n\n    /**\n     * constructor\n     * @param creator\n     * @param id\n     * @param description\n     * @param properties\n     * @param levy\n     * @param metaId\n     */\n    constructor(creator: PublicAccount, id: MosaicId, description: string, properties: MosaicProperties, levy?: MosaicLevy, metaId?: number);\n}\n\n/**\n * Each mosaic definition comes with a set of properties.\n * Each property has a default value which will be applied in case it was not specified.\n * Future release may add additional properties to the set of available properties\n */\nexport declare class MosaicProperties {\n\n    /**\n     * initialSupply: The creator can specify an initial supply of mosaics when creating the definition.\n     * The supply is given in entire units of the mosaic, not in smallest sub-units.\n     * The initial supply must be in the range of 0 and 9,000,000,000. The default value is \"1000\".\n     */\n    readonly initialSupply: number;\n\n    /**\n     * The creator can choose between a definition that allows a mosaic supply change at a later point or an immutable supply.\n     * Allowed values for the property are \"true\" and \"false\". The default value is \"false\".\n     */\n    readonly supplyMutable: boolean;\n\n    /**\n     * The creator can choose if the mosaic definition should allow for transfers of the mosaic among accounts other than the creator.\n     * If the property 'transferable' is set to \"false\", only transfer transactions having the creator as sender or as recipient can transfer mosaics of that type.\n     * If set to \"true\" the mosaics can be transferred to and from arbitrary accounts.\n     * Allowed values for the property are thus \"true\" and \"false\". The default value is \"true\".\n     */\n    readonly transferable: boolean;\n\n    /**\n     * The divisibility determines up to what decimal place the mosaic can be divided into.\n     * Thus a divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics, i.e. milli mosaics is the smallest sub-unit.\n     * When transferring mosaics via a transfer transaction the quantity transferred is given in multiples of those smallest parts.\n     * The divisibility must be in the range of 0 and 6. The default value is \"0\".\n     */\n    readonly divisibility: number;\n\n    /**\n     * constructor\n     * @param divisibility\n     * @param initialSupply\n     * @param supplyMutable\n     * @param transferable\n     */\n    constructor(divisibility?: number, initialSupply?: number, transferable?: boolean, supplyMutable?: boolean);\n}\n\n\n\n\nMosaicLevy\n\n\n\nexport declare enum MosaicLevyType {\n    Absolute = 1,\n    Percentil = 2,\n}\n\n/**\n * A mosaic definition can optionally specify a levy for transferring those mosaics. This might be needed by legal entities needing to collect some taxes for transfers.\n */\nexport declare class MosaicLevy {\n\n    /**\n     *  The levy type\n     */\n    readonly type: MosaicLevyType;\n\n    /**\n     * The recipient of the levy.\n     */\n    readonly recipient: Address;\n\n    /**\n     * The mosaic in which the levy is paid.\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The fee. The interpretation is dependent on the type of the levy\n     */\n    readonly fee: number;\n\n    /**\n     * constructor\n     * @param type\n     * @param recipient\n     * @param mosaicId\n     * @param fee\n     */\n    constructor(type: MosaicLevyType, recipient: Address, mosaicId: MosaicId, fee: number);\n}\n\n\n\n\nMosaicTransferable\n\n\n\n/**\n * Mosaic transferable model\n */\nexport declare class MosaicTransferable {\n\n    /**\n     * Quantity to be send\n     */\n    readonly quantity: number;\n\n    /**\n     * Mosaic definition properties\n     */\n    readonly properties: MosaicProperties;\n\n    /**\n     * Mosaic id\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * Levy\n     */\n    readonly levy?: MosaicLevy;\n\n    /**\n     * constructor\n     * @param mosaicId\n     * @param properties\n     * @param amount\n     * @param levy\n     */\n    constructor(mosaicId: MosaicId, properties: MosaicProperties, amount: number, levy?: MosaicLevy);\n\n    /**\n     * Create a MosaicTransferable object with mosaic definition\n     * @param mosaicDefinition\n     * @param quantity\n     * @returns {MosaicTransferable}\n     */\n    static createWithMosaicDefinition(mosaicDefinition: MosaicDefinition, quantity: number): MosaicTransferable;\n}\n\n\n\n\nXEM\n\n\n/**\n * XEM mosaic transferable\n */\nexport declare class XEM extends MosaicTransferable {\n    /**\n     * Divisiblity\n     * @type {number}\n     */\n    static DIVISIBILITY: number;\n    /**\n     * Initial supply\n     * @type {number}\n     */\n    static INITIALSUPPLY: number;\n    /**\n     * Is tranferable\n     * @type {boolean}\n     */\n    static TRANSFERABLE: boolean;\n    /**\n     * Is mutable\n     * @type {boolean}\n     */\n    static SUPPLYMUTABLE: boolean;\n    /**\n     * mosaicId\n     * @type {MosaicId}\n     */\n    static MOSAICID: MosaicId;\n    /**\n    * constructor\n    * @param amount\n    */\n    constructor(amount: number) {\n        super(new MosaicId(\"nem\", \"xem\"), new MosaicProperties(6, 8999999999, true, false), amount);\n    }\n}",
            "title": "Mosaic"
        },
        {
            "location": "/documentation/mosaic/#mosaic-related-requests",
            "text": "NEM mosaics are assets that expose additional properties and other features. Each mosaic has an underlying mosaic definition. To be able to create a mosaic definition, an account must rent at least one root namespace which the mosaic definition can then refer to.  Official Source",
            "title": "Mosaic related requests"
        },
        {
            "location": "/documentation/mosaic/#mosaichttp-definition",
            "text": "export declare class MosaicHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Gets the mosaic definitions for a given namespace. The request supports paging.\n     * @param namespace\n     * @param id - The topmost mosaic definition database id up to which root mosaic definitions are returned. The parameter is optional. If not supplied the most recent mosaic definitiona are returned.\n     * @param pageSize - The number of mosaic definition objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100.\n     * @returns Observable<MosaicDefinition[]>\n     */\n    getAllMosaicsGivenNamespace(namespace: string, id?: number, pageSize?: number): Observable<MosaicDefinition[]>;\n\n    /**\n     * Return the Mosaic Definition given a namespace and mosaic. Throw exception if no mosaic is found\n     * @param {string} mosaicId\n     * @returns {Observable<MosaicDefinition>}\n     */\n    getMosaicDefinition(mosaicId: MosaicId): Observable<MosaicDefinition>;\n\n    /**\n     * Return a MosaicTransferable with the amount\n     * @param {string} mosaicId\n     * @param {number} amount\n     * @returns {Observable<MosaicTransferable>}\n     */\n    getMosaicTransferableWithAmount(mosaicId: MosaicId, amount: number): Observable<MosaicTransferable>;\n}",
            "title": "MosaicHttp definition"
        },
        {
            "location": "/documentation/mosaic/#mosaichttp-usage",
            "text": "import {MosaicHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst mosaicHttp = new MosaicHttp();\nconst namespace = \"server\";\n\nmosaicHttp.getAllMosaicsGivenNamespace(namespace).subscribe(mosaicDefinitions => {\n    console.log(mosaicDefinitions);\n});  Output  [ MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'testmosaic' },\n    description: 'descritpio',\n    properties:\n     MosaicProperties {\n       initialSupply: 1000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: undefined,\n    metaId: 447 },\n  MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'alcapone' },\n    description: 'the one and only al capone',\n    properties:\n     MosaicProperties {\n       initialSupply: 10000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 385 },\n  MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' },\n    description: 'description',\n    properties:\n     MosaicProperties {\n       initialSupply: 100000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 384 } ]  Run the code",
            "title": "MosaicHttp usage"
        },
        {
            "location": "/documentation/mosaic/#models",
            "text": "",
            "title": "Models"
        },
        {
            "location": "/documentation/mosaic/#mosaicid",
            "text": "/**\n * A mosaic id uniquely identifies an underlying mosaic definition.\n */\nexport declare class MosaicId {\n    /**\n     * The corresponding namespace id\n     */\n    readonly namespaceId: string;\n    /**\n     * The name of the mosaic definition.\n     */\n    readonly name: string;\n    /**\n     * constructor\n     * @param namespaceId\n     * @param name\n     */\n    constructor(namespaceId: string, name: string);\n    /**\n     * Compares mosaicIds for equality\n     * @param mosaicId\n     * @returns {boolean}\n     */\n    equals(mosaicId: MosaicId): boolean;\n    /**\n     * Mosaic Id description in format namespaceId:name ex: nem:xem\n     */\n    description(): string;\n}",
            "title": "MosaicId"
        },
        {
            "location": "/documentation/mosaic/#mosaic",
            "text": "/**\n * A mosaic describes an instance of a mosaic definition. Mosaics can be transferred by means of a transfer transaction.\n */\nexport declare class Mosaic {\n\n    /**\n     * The mosaic id\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The mosaic quantity. The quantity is always given in smallest units for the mosaic, i.e. if it has a divisibility of 3 the quantity is given in millis.\n     */\n    readonly quantity: number;\n\n    /**\n     * constructor\n     * @param mosaicId\n     * @param quantity\n     */\n    constructor(mosaicId: MosaicId, quantity: number);\n}",
            "title": "Mosaic"
        },
        {
            "location": "/documentation/mosaic/#mosaicdefinition",
            "text": "/**\n * A mosaic definition describes an asset class. Some fields are mandatory while others are optional.\n * The properties of a mosaic definition always have a default value and only need to be supplied if they differ from the default value.\n */\nexport declare class MosaicDefinition {\n\n    /**\n     *  The public key of the mosaic definition creator.\n     */\n    readonly creator: PublicAccount;\n\n    /**\n     * The mosaic id\n     */\n    readonly id: MosaicId;\n\n    /**\n     * The mosaic description. The description may have a length of up to 512 characters and cannot be empty.\n     */\n    readonly description: string;\n\n    /**\n    * Mosaic properties \n    */\n    readonly properties: MosaicProperties;\n\n    /**\n     * The optional levy for the mosaic. A creator can demand that each mosaic transfer induces an additional fee\n     */\n    readonly levy?: MosaicLevy;\n\n    /**\n     * The id for the mosaic definition object.\n     */\n    readonly metaId?: number;\n\n    /**\n     * constructor\n     * @param creator\n     * @param id\n     * @param description\n     * @param properties\n     * @param levy\n     * @param metaId\n     */\n    constructor(creator: PublicAccount, id: MosaicId, description: string, properties: MosaicProperties, levy?: MosaicLevy, metaId?: number);\n}\n\n/**\n * Each mosaic definition comes with a set of properties.\n * Each property has a default value which will be applied in case it was not specified.\n * Future release may add additional properties to the set of available properties\n */\nexport declare class MosaicProperties {\n\n    /**\n     * initialSupply: The creator can specify an initial supply of mosaics when creating the definition.\n     * The supply is given in entire units of the mosaic, not in smallest sub-units.\n     * The initial supply must be in the range of 0 and 9,000,000,000. The default value is \"1000\".\n     */\n    readonly initialSupply: number;\n\n    /**\n     * The creator can choose between a definition that allows a mosaic supply change at a later point or an immutable supply.\n     * Allowed values for the property are \"true\" and \"false\". The default value is \"false\".\n     */\n    readonly supplyMutable: boolean;\n\n    /**\n     * The creator can choose if the mosaic definition should allow for transfers of the mosaic among accounts other than the creator.\n     * If the property 'transferable' is set to \"false\", only transfer transactions having the creator as sender or as recipient can transfer mosaics of that type.\n     * If set to \"true\" the mosaics can be transferred to and from arbitrary accounts.\n     * Allowed values for the property are thus \"true\" and \"false\". The default value is \"true\".\n     */\n    readonly transferable: boolean;\n\n    /**\n     * The divisibility determines up to what decimal place the mosaic can be divided into.\n     * Thus a divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics, i.e. milli mosaics is the smallest sub-unit.\n     * When transferring mosaics via a transfer transaction the quantity transferred is given in multiples of those smallest parts.\n     * The divisibility must be in the range of 0 and 6. The default value is \"0\".\n     */\n    readonly divisibility: number;\n\n    /**\n     * constructor\n     * @param divisibility\n     * @param initialSupply\n     * @param supplyMutable\n     * @param transferable\n     */\n    constructor(divisibility?: number, initialSupply?: number, transferable?: boolean, supplyMutable?: boolean);\n}",
            "title": "MosaicDefinition"
        },
        {
            "location": "/documentation/mosaic/#mosaiclevy",
            "text": "export declare enum MosaicLevyType {\n    Absolute = 1,\n    Percentil = 2,\n}\n\n/**\n * A mosaic definition can optionally specify a levy for transferring those mosaics. This might be needed by legal entities needing to collect some taxes for transfers.\n */\nexport declare class MosaicLevy {\n\n    /**\n     *  The levy type\n     */\n    readonly type: MosaicLevyType;\n\n    /**\n     * The recipient of the levy.\n     */\n    readonly recipient: Address;\n\n    /**\n     * The mosaic in which the levy is paid.\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The fee. The interpretation is dependent on the type of the levy\n     */\n    readonly fee: number;\n\n    /**\n     * constructor\n     * @param type\n     * @param recipient\n     * @param mosaicId\n     * @param fee\n     */\n    constructor(type: MosaicLevyType, recipient: Address, mosaicId: MosaicId, fee: number);\n}",
            "title": "MosaicLevy"
        },
        {
            "location": "/documentation/mosaic/#mosaictransferable",
            "text": "/**\n * Mosaic transferable model\n */\nexport declare class MosaicTransferable {\n\n    /**\n     * Quantity to be send\n     */\n    readonly quantity: number;\n\n    /**\n     * Mosaic definition properties\n     */\n    readonly properties: MosaicProperties;\n\n    /**\n     * Mosaic id\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * Levy\n     */\n    readonly levy?: MosaicLevy;\n\n    /**\n     * constructor\n     * @param mosaicId\n     * @param properties\n     * @param amount\n     * @param levy\n     */\n    constructor(mosaicId: MosaicId, properties: MosaicProperties, amount: number, levy?: MosaicLevy);\n\n    /**\n     * Create a MosaicTransferable object with mosaic definition\n     * @param mosaicDefinition\n     * @param quantity\n     * @returns {MosaicTransferable}\n     */\n    static createWithMosaicDefinition(mosaicDefinition: MosaicDefinition, quantity: number): MosaicTransferable;\n}",
            "title": "MosaicTransferable"
        },
        {
            "location": "/documentation/mosaic/#xem",
            "text": "/**\n * XEM mosaic transferable\n */\nexport declare class XEM extends MosaicTransferable {\n    /**\n     * Divisiblity\n     * @type {number}\n     */\n    static DIVISIBILITY: number;\n    /**\n     * Initial supply\n     * @type {number}\n     */\n    static INITIALSUPPLY: number;\n    /**\n     * Is tranferable\n     * @type {boolean}\n     */\n    static TRANSFERABLE: boolean;\n    /**\n     * Is mutable\n     * @type {boolean}\n     */\n    static SUPPLYMUTABLE: boolean;\n    /**\n     * mosaicId\n     * @type {MosaicId}\n     */\n    static MOSAICID: MosaicId;\n    /**\n    * constructor\n    * @param amount\n    */\n    constructor(amount: number) {\n        super(new MosaicId(\"nem\", \"xem\"), new MosaicProperties(6, 8999999999, true, false), amount);\n    }\n}",
            "title": "XEM"
        },
        {
            "location": "/documentation/custom_mosaics/",
            "text": "Custom Mosaics Definitions\n\n\nNEM Library adds already defined \nMosaics\n to be used like \nXEM\n model.\n\n\nHow to request a new Mosaic Definition\n\n\nWe like to support as Mosaics as we can, just \nemail us\n with the mosaic that you would like to add to NEM Library. \n\n\nWe just require that the mosaic \nmust\n not be mutable.\n\n\nDimCoin Model\n\n\nDimToken is from \nDIMCOIN\n\n\nexport class DimCoin extends MosaicTransferable {\n\n  constructor(amount: number) {\n    super(new MosaicId(\"dim\", \"coin\"), new MosaicProperties(6, 9000000000, true, false), amount);\n  }\n}\n\n\n\n\nDimToken Model\n\n\nDimToken is from \nDIMCOIN\n\n\nexport class DimToken extends MosaicTransferable {\n\n  constructor(amount: number) {\n    super(new MosaicId(\"dim\", \"token\"), new MosaicProperties(6, 10000000, true, false), amount);\n  }\n}\n\n\n\n\nEcobitEco Model\n\n\nEcobitEco is from \nEcobit project\n\n\nexport class EcobitEco extends MosaicTransferable {\n  constructor(amount: number) {\n    super(new MosaicId(\"ecobit\", \"eco\"), new MosaicProperties(0, 8888888888, true, false), amount);\n  }\n}",
            "title": "Custom mosaics"
        },
        {
            "location": "/documentation/custom_mosaics/#custom-mosaics-definitions",
            "text": "NEM Library adds already defined  Mosaics  to be used like  XEM  model.",
            "title": "Custom Mosaics Definitions"
        },
        {
            "location": "/documentation/custom_mosaics/#how-to-request-a-new-mosaic-definition",
            "text": "We like to support as Mosaics as we can, just  email us  with the mosaic that you would like to add to NEM Library.   We just require that the mosaic  must  not be mutable.",
            "title": "How to request a new Mosaic Definition"
        },
        {
            "location": "/documentation/custom_mosaics/#dimcoin-model",
            "text": "DimToken is from  DIMCOIN  export class DimCoin extends MosaicTransferable {\n\n  constructor(amount: number) {\n    super(new MosaicId(\"dim\", \"coin\"), new MosaicProperties(6, 9000000000, true, false), amount);\n  }\n}",
            "title": "DimCoin Model"
        },
        {
            "location": "/documentation/custom_mosaics/#dimtoken-model",
            "text": "DimToken is from  DIMCOIN  export class DimToken extends MosaicTransferable {\n\n  constructor(amount: number) {\n    super(new MosaicId(\"dim\", \"token\"), new MosaicProperties(6, 10000000, true, false), amount);\n  }\n}",
            "title": "DimToken Model"
        },
        {
            "location": "/documentation/custom_mosaics/#ecobiteco-model",
            "text": "EcobitEco is from  Ecobit project  export class EcobitEco extends MosaicTransferable {\n  constructor(amount: number) {\n    super(new MosaicId(\"ecobit\", \"eco\"), new MosaicProperties(0, 8888888888, true, false), amount);\n  }\n}",
            "title": "EcobitEco Model"
        },
        {
            "location": "/documentation/node/",
            "text": "Node related requests\n\n\nNodes are the entities that exchange data in a network. A node is essentially a NIS instance running on a computer. To be able to communicate with the network, a node needs to be booted. Through node requests it is possible to discover other nodes in the network, learn about other nodes experiences and get information about their current chain height.\n\n\nOfficial Source\n\n\nNodeHttp definition\n\n\nexport declare class NodeHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Gets basic information about a node\n     * @returns Observable<Node>\n     */\n    getNodeInfo(): Observable<Node>;\n\n    /**\n     * Gets extended information about a node\n     * @returns Observable<NisNodeInfo>\n     */\n    getNisNodeInfo(): Observable<NisNodeInfo>;\n\n    /**\n     * Gets an array of all known nodes in the neighborhood.\n     * @returns Observable<NodeCollection>\n     */\n    getAllNodes(): Observable<NodeCollection>;\n\n    /**\n     * Gets an array of all nodes with status 'active' in the neighborhood.\n     * @returns Observable<Node[]>\n     */\n    getActiveNodes(): Observable<Node[]>;\n\n    /**\n     * Gets an array of active nodes in the neighborhood that are selected for broadcasts.\n     * @returns Observable<Node[]>\n     */\n    getActiveNeighbourNodes(): Observable<Node[]>;\n\n    /**\n     * Requests the chain height from every node in the active node list and returns the maximum height seen.\n     * @returns Observable<BlockHeight>\n     */\n    getMaximumChainHeightInActiveNeighborhood(): Observable<BlockHeight>;\n\n    /**\n     * Requests the chain height from every node in the active node list and returns the maximum height seen.\n     * @returns Observable<ExtendedNodeExperience[]>\n     */\n    getNodeExperiences(): Observable<ExtendedNodeExperience[]>;\n}\n\n\n\n\nNodeHttp usage\n\n\nimport {NodeHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp();\nnodeHttp.getNodeInfo().subscribe(node => {\n    console.log(node);\n});\n\n\n\n\nOutput:\n\n\nNode {\n  metaData: \n   NodeMetaData {\n     features: 3,\n     network: -104,\n     application: null,\n     version: '0.6.92-BETA',\n     platform: 'Oracle Corporation (1.8.0_40) on Linux' },\n  endpoint: NodeEndpoint { protocol: 'http', port: 7890, host: '104.128.226.60' },\n  identity: NodeIdentity { name: 'Hi, I am BigAlice2', publicAccount: undefined } }\n\n\n\n\nRun the code\n\n\nModels\n\n\nNode\n\n\n/**\n * Nodes are the entities that perform communication in the network like sending and receiving data.\n * A node has an identity which is tied to an account through which the node can identify itself to the network.\n * The communication is done through the endpoint of the node. Additionally a node provides meta data information.\n */\nexport declare class Node {\n\n    /**\n     * Denotes the beginning of the meta data substructure.\n     */\n    readonly metaData: NodeMetaData;\n\n    /**\n     * Denotes the beginning of the endpoint substructure.\n     */\n    readonly endpoint: NodeEndpoint;\n\n    /**\n     * Denotes the beginning of the identity substructure.\n     */\n    readonly identity: NodeIdentity;\n\n}\n\n/**\n * Node meta data\n */\nexport declare class NodeMetaData {\n\n    /**\n     * The number of features the nodes has.\n     */\n    readonly features: number;\n\n    /**\n     * The network id\n     */\n    readonly network: NetworkTypes;\n\n    /**\n     * The name of the application that is running the node.\n     */\n    readonly application: string;\n\n    /**\n     * The version of the application.\n     */\n    readonly version: string;\n\n    /**\n     * The underlying platform (OS, java version).\n     */\n    readonly platform: string;\n}\n\n/**\n * Node endpoint\n */\nexport declare class NodeEndpoint {\n\n    /**\n     * The protocol used for the communication (HTTP or HTTPS).\n     */\n    readonly protocol: string;\n\n    /**\n     * The port used for the communication.\n     */\n    readonly port: number;\n\n    /**\n     * The IP address of the endpoint.\n     */\n    readonly host: string;\n}\n\n/**\n * Node identity\n */\nexport declare class NodeIdentity {\n\n    /**\n     * The name of the node.\n     */\n    readonly name: string;\n\n    /**\n    * The public account used to identify the node.\n    */\n    readonly publicAccount: PublicAccount;\n}\n\n\n\n\n\nNisNodeInfo\n\n\n/**\n * A NodeCollection object holds arrays of nodes with different statuses.\n */\nexport declare class NisNodeInfo {\n\n    /**\n     * Denotes the beginning of the node substructure.\n     */\n    readonly node: Node;\n\n    /**\n     * Denotes the beginning of the application meta data substructure.\n     */\n    readonly nisInfo: ApplicationMetaData;\n}\n\n/**\n * The application meta data object supplies additional information about the application running on a node.\n */\nexport declare class ApplicationMetaData {\n\n    /**\n     * The current network time, i.e. the number of seconds that have elapsed since the creation of the nemesis block.\n     */\n    readonly currentTime: number;\n\n    /**\n     * The name of the application running on the node.\n     */\n    readonly application: string;\n\n    /**\n     * The network time when the application was started.\n     */\n    readonly startTime: number;\n\n    /**\n     * The application version.\n     */\n    readonly version: string;\n\n    /**\n     * The signer of the certificate used by the application.\n     */\n    readonly signer: string;\n}\n\n\n\n\nNodeCollection\n\n\n/**\n * A NodeCollection object holds arrays of nodes with different statuses.\n */\nexport declare class NodeCollection {\n\n    /**\n     * A connection to the node cannot be established.\n     */\n    readonly inactive: Node[];\n\n    /**\n     * A connection can be established and the remote node responds in a timely manner.\n     */\n    readonly active: Node[];\n\n    /**\n     * A connection can be established but the node cannot provide information within the timeout limits.\n     */\n    readonly busy: Node[];\n\n    /**\n     * A fatal error occurs when trying to establish a connection or the node couldn't authenticate itself correctly.\n     */\n    readonly failure: Node[];\n}\n\n\n\n\nExtendedNodeExperience\n\n\n/**\n * When exchanging data with other nodes the result of the communication is divided into three\n * different outcomes: success, neutral and failure.\n * In the cases of success and failure the result is saved to be able to judge the quality of a node.\n * This has influence on the probability that a certain node is selected as partner.\n */\nexport declare class ExtendedNodeExperience {\n\n    /**\n     * Denotes the beginning of the of the Node substructure.\n     */\n    readonly node: Node;\n\n    /**\n     * The number of synchronization attempts the node had with the remote node.\n     */\n    readonly syncs: number;\n\n    /**\n     * Denotes the beginning of the of the NodeExperience substructure.\n     */\n    readonly experience: ExtendedNodeExperienceData;\n}\n\n/**\n * Node experience data\n */\nexport declare class ExtendedNodeExperienceData {\n\n    /**\n     * The number of successful communications with the remote node.\n     */\n    readonly s: number;\n\n    /**\n     * The number of failed communications with the remote node.\n     */\n    readonly f: number;\n}",
            "title": "Node"
        },
        {
            "location": "/documentation/node/#node-related-requests",
            "text": "Nodes are the entities that exchange data in a network. A node is essentially a NIS instance running on a computer. To be able to communicate with the network, a node needs to be booted. Through node requests it is possible to discover other nodes in the network, learn about other nodes experiences and get information about their current chain height.  Official Source",
            "title": "Node related requests"
        },
        {
            "location": "/documentation/node/#nodehttp-definition",
            "text": "export declare class NodeHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Gets basic information about a node\n     * @returns Observable<Node>\n     */\n    getNodeInfo(): Observable<Node>;\n\n    /**\n     * Gets extended information about a node\n     * @returns Observable<NisNodeInfo>\n     */\n    getNisNodeInfo(): Observable<NisNodeInfo>;\n\n    /**\n     * Gets an array of all known nodes in the neighborhood.\n     * @returns Observable<NodeCollection>\n     */\n    getAllNodes(): Observable<NodeCollection>;\n\n    /**\n     * Gets an array of all nodes with status 'active' in the neighborhood.\n     * @returns Observable<Node[]>\n     */\n    getActiveNodes(): Observable<Node[]>;\n\n    /**\n     * Gets an array of active nodes in the neighborhood that are selected for broadcasts.\n     * @returns Observable<Node[]>\n     */\n    getActiveNeighbourNodes(): Observable<Node[]>;\n\n    /**\n     * Requests the chain height from every node in the active node list and returns the maximum height seen.\n     * @returns Observable<BlockHeight>\n     */\n    getMaximumChainHeightInActiveNeighborhood(): Observable<BlockHeight>;\n\n    /**\n     * Requests the chain height from every node in the active node list and returns the maximum height seen.\n     * @returns Observable<ExtendedNodeExperience[]>\n     */\n    getNodeExperiences(): Observable<ExtendedNodeExperience[]>;\n}",
            "title": "NodeHttp definition"
        },
        {
            "location": "/documentation/node/#nodehttp-usage",
            "text": "import {NodeHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp();\nnodeHttp.getNodeInfo().subscribe(node => {\n    console.log(node);\n});  Output:  Node {\n  metaData: \n   NodeMetaData {\n     features: 3,\n     network: -104,\n     application: null,\n     version: '0.6.92-BETA',\n     platform: 'Oracle Corporation (1.8.0_40) on Linux' },\n  endpoint: NodeEndpoint { protocol: 'http', port: 7890, host: '104.128.226.60' },\n  identity: NodeIdentity { name: 'Hi, I am BigAlice2', publicAccount: undefined } }  Run the code",
            "title": "NodeHttp usage"
        },
        {
            "location": "/documentation/node/#models",
            "text": "",
            "title": "Models"
        },
        {
            "location": "/documentation/node/#node",
            "text": "/**\n * Nodes are the entities that perform communication in the network like sending and receiving data.\n * A node has an identity which is tied to an account through which the node can identify itself to the network.\n * The communication is done through the endpoint of the node. Additionally a node provides meta data information.\n */\nexport declare class Node {\n\n    /**\n     * Denotes the beginning of the meta data substructure.\n     */\n    readonly metaData: NodeMetaData;\n\n    /**\n     * Denotes the beginning of the endpoint substructure.\n     */\n    readonly endpoint: NodeEndpoint;\n\n    /**\n     * Denotes the beginning of the identity substructure.\n     */\n    readonly identity: NodeIdentity;\n\n}\n\n/**\n * Node meta data\n */\nexport declare class NodeMetaData {\n\n    /**\n     * The number of features the nodes has.\n     */\n    readonly features: number;\n\n    /**\n     * The network id\n     */\n    readonly network: NetworkTypes;\n\n    /**\n     * The name of the application that is running the node.\n     */\n    readonly application: string;\n\n    /**\n     * The version of the application.\n     */\n    readonly version: string;\n\n    /**\n     * The underlying platform (OS, java version).\n     */\n    readonly platform: string;\n}\n\n/**\n * Node endpoint\n */\nexport declare class NodeEndpoint {\n\n    /**\n     * The protocol used for the communication (HTTP or HTTPS).\n     */\n    readonly protocol: string;\n\n    /**\n     * The port used for the communication.\n     */\n    readonly port: number;\n\n    /**\n     * The IP address of the endpoint.\n     */\n    readonly host: string;\n}\n\n/**\n * Node identity\n */\nexport declare class NodeIdentity {\n\n    /**\n     * The name of the node.\n     */\n    readonly name: string;\n\n    /**\n    * The public account used to identify the node.\n    */\n    readonly publicAccount: PublicAccount;\n}",
            "title": "Node"
        },
        {
            "location": "/documentation/node/#nisnodeinfo",
            "text": "/**\n * A NodeCollection object holds arrays of nodes with different statuses.\n */\nexport declare class NisNodeInfo {\n\n    /**\n     * Denotes the beginning of the node substructure.\n     */\n    readonly node: Node;\n\n    /**\n     * Denotes the beginning of the application meta data substructure.\n     */\n    readonly nisInfo: ApplicationMetaData;\n}\n\n/**\n * The application meta data object supplies additional information about the application running on a node.\n */\nexport declare class ApplicationMetaData {\n\n    /**\n     * The current network time, i.e. the number of seconds that have elapsed since the creation of the nemesis block.\n     */\n    readonly currentTime: number;\n\n    /**\n     * The name of the application running on the node.\n     */\n    readonly application: string;\n\n    /**\n     * The network time when the application was started.\n     */\n    readonly startTime: number;\n\n    /**\n     * The application version.\n     */\n    readonly version: string;\n\n    /**\n     * The signer of the certificate used by the application.\n     */\n    readonly signer: string;\n}",
            "title": "NisNodeInfo"
        },
        {
            "location": "/documentation/node/#nodecollection",
            "text": "/**\n * A NodeCollection object holds arrays of nodes with different statuses.\n */\nexport declare class NodeCollection {\n\n    /**\n     * A connection to the node cannot be established.\n     */\n    readonly inactive: Node[];\n\n    /**\n     * A connection can be established and the remote node responds in a timely manner.\n     */\n    readonly active: Node[];\n\n    /**\n     * A connection can be established but the node cannot provide information within the timeout limits.\n     */\n    readonly busy: Node[];\n\n    /**\n     * A fatal error occurs when trying to establish a connection or the node couldn't authenticate itself correctly.\n     */\n    readonly failure: Node[];\n}",
            "title": "NodeCollection"
        },
        {
            "location": "/documentation/node/#extendednodeexperience",
            "text": "/**\n * When exchanging data with other nodes the result of the communication is divided into three\n * different outcomes: success, neutral and failure.\n * In the cases of success and failure the result is saved to be able to judge the quality of a node.\n * This has influence on the probability that a certain node is selected as partner.\n */\nexport declare class ExtendedNodeExperience {\n\n    /**\n     * Denotes the beginning of the of the Node substructure.\n     */\n    readonly node: Node;\n\n    /**\n     * The number of synchronization attempts the node had with the remote node.\n     */\n    readonly syncs: number;\n\n    /**\n     * Denotes the beginning of the of the NodeExperience substructure.\n     */\n    readonly experience: ExtendedNodeExperienceData;\n}\n\n/**\n * Node experience data\n */\nexport declare class ExtendedNodeExperienceData {\n\n    /**\n     * The number of successful communications with the remote node.\n     */\n    readonly s: number;\n\n    /**\n     * The number of failed communications with the remote node.\n     */\n    readonly f: number;\n}",
            "title": "ExtendedNodeExperience"
        },
        {
            "location": "/documentation/blockchain/",
            "text": "Blockchain related requests\n\n\nNEM builds a blockchain which contains every bit of information needed. Subsequent blocks in the blockchain have increasing heights that differ by one. Each block can contain transactions. Transactions build the basis of all account activity. It is therefore important to understand the concept and the structures of blocks and transactions.\n\n\nBlocks are generated by accounts. If an account generates a block and the block gets included in the blockchain, the generating account, called the harvester, gets all the transaction fees for transactions that are included in the block. A harvester will therefore usually include as many transactions as possible.\n\n\nTransactions reflect all account activities. In order for a client to have an up to date balance on every account it is crucial to know about every transaction that occurred and therefore the client must have knowledge about every single block in the chain (one says: the client must be synchronized with the blockchain).\n\n\nOfficial Source\n\n\nBlockHttp definition\n\n\nexport declare type BlockHeight = number;\n\nexport declare type BlockChainScore = number;\n\nexport declare class BlockHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Gets a block from the chain that has a given hash.\n     * @param BlockHeight - A BlockHeight JSON object\n     * @returns Observable<Block>\n     */\n    getBlockByHeight(blockHeight: BlockHeight): Observable<Block>;\n}\n\n\n\n\n\nBlockHttp usage\n\n\nimport {BlockHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst blockHttp = new BlockHttp();\nblockHttp.getBlockByHeight(1033023).subscribe(block => {\n    console.log(block);\n});\n\n\n\n\nOutput\n\n\nBlock {\n  height: 1033023,\n  type: 1,\n  timeStamp: 72650707,\n  prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' },\n  signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00',\n  signer: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TDONALICE7O3L63AS3KNDCPT7ZA7HMQTFZGYUCAH',\n        networkType: 152 },\n     publicKey: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a' },\n  transactions: [],\n  version: -1744830463 }\n\n\n\n\nRun the code\n\n\nChainHttp definition\n\n\nexport declare class ChainHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n    /**\n     * Gets the current height of the block chain.\n     * @returns Observable<BlockHeight>\n     */\n    getBlockchainHeight(): Observable<BlockHeight>;\n    /**\n     * Gets the current score of the block chain. The higher the score, the better the chain.\n     * During synchronization, nodes try to get the best block chain in the network.\n     * @returns Observable<BlockChainScore>\n     */\n    getBlockchainScore(): Observable<BlockChainScore>;\n    /**\n     * Gets the current last block of the chain.\n     * @returns Observable<Block>\n     */\n    getBlockchainLastBlock(): Observable<Block>;\n}\n\n\n\n\n\n\nChainHttp usage\n\n\nimport {ChainHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst chainHttp = new ChainHttp();\nchainHttp.getBlockchainLastBlock().subscribe(block => {\n    console.log(block);\n});\n\n\n\n\nOutput\n\n\nBlock {\n  height: 1033023,\n  type: 1,\n  timeStamp: 72650707,\n  prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' },\n  signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00',\n  signer: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TDONALICE7O3L63AS3KNDCPT7ZA7HMQTFZGYUCAH',\n        networkType: 152 },\n     publicKey: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a' },\n  transactions: [],\n  version: -1744830463 }\n\n\n\n\n\nRun the code\n\n\nModels\n\n\nBlock\n\n\n\nexport declare enum BlockVersion {\n  MAIN_NET = 0x68,\n  TEST_NET = 0x98\n}\n\nexport declare enum BlockType {\n  NEMESIS = -1,\n  REGULAR = 1\n}\n\n/**\n * A blockchain is the structure that contains the transaction information. A blockchain can contain up to 120 transactions. Blocks are generated and signed by accounts and are the instrument by which information is spread in the network.\n */\nexport declare class Block  {\n\n  /**\n   * The height of the blockchain. Each blockchain has a unique height. Subsequent blocks differ in height by 1.\n   */\n  readonly height: BlockHeight;\n\n  /**\n   * The blockchain type\n   */\n  readonly type: BlockType;\n\n  /**\n   * The number of seconds elapsed since the creation of the nemesis blockchain.\n   */\n  readonly timeStamp: number;\n\n  /**\n   * The sha3-256 hash of the last blockchain as hex-string.\n   */\n  readonly prevBlockHash: HashData;\n\n  /**\n   * The public account of the harvester of the blockchain as hexadecimal number.\n   */\n  readonly signer: PublicAccount;\n\n  /**\n   * The public key of the harvester of the blockchain as hexadecimal number.\n   */\n  readonly signer: string;\n\n  /**\n   * The array of transaction\n   */\n  readonly transactions: Transaction[];\n\n  /**\n   * The blockchain version\n   */\n  readonly version: BlockVersion;\n }",
            "title": "Blockchain"
        },
        {
            "location": "/documentation/blockchain/#blockchain-related-requests",
            "text": "NEM builds a blockchain which contains every bit of information needed. Subsequent blocks in the blockchain have increasing heights that differ by one. Each block can contain transactions. Transactions build the basis of all account activity. It is therefore important to understand the concept and the structures of blocks and transactions.  Blocks are generated by accounts. If an account generates a block and the block gets included in the blockchain, the generating account, called the harvester, gets all the transaction fees for transactions that are included in the block. A harvester will therefore usually include as many transactions as possible.  Transactions reflect all account activities. In order for a client to have an up to date balance on every account it is crucial to know about every transaction that occurred and therefore the client must have knowledge about every single block in the chain (one says: the client must be synchronized with the blockchain).  Official Source",
            "title": "Blockchain related requests"
        },
        {
            "location": "/documentation/blockchain/#blockhttp-definition",
            "text": "export declare type BlockHeight = number;\n\nexport declare type BlockChainScore = number;\n\nexport declare class BlockHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n\n    /**\n     * Gets a block from the chain that has a given hash.\n     * @param BlockHeight - A BlockHeight JSON object\n     * @returns Observable<Block>\n     */\n    getBlockByHeight(blockHeight: BlockHeight): Observable<Block>;\n}",
            "title": "BlockHttp definition"
        },
        {
            "location": "/documentation/blockchain/#blockhttp-usage",
            "text": "import {BlockHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst blockHttp = new BlockHttp();\nblockHttp.getBlockByHeight(1033023).subscribe(block => {\n    console.log(block);\n});  Output  Block {\n  height: 1033023,\n  type: 1,\n  timeStamp: 72650707,\n  prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' },\n  signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00',\n  signer: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TDONALICE7O3L63AS3KNDCPT7ZA7HMQTFZGYUCAH',\n        networkType: 152 },\n     publicKey: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a' },\n  transactions: [],\n  version: -1744830463 }  Run the code",
            "title": "BlockHttp usage"
        },
        {
            "location": "/documentation/blockchain/#chainhttp-definition",
            "text": "export declare class ChainHttp extends HttpEndpoint {\n    constructor(nodes?: ServerConfig[]);\n    /**\n     * Gets the current height of the block chain.\n     * @returns Observable<BlockHeight>\n     */\n    getBlockchainHeight(): Observable<BlockHeight>;\n    /**\n     * Gets the current score of the block chain. The higher the score, the better the chain.\n     * During synchronization, nodes try to get the best block chain in the network.\n     * @returns Observable<BlockChainScore>\n     */\n    getBlockchainScore(): Observable<BlockChainScore>;\n    /**\n     * Gets the current last block of the chain.\n     * @returns Observable<Block>\n     */\n    getBlockchainLastBlock(): Observable<Block>;\n}",
            "title": "ChainHttp definition"
        },
        {
            "location": "/documentation/blockchain/#chainhttp-usage",
            "text": "import {ChainHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst chainHttp = new ChainHttp();\nchainHttp.getBlockchainLastBlock().subscribe(block => {\n    console.log(block);\n});  Output  Block {\n  height: 1033023,\n  type: 1,\n  timeStamp: 72650707,\n  prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' },\n  signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00',\n  signer: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TDONALICE7O3L63AS3KNDCPT7ZA7HMQTFZGYUCAH',\n        networkType: 152 },\n     publicKey: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a' },\n  transactions: [],\n  version: -1744830463 }  Run the code",
            "title": "ChainHttp usage"
        },
        {
            "location": "/documentation/blockchain/#models",
            "text": "",
            "title": "Models"
        },
        {
            "location": "/documentation/blockchain/#block",
            "text": "export declare enum BlockVersion {\n  MAIN_NET = 0x68,\n  TEST_NET = 0x98\n}\n\nexport declare enum BlockType {\n  NEMESIS = -1,\n  REGULAR = 1\n}\n\n/**\n * A blockchain is the structure that contains the transaction information. A blockchain can contain up to 120 transactions. Blocks are generated and signed by accounts and are the instrument by which information is spread in the network.\n */\nexport declare class Block  {\n\n  /**\n   * The height of the blockchain. Each blockchain has a unique height. Subsequent blocks differ in height by 1.\n   */\n  readonly height: BlockHeight;\n\n  /**\n   * The blockchain type\n   */\n  readonly type: BlockType;\n\n  /**\n   * The number of seconds elapsed since the creation of the nemesis blockchain.\n   */\n  readonly timeStamp: number;\n\n  /**\n   * The sha3-256 hash of the last blockchain as hex-string.\n   */\n  readonly prevBlockHash: HashData;\n\n  /**\n   * The public account of the harvester of the blockchain as hexadecimal number.\n   */\n  readonly signer: PublicAccount;\n\n  /**\n   * The public key of the harvester of the blockchain as hexadecimal number.\n   */\n  readonly signer: string;\n\n  /**\n   * The array of transaction\n   */\n  readonly transactions: Transaction[];\n\n  /**\n   * The blockchain version\n   */\n  readonly version: BlockVersion;\n }",
            "title": "Block"
        },
        {
            "location": "/documentation/listener/",
            "text": "Listeners\n\n\nAccountListener definition\n\n\n/**\n * Account listener\n */\nexport declare class AccountListener extends Listener {\n\n    /**\n     * Constructor\n     * @param nodes\n     */\n    constructor(nodes?: WebSocketConfig[]);\n\n    /**\n     * Start listening updates\n     * @param address\n     * @returns {Observable<AccountInfoWithMetaData>}\n     */\n    given(address: Address): Observable<AccountInfoWithMetaData>;\n}\n\n\n\n\n\n\nAccountListener usage\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {AccountListener, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\");\nlet accountListener = new AccountListener().given(address).subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});\n\n\n\n\n\n\nOutput\n\n\nAccountInfoWithMetaData {\n  balance: \n   Balance {\n     balance: 10246300001,\n     vestedBalance: 5507591402,\n     unvestedBalance: 4738708599 },\n  importance: 0,\n  publicAccount: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA',\n        networkType: 152 },\n     publicKey: 'a4f9d42cf8e1f7c6c3216ede81896c4fa9f49071ee4aee2a4843e2711899b23a' },\n  harvestedBlocks: 0,\n  cosignatoriesCount: undefined,\n  minCosignatories: undefined,\n  status: 'LOCKED',\n  remoteStatus: 'ACTIVE',\n  cosignatoryOf: \n   [ AccountInfo {\n       balance: [Object],\n       importance: 0,\n       publicAccount: [Object],\n       harvestedBlocks: 0,\n       cosignatoriesCount: undefined,\n       minCosignatories: undefined },\n     AccountInfo {\n       balance: [Object],\n       importance: 0,\n       publicAccount: [Object],\n       harvestedBlocks: 0,\n       cosignatoriesCount: undefined,\n       minCosignatories: undefined } ],\n  cosignatories: [] }\n\n\n\n\n\nRun the code\n\n\nBlockchainListener definition\n\n\n/**\n * Blockchain listener\n */\nexport declare class BlockchainListener extends Listener {\n\n    /**\n     * Constructor\n     * @param nodes\n     */\n    constructor(nodes?: WebSocketConfig[]);\n\n    /**\n     * Start listening new blocks\n     * @returns {Observable<Block>}\n     */\n    newBlock(): Observable<Block>;\n\n    /**\n     * Start listening new blockchain height\n     * @returns {Observable<BlockHeight>}\n     */\n    newHeight(): Observable<BlockHeight>;\n}\n\n\n\n\n\n\nUnconfirmedTransactionListener definition\n\n\n/**\n * UnconfirmedTransaction listener\n */\nexport declare class UnconfirmedTransactionListener extends Listener {\n\n    /**\n     * Constructor\n     * @param nodes\n     */\n    constructor(nodes?: WebSocketConfig[]);\n\n    /**\n     * Start listening new unconfirmed transactions\n     * @param address\n     * @returns {Observable<Transaction>}\n     */\n    given(address: Address): Observable<Transaction>;\n\n}\n\n\n\n\n\n\nConfirmedTransactionListener definition\n\n\n/**\n * ConfirmedTransaction listener\n */\nexport declare class ConfirmedTransactionListener extends Listener {\n\n    /**\n     * Constructor\n     * @param nodes\n     */\n    constructor(nodes?: WebSocketConfig[]);\n\n    /**\n     * Start listening new confirmed transactions\n     * @param address\n     * @returns {Observable<Transaction>}\n     */\n    given(address: Address): Observable<Transaction>;\n\n}",
            "title": "Listener"
        },
        {
            "location": "/documentation/listener/#listeners",
            "text": "",
            "title": "Listeners"
        },
        {
            "location": "/documentation/listener/#accountlistener-definition",
            "text": "/**\n * Account listener\n */\nexport declare class AccountListener extends Listener {\n\n    /**\n     * Constructor\n     * @param nodes\n     */\n    constructor(nodes?: WebSocketConfig[]);\n\n    /**\n     * Start listening updates\n     * @param address\n     * @returns {Observable<AccountInfoWithMetaData>}\n     */\n    given(address: Address): Observable<AccountInfoWithMetaData>;\n}",
            "title": "AccountListener definition"
        },
        {
            "location": "/documentation/listener/#accountlistener-usage",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {AccountListener, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\");\nlet accountListener = new AccountListener().given(address).subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});  Output  AccountInfoWithMetaData {\n  balance: \n   Balance {\n     balance: 10246300001,\n     vestedBalance: 5507591402,\n     unvestedBalance: 4738708599 },\n  importance: 0,\n  publicAccount: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA',\n        networkType: 152 },\n     publicKey: 'a4f9d42cf8e1f7c6c3216ede81896c4fa9f49071ee4aee2a4843e2711899b23a' },\n  harvestedBlocks: 0,\n  cosignatoriesCount: undefined,\n  minCosignatories: undefined,\n  status: 'LOCKED',\n  remoteStatus: 'ACTIVE',\n  cosignatoryOf: \n   [ AccountInfo {\n       balance: [Object],\n       importance: 0,\n       publicAccount: [Object],\n       harvestedBlocks: 0,\n       cosignatoriesCount: undefined,\n       minCosignatories: undefined },\n     AccountInfo {\n       balance: [Object],\n       importance: 0,\n       publicAccount: [Object],\n       harvestedBlocks: 0,\n       cosignatoriesCount: undefined,\n       minCosignatories: undefined } ],\n  cosignatories: [] }  Run the code",
            "title": "AccountListener usage"
        },
        {
            "location": "/documentation/listener/#blockchainlistener-definition",
            "text": "/**\n * Blockchain listener\n */\nexport declare class BlockchainListener extends Listener {\n\n    /**\n     * Constructor\n     * @param nodes\n     */\n    constructor(nodes?: WebSocketConfig[]);\n\n    /**\n     * Start listening new blocks\n     * @returns {Observable<Block>}\n     */\n    newBlock(): Observable<Block>;\n\n    /**\n     * Start listening new blockchain height\n     * @returns {Observable<BlockHeight>}\n     */\n    newHeight(): Observable<BlockHeight>;\n}",
            "title": "BlockchainListener definition"
        },
        {
            "location": "/documentation/listener/#unconfirmedtransactionlistener-definition",
            "text": "/**\n * UnconfirmedTransaction listener\n */\nexport declare class UnconfirmedTransactionListener extends Listener {\n\n    /**\n     * Constructor\n     * @param nodes\n     */\n    constructor(nodes?: WebSocketConfig[]);\n\n    /**\n     * Start listening new unconfirmed transactions\n     * @param address\n     * @returns {Observable<Transaction>}\n     */\n    given(address: Address): Observable<Transaction>;\n\n}",
            "title": "UnconfirmedTransactionListener definition"
        },
        {
            "location": "/documentation/listener/#confirmedtransactionlistener-definition",
            "text": "/**\n * ConfirmedTransaction listener\n */\nexport declare class ConfirmedTransactionListener extends Listener {\n\n    /**\n     * Constructor\n     * @param nodes\n     */\n    constructor(nodes?: WebSocketConfig[]);\n\n    /**\n     * Start listening new confirmed transactions\n     * @param address\n     * @returns {Observable<Transaction>}\n     */\n    given(address: Address): Observable<Transaction>;\n\n}",
            "title": "ConfirmedTransactionListener definition"
        },
        {
            "location": "/documentation/wallet/",
            "text": "Wallets\n\n\nSimpleWallet definition\n\n\n/**\n * Simple wallet model generates a private key from a PRNG\n */\nexport declare class SimpleWallet extends Wallet {\n\n    /**\n     * The encripted private key and information to decrypt it\n     */\n    readonly encryptedPrivateKey: EncryptedPrivateKey;\n\n    /**\n     * Create a SimpleWallet\n     * @param name\n     * @param password\n     * @returns {SimpleWallet}\n     */\n    static create(name: string, password: Password): SimpleWallet;\n\n    /**\n     * Create a SimpleWallet from private key\n     * @param name\n     * @param network\n     * @param password\n     * @param privateKey\n     * @returns {SimpleWallet}\n     */\n    static createWithPrivateKey(name: string, password: Password, privateKey: string): SimpleWallet;\n\n    /**\n     * Open a wallet and generate an Account\n     * @param password\n     * @returns {Account}\n     */\n    open(password: Password): Account;\n\n    /**\n    * Receives the Private Key for the Wallet\n    * @param {Password} password\n    * @returns {string}\n    */\n    unlockPrivateKey(password: Password): string;\n\n    /**\n    * Converts SimpleWallet into writable string to persist into a file\n    * @returns {string}\n    */\n    writeWLTFile(): string;\n\n    /**\n    * Reads the WLT content and converts it into a SimpleWallet\n    * @param {string} wlt\n    * @returns {SimpleWallet}\n    */\n    static readFromWLT(wlt: string): SimpleWallet;\n}\n\n\n\n\n\nSimpleWallet usage\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst password = new Password(\"password\");\nconst simpleWallet = SimpleWallet.create(\"simple wallet\", password);\n\nconsole.log(simpleWallet);\n\n\n\n\nOutput\n\n\nSimpleWallet {\n  name: 'simple wallet',\n  network: 152,\n  address: \n   Address {\n     value: 'TBSICCK3PJZDWQ4JCPWT55IRBWEQMRSABQ3QJHE4',\n     networkType: 152 },\n  creationDate: \n   LocalDateTime {\n     _date: LocalDate { _year: 2017, _month: 7, _day: 24 },\n     _time: LocalTime { _hour: 16, _minute: 44, _second: 14, _nano: 870000000 } },\n  encryptedPrivateKey: \n   EncryptedPrivateKey {\n     encryptedKey: '2cb583e61208964d465955cc35c86c9e83733a10adc40cee6b8c650478ffe3667ccb70328a0dc2c67de9770806040580',\n     iv: 'c192d9a501c7dde5c7e05186c93b63da' } }\n\n\n\n\n\nRun the code\n\n\nBrainWallet definition\n\n\n/**\n * Brain wallet derived the private key from the brainPassword, hashing the brainPassword multiple times, therefore it's crucial to select a SAFE brainPassword.\n */\nexport declare class BrainWallet extends Wallet {\n\n    /**\n     * Create a BrainWallet\n     * @param name\n     * @param password\n     * @returns {BrainWallet}\n     */\n    static create(name: string, password: BrainPassword): BrainWallet;\n\n    /**\n     * Open a wallet and generate an Account\n     * @param password\n     * @returns {Account}\n     */\n    open(password: BrainPassword): Account;\n\n\n    /**\n    * Receives the Private Key for the Wallet\n    * @param {Password} password\n    * @returns {string}\n    */\n    unlockPrivateKey(password: Password): string;\n\n    /**\n    * Converts BrainWallet into writable string to persist into a file\n    * @returns {string}\n    */\n    writeWLTFile(): string;\n\n    /**\n    * Reads the WLT content and converts it into a BrainWallet\n    * @param {string} wlt\n    * @returns {BrainWallet}\n    */\n    static readFromWLT(wlt: string): BrainWallet;\n}\n\n\n\n\n\nBrainWallet usage\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst brainPassword =  new BrainPassword(\"entertain destruction sassy impartial morning electric limit glib bait grape icy measure\")\nconst brainWallet = BrainWallet.create(\"brain wallet\", brainPassword);\n\nconsole.log(brainWallet);\n\n\n\n\nOutput\n\n\nBrainWallet {\n  name: 'brain wallet',\n  network: 152,\n  address: \n   Address {\n     value: 'TBUWTIIYM2BFFAE3JOEW3LGG5X3QTO7L2RWGZ6XV',\n     networkType: 152 },\n  creationDate: \n   LocalDateTime {\n     _date: LocalDate { _year: 2017, _month: 7, _day: 24 },\n     _time: LocalTime { _hour: 16, _minute: 44, _second: 42, _nano: 402000000 } } }\n\n\n\n\n\nRun the code\n\n\nModels\n\n\nWallet\n\n\nexport enum WalletType {\n  SIMPLE,\n  BRAIN\n}\n\n/**\n * Wallet base model\n */\nexport declare abstract class Wallet {\n\n    /**\n     * The wallet's name\n     */\n    readonly name: string;\n\n    /**\n     * The wallet's network\n     */\n    readonly network: NetworkTypes;\n\n    /**\n     * The wallet's address\n     */\n    readonly address: Address;\n\n    /**\n     * The wallet's creation date\n     */\n    readonly creationDate: LocalDateTime;\n\n    /**\n     * Abstract open wallet method returning an account from current wallet.\n     * @param password\n     */\n    abstract open(password: Password): Account;\n\n    /**\n    * Given a WLT string, retusn the WalletType\n    * @param {string} wlt\n    * @returns {WalletType}\n    */\n    static walletTypeGivenWLT(wlt: string): WalletType;\n}\n\n\n\n\n\nPassword\n\n\n/**\n * Password model\n */\nexport declare class Password {\n\n    /**\n     * Password value\n     */\n    readonly value: string;\n\n    /**\n     * Create a password with at least 8 characters\n     * @param password\n     */\n    constructor(password: string);\n}\n\n\n\n\n\nBrainPassword\n\n\n/**\n * Brain password is an extended version of Password. With the brain password we derive the private key in BrainWallets.\n */\nexport declare class BrainPassword extends Password {\n\n    /**\n     * Constructor\n     * @param password - password must be secure, the password must be at least a 12 random words password.\n     */\n    constructor(password: string);\n}\n\n\n\n\n\n\nEncryptedPrivateKey\n\n\n/**\n * EncryptedPrivateKey model\n */\nexport declare class EncryptedPrivateKey {\n\n    /**\n     * Encrypted private key data\n     */\n    readonly encryptedKey: string;\n\n    /**\n     * Initialization vector used in the decrypt process\n     */\n    readonly iv: string;\n}",
            "title": "Wallet"
        },
        {
            "location": "/documentation/wallet/#wallets",
            "text": "",
            "title": "Wallets"
        },
        {
            "location": "/documentation/wallet/#simplewallet-definition",
            "text": "/**\n * Simple wallet model generates a private key from a PRNG\n */\nexport declare class SimpleWallet extends Wallet {\n\n    /**\n     * The encripted private key and information to decrypt it\n     */\n    readonly encryptedPrivateKey: EncryptedPrivateKey;\n\n    /**\n     * Create a SimpleWallet\n     * @param name\n     * @param password\n     * @returns {SimpleWallet}\n     */\n    static create(name: string, password: Password): SimpleWallet;\n\n    /**\n     * Create a SimpleWallet from private key\n     * @param name\n     * @param network\n     * @param password\n     * @param privateKey\n     * @returns {SimpleWallet}\n     */\n    static createWithPrivateKey(name: string, password: Password, privateKey: string): SimpleWallet;\n\n    /**\n     * Open a wallet and generate an Account\n     * @param password\n     * @returns {Account}\n     */\n    open(password: Password): Account;\n\n    /**\n    * Receives the Private Key for the Wallet\n    * @param {Password} password\n    * @returns {string}\n    */\n    unlockPrivateKey(password: Password): string;\n\n    /**\n    * Converts SimpleWallet into writable string to persist into a file\n    * @returns {string}\n    */\n    writeWLTFile(): string;\n\n    /**\n    * Reads the WLT content and converts it into a SimpleWallet\n    * @param {string} wlt\n    * @returns {SimpleWallet}\n    */\n    static readFromWLT(wlt: string): SimpleWallet;\n}",
            "title": "SimpleWallet definition"
        },
        {
            "location": "/documentation/wallet/#simplewallet-usage",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst password = new Password(\"password\");\nconst simpleWallet = SimpleWallet.create(\"simple wallet\", password);\n\nconsole.log(simpleWallet);  Output  SimpleWallet {\n  name: 'simple wallet',\n  network: 152,\n  address: \n   Address {\n     value: 'TBSICCK3PJZDWQ4JCPWT55IRBWEQMRSABQ3QJHE4',\n     networkType: 152 },\n  creationDate: \n   LocalDateTime {\n     _date: LocalDate { _year: 2017, _month: 7, _day: 24 },\n     _time: LocalTime { _hour: 16, _minute: 44, _second: 14, _nano: 870000000 } },\n  encryptedPrivateKey: \n   EncryptedPrivateKey {\n     encryptedKey: '2cb583e61208964d465955cc35c86c9e83733a10adc40cee6b8c650478ffe3667ccb70328a0dc2c67de9770806040580',\n     iv: 'c192d9a501c7dde5c7e05186c93b63da' } }  Run the code",
            "title": "SimpleWallet usage"
        },
        {
            "location": "/documentation/wallet/#brainwallet-definition",
            "text": "/**\n * Brain wallet derived the private key from the brainPassword, hashing the brainPassword multiple times, therefore it's crucial to select a SAFE brainPassword.\n */\nexport declare class BrainWallet extends Wallet {\n\n    /**\n     * Create a BrainWallet\n     * @param name\n     * @param password\n     * @returns {BrainWallet}\n     */\n    static create(name: string, password: BrainPassword): BrainWallet;\n\n    /**\n     * Open a wallet and generate an Account\n     * @param password\n     * @returns {Account}\n     */\n    open(password: BrainPassword): Account;\n\n\n    /**\n    * Receives the Private Key for the Wallet\n    * @param {Password} password\n    * @returns {string}\n    */\n    unlockPrivateKey(password: Password): string;\n\n    /**\n    * Converts BrainWallet into writable string to persist into a file\n    * @returns {string}\n    */\n    writeWLTFile(): string;\n\n    /**\n    * Reads the WLT content and converts it into a BrainWallet\n    * @param {string} wlt\n    * @returns {BrainWallet}\n    */\n    static readFromWLT(wlt: string): BrainWallet;\n}",
            "title": "BrainWallet definition"
        },
        {
            "location": "/documentation/wallet/#brainwallet-usage",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst brainPassword =  new BrainPassword(\"entertain destruction sassy impartial morning electric limit glib bait grape icy measure\")\nconst brainWallet = BrainWallet.create(\"brain wallet\", brainPassword);\n\nconsole.log(brainWallet);  Output  BrainWallet {\n  name: 'brain wallet',\n  network: 152,\n  address: \n   Address {\n     value: 'TBUWTIIYM2BFFAE3JOEW3LGG5X3QTO7L2RWGZ6XV',\n     networkType: 152 },\n  creationDate: \n   LocalDateTime {\n     _date: LocalDate { _year: 2017, _month: 7, _day: 24 },\n     _time: LocalTime { _hour: 16, _minute: 44, _second: 42, _nano: 402000000 } } }  Run the code",
            "title": "BrainWallet usage"
        },
        {
            "location": "/documentation/wallet/#models",
            "text": "",
            "title": "Models"
        },
        {
            "location": "/documentation/wallet/#wallet",
            "text": "export enum WalletType {\n  SIMPLE,\n  BRAIN\n}\n\n/**\n * Wallet base model\n */\nexport declare abstract class Wallet {\n\n    /**\n     * The wallet's name\n     */\n    readonly name: string;\n\n    /**\n     * The wallet's network\n     */\n    readonly network: NetworkTypes;\n\n    /**\n     * The wallet's address\n     */\n    readonly address: Address;\n\n    /**\n     * The wallet's creation date\n     */\n    readonly creationDate: LocalDateTime;\n\n    /**\n     * Abstract open wallet method returning an account from current wallet.\n     * @param password\n     */\n    abstract open(password: Password): Account;\n\n    /**\n    * Given a WLT string, retusn the WalletType\n    * @param {string} wlt\n    * @returns {WalletType}\n    */\n    static walletTypeGivenWLT(wlt: string): WalletType;\n}",
            "title": "Wallet"
        },
        {
            "location": "/documentation/wallet/#password",
            "text": "/**\n * Password model\n */\nexport declare class Password {\n\n    /**\n     * Password value\n     */\n    readonly value: string;\n\n    /**\n     * Create a password with at least 8 characters\n     * @param password\n     */\n    constructor(password: string);\n}",
            "title": "Password"
        },
        {
            "location": "/documentation/wallet/#brainpassword",
            "text": "/**\n * Brain password is an extended version of Password. With the brain password we derive the private key in BrainWallets.\n */\nexport declare class BrainPassword extends Password {\n\n    /**\n     * Constructor\n     * @param password - password must be secure, the password must be at least a 12 random words password.\n     */\n    constructor(password: string);\n}",
            "title": "BrainPassword"
        },
        {
            "location": "/documentation/wallet/#encryptedprivatekey",
            "text": "/**\n * EncryptedPrivateKey model\n */\nexport declare class EncryptedPrivateKey {\n\n    /**\n     * Encrypted private key data\n     */\n    readonly encryptedKey: string;\n\n    /**\n     * Initialization vector used in the decrypt process\n     */\n    readonly iv: string;\n}",
            "title": "EncryptedPrivateKey"
        },
        {
            "location": "/documentation/service/",
            "text": "AccountOwnedMosaicsService\n\n\nDefinition\n\n\n/**\n * Service to get account owned mosaics\n */\nexport declare class AccountOwnedMosaicsService {\n\n    /**\n     * accountHttp\n     */\n    accountHttp: AccountHttp;\n\n    /**\n     * mosaicHttp\n     */\n    mosaicHttp: MosaicHttp;\n\n    /**\n     * constructor\n     * @param accountHttp\n     * @param mosaicHttp\n     */\n    constructor(accountHttp: AccountHttp, mosaicHttp: MosaicHttp);\n\n    /**\n     * Account owned mosaics definitions\n     * @param address\n     * @returns {Observable<MosaicDefinition[]>}\n     */\n    fromAddress(address: Address): Observable<MosaicDefinition[]>;\n}\n\n\n\n\n\nUsage\n\n\nimport {NEMLibrary, NetworkTypes, Address, AccountOwnedMosaicsService, AccountHttp, MosaicHttp} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet address = new Address(\"\");\nlet accountOwnedMosaics = new AccountOwnedMosaicsService(new AccountHttp(), new MosaicHttp());\naccountOwnedMosaics.fromAddress(address).subscribe(mosaics => {\n    console.log(mosaics);\n});\n\n\n\n\nOutput:\n\n\n[ MosaicDefinition {\n    creator: \n     PublicAccount {\n       address: [Object],\n       publicKey: '34f510bc0173a1b65a0531e2fbb65b6db764234842d89b905e3071c4732ca3fd' },\n    id: MosaicId { namespaceId: 'country.cat', name: 'patufet' },\n    description: 'patufet coin',\n    properties: \n     MosaicProperties {\n       initialSupply: 7000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: undefined,\n    metaId: 319 },\n  MosaicDefinition {\n    creator: \n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' },\n    description: 'description',\n    properties: \n     MosaicProperties {\n       initialSupply: 100000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 386 }]\n\n\n\n\nRun the code\n\n\nMosaicService\n\n\nDefinition\n\n\n/**\n * Mosaic service\n */\nexport declare class MosaicService {\n    /**\n     * mosaicHttp\n     */\n    private mosaicHttp;\n    /**\n     * constructor\n     * @param mosaicHttp\n     */\n    constructor(mosaicHttp: MosaicHttp);\n    /**\n     * Calculate levy for a given mosaicTransferable\n     * @param mosaicTransferable\n     * @returns {any}\n     */\n    calculateLevy(mosaicTransferable: MosaicTransferable): Observable<number>;\n}\n\n\n\n\nUsage\n\n\nimport {NEMLibrary, NetworkTypes, MosaicId, MosaicLevy, MosaicLevyType, Address, MosaicTransferable, MosaicHttp, MosaicProperties, MosaicService} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet levyMosaicId = new MosaicId(\"server\", \"testmosaic\");\nlet levy = new MosaicLevy(MosaicLevyType.Percentil, new Address(\"\"), levyMosaicId, 5);\nlet mosaicTransferable = new MosaicTransferable(new MosaicId(\"server\", \"mosaic\"), new MosaicProperties(0, 10000000, true, false), 100000, levy);\n\nlet mosaicService = new MosaicService(new MosaicHttp());\nmosaicService.calculateLevy(mosaicTransferable).subscribe(levy => {\n    console.log(levy);\n});\n\n\n\n\nOutput:\n\n\n5\n\n\n\n\nRun the code\n\n\nQRService\n\n\nDefinition\n\n\nexport declare class QRService {\n    /**\n     * Generates the QR text from the wallet\n     * @returns {string}\n     */\n    generateWalletQRText(password: Password, wallet: Wallet): string;\n    /**\n     * Decrypt the private key from the QR text\n     * @param password password\n     * @param qrWalletText Object generated by generateWalletQRText method\n     * @return Decrypted private key\n     */\n    decryptWalletQRText(password: Password, qrWalletText: QRWalletText): string;\n    /**\n     * Generates the QR text from an address\n     * @returns {string}\n     */\n    generateAddressQRText(address: Address): string;\n    /**\n     * Decrypt the address from the QR text\n     * @param qrAddressText Object generated by generateAddressQRText method\n     * @return Address\n     */\n    decryptAddressQRText(qrAddressText: QRAddressText): Address;\n    /**\n     * Generates the QR text from a transaction\n     * @returns {string}\n     */\n    generateTransactionQRText(recipientAddress: Address, amount: number, msg: string): string;\n    /**\n     * Decrypt the transaction from the QR text\n     * @param qrTransactionText Object generated by generateTransactionQRText method\n     * @return TransferTransaction\n     */\n    decryptTrasactionQRText(qrTransactionText: QRTransactionText): TransferTransaction;\n}",
            "title": "Service"
        },
        {
            "location": "/documentation/service/#accountownedmosaicsservice",
            "text": "Definition  /**\n * Service to get account owned mosaics\n */\nexport declare class AccountOwnedMosaicsService {\n\n    /**\n     * accountHttp\n     */\n    accountHttp: AccountHttp;\n\n    /**\n     * mosaicHttp\n     */\n    mosaicHttp: MosaicHttp;\n\n    /**\n     * constructor\n     * @param accountHttp\n     * @param mosaicHttp\n     */\n    constructor(accountHttp: AccountHttp, mosaicHttp: MosaicHttp);\n\n    /**\n     * Account owned mosaics definitions\n     * @param address\n     * @returns {Observable<MosaicDefinition[]>}\n     */\n    fromAddress(address: Address): Observable<MosaicDefinition[]>;\n}  Usage  import {NEMLibrary, NetworkTypes, Address, AccountOwnedMosaicsService, AccountHttp, MosaicHttp} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet address = new Address(\"\");\nlet accountOwnedMosaics = new AccountOwnedMosaicsService(new AccountHttp(), new MosaicHttp());\naccountOwnedMosaics.fromAddress(address).subscribe(mosaics => {\n    console.log(mosaics);\n});  Output:  [ MosaicDefinition {\n    creator: \n     PublicAccount {\n       address: [Object],\n       publicKey: '34f510bc0173a1b65a0531e2fbb65b6db764234842d89b905e3071c4732ca3fd' },\n    id: MosaicId { namespaceId: 'country.cat', name: 'patufet' },\n    description: 'patufet coin',\n    properties: \n     MosaicProperties {\n       initialSupply: 7000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: undefined,\n    metaId: 319 },\n  MosaicDefinition {\n    creator: \n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' },\n    description: 'description',\n    properties: \n     MosaicProperties {\n       initialSupply: 100000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 386 }]  Run the code",
            "title": "AccountOwnedMosaicsService"
        },
        {
            "location": "/documentation/service/#mosaicservice",
            "text": "Definition  /**\n * Mosaic service\n */\nexport declare class MosaicService {\n    /**\n     * mosaicHttp\n     */\n    private mosaicHttp;\n    /**\n     * constructor\n     * @param mosaicHttp\n     */\n    constructor(mosaicHttp: MosaicHttp);\n    /**\n     * Calculate levy for a given mosaicTransferable\n     * @param mosaicTransferable\n     * @returns {any}\n     */\n    calculateLevy(mosaicTransferable: MosaicTransferable): Observable<number>;\n}  Usage  import {NEMLibrary, NetworkTypes, MosaicId, MosaicLevy, MosaicLevyType, Address, MosaicTransferable, MosaicHttp, MosaicProperties, MosaicService} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet levyMosaicId = new MosaicId(\"server\", \"testmosaic\");\nlet levy = new MosaicLevy(MosaicLevyType.Percentil, new Address(\"\"), levyMosaicId, 5);\nlet mosaicTransferable = new MosaicTransferable(new MosaicId(\"server\", \"mosaic\"), new MosaicProperties(0, 10000000, true, false), 100000, levy);\n\nlet mosaicService = new MosaicService(new MosaicHttp());\nmosaicService.calculateLevy(mosaicTransferable).subscribe(levy => {\n    console.log(levy);\n});  Output:  5  Run the code",
            "title": "MosaicService"
        },
        {
            "location": "/documentation/service/#qrservice",
            "text": "Definition  export declare class QRService {\n    /**\n     * Generates the QR text from the wallet\n     * @returns {string}\n     */\n    generateWalletQRText(password: Password, wallet: Wallet): string;\n    /**\n     * Decrypt the private key from the QR text\n     * @param password password\n     * @param qrWalletText Object generated by generateWalletQRText method\n     * @return Decrypted private key\n     */\n    decryptWalletQRText(password: Password, qrWalletText: QRWalletText): string;\n    /**\n     * Generates the QR text from an address\n     * @returns {string}\n     */\n    generateAddressQRText(address: Address): string;\n    /**\n     * Decrypt the address from the QR text\n     * @param qrAddressText Object generated by generateAddressQRText method\n     * @return Address\n     */\n    decryptAddressQRText(qrAddressText: QRAddressText): Address;\n    /**\n     * Generates the QR text from a transaction\n     * @returns {string}\n     */\n    generateTransactionQRText(recipientAddress: Address, amount: number, msg: string): string;\n    /**\n     * Decrypt the transaction from the QR text\n     * @param qrTransactionText Object generated by generateTransactionQRText method\n     * @return TransferTransaction\n     */\n    decryptTrasactionQRText(qrTransactionText: QRTransactionText): TransferTransaction;\n}",
            "title": "QRService"
        },
        {
            "location": "/documentation/error/",
            "text": "Errors\n\n\nIn case NIS encounters an error while processing a request it returns an error.\n\n\nThis chapter describes the error messages that can be returned from NIS.\n\n\nError messages\n\n\nRequest method 'GET' not supported\n\n\nThe request was performed as a GET request but was expected to be a POST request.\n\n\naddress must be valid:\n\n\nAt least one address supplied in the request was invalid. Addresses are validated before processing a request. If validation fails, an error containing this message is returned.\n\n\nFAILURE_SERVER_LIMIT:\n\n\nThe number of accounts that are allowed to harvest on NIS was exceeded.\n\n\nJSON Object was expected:\n\n\nA parameter is missing in the request.\n\n\nFAILURE_UNKNOWN_ACCOUNT:\n\n\nThe account specified in the request is not known.\n\n\nblock not found in the db\n\n\nThe block that was requested could not be found in the database.\n\n\nheight must be positive\n\n\nThe block height supplied in a request was zero or negative. Block height must always be greater than zero.\n\n\nnetwork has not been booted yet\n\n\nMost requests need the node that should answer the request to be already booted. If node is not booted yet, this error message will be returned.\n\n\nnetwork boot was already attempted\n\n\nIt was attempted to boot an already booted node. Nodes can only be booted once.\n\n\nremote 123.45.67.89 attempted to call local /node/boot\n\n\nIt was attempted to boot a remote node. Only local node can be booted.\n\n\nFAILURE_PAST_DEADLINE\n\n\nThe deadline for the entity has already expired. The deadline must always lie in the future.\n\n\nFAILURE_FUTURE_DEADLINE\n\n\nThe deadline lies too far in the future. Deadlines are only allowed to lie up to 24 hours in the future.\n\n\nFAILURE_INSUFFICIENT_BALANCE\n\n\nThe account does not have enough funds.\n\n\nFAILURE_MESSAGE_TOO_LARGE\n\n\nThe message for the transaction exceeds the limit of 512 bytes.\n\n\nFAILURE_HASH_EXISTS\n\n\nThe hash of the entity already exists either in the cache or in the database.\n\n\nFAILURE_SIGNATURE_NOT_VERIFIABLE\n\n\nThe signature of the entity failed upon verification.\n\n\nFAILURE_TIMESTAMP_TOO_FAR_IN_PAST\n\n\nThe timestamp of the entity lies to far in the past.\n\n\nFAILURE_TIMESTAMP_TOO_FAR_IN_FUTURE\n\n\nThe timestamp of the entity lies too far in the future.\n\n\nFAILURE_INELIGIBLE_BLOCK_SIGNER\n\n\nValidation failed because the block had an ineligible signer. This usually occurs when remote harvesting is in the process of being activated or deactivated.\n\n\nFAILURE_ENTITY_UNUSABLE_OUT_OF_SYNC\n\n\nThe entity cannot be processed because the remote node is out of synchronization with the local node. This happens frequently when a node is not fully synchronized and receives a new block with much larger height than its own chain.\n\n\nFAILURE_INSUFFICIENT_FEE\n\n\nThe supplied transaction has an insufficient fee.\n\n\nFAILURE_NEMESIS_ACCOUNT_TRANSACTION_AFTER_NEMESIS_BLOCK\n\n\nThe supplied transaction has the nemesis account as sender and cannot be included in a normal block.\n\n\nFAILURE_TRANSACTION_CACHE_TOO_FULL\n\n\nThe transaction was rejected because the transaction cache is too full. This happens when an account tries to send too many transactions in a short time. To improve the chance that the transaction gets accepted you can try to raise the transaction fee.\n\n\nFAILURE_WRONG_NETWORK\n\n\nEntity was rejected because it has the wrong network specified.\n\n\nFAILURE_CANNOT_HARVEST_FROM_BLOCKED_ACCOUNT\n\n\nBlock was rejected because it was harvested by a blocked account (typically a reserved NEM fund).\n\n\nFAILURE_DESTINATION_ACCOUNT_HAS_NONZERO_BALANCE\n\n\nThe importance cannot be transferred to an account with nonzero balance.\n\n\nFAILURE_IMPORTANCE_TRANSFER_IN_PROGRESS\n\n\nThe transaction is conflicting because there is already a transfer of importance in progress.\n\n\nFAILURE_IMPORTANCE_TRANSFER_NEEDS_TO_BE_DEACTIVATED\n\n\nThe transaction is conflicting because the importance was already transferred.\n\n\nFAILURE_IMPORTANCE_TRANSFER_IS_NOT_ACTIVE\n\n\nThe transaction is conflicting because no importance has been transferred yet.\n\n\nFAILURE_TRANSACTION_NOT_ALLOWED_FOR_REMOTE\n\n\nValidation failed because transaction is using remote account in an improper way.\n\n\nFAILURE_MULTISIG_NOT_A_COSIGNER\n\n\nThe multisig transaction was rejected because the signer of the transaction is not a cosignatory of the sender account of the inner transaction.\n\n\nFAILURE_MULTISIG_INVALID_COSIGNERS\n\n\nValidation failed because the cosignatories attached to a multisig transaction were invalid.\n\n\nFAILURE_MULTISIG_NO_MATCHING_MULTISIG\n\n\nThe signature transaction was rejected because the corresponding multisig transaction was not found.\n\n\nFAILURE_TRANSACTION_NOT_ALLOWED_FOR_MULTISIG\n\n\nThe transaction was rejected because the signer is a multisig account. Multisig accounts are not allowed to initiate any transaction (only cosignatories are allowed to do so).\n\n\nFAILURE_MULTISIG_ALREADY_A_COSIGNER\n\n\nThe transaction was rejected because it tried to add a cosignatory to a multisig account which already has this cosignatory.\n\n\nFAILURE_MULTISIG_MODIFICATION_MULTIPLE_DELETES\n\n\nThe transaction was rejected because it tried to remove multiple cosignatories at once. It is only allowed to remove one cosignatory at a time.\n\n\nFAILURE_MULTISIG_MODIFICATION_REDUNDANT_MODIFICATIONS\n\n\nThe transaction was rejected because it tried to do redundant modifications. This can happen if a transaction tries to add the same cosignatory two time.\n\n\nFAILURE_CONFLICTING_MULTISIG_MODIFICATION\n\n\nThe transaction was rejected because it contained conflicting modifications to a multisig account. This can for instance happen if a transaction tries to add and then delete the same cosignatory.\n\n\nFAILURE_TOO_MANY_MULTISIG_COSIGNERS\n\n\nThe transaction was rejected because it contains too many cosignatories. The maximum number of cosignatories allowed for a multisig account is 32.\n\n\nFAILURE_MULTISIG_ACCOUNT_CANNOT_BE_COSIGNER\n\n\nValidation failed because a multisig modification would result in a multisig account being a cosigner.\n\n\nFAILURE_MULTISIG_MIN_COSIGNATORIES_OUT_OF_RANGE\n\n\nValidation failed because the minimum number of cosignatories is negative or larger than the number of cosignatories.\n\n\nFAILURE_NAMESPACE_UNKNOWN\n\n\nValidation failed because the namespace is unknown.\n\n\nFAILURE_NAMESPACE_ALREADY_EXISTS\n\n\nValidation failed because the namespace already exists.\n\n\nFAILURE_NAMESPACE_EXPIRED\n\n\nValidation failed because the namespace has expired.\n\n\nFAILURE_NAMESPACE_OWNER_CONFLICT\n\n\nValidation failed because the transaction signer is not the owner of the namespace.\n\n\nFAILURE_NAMESPACE_INVALID_NAME(\n\n\nValidation failed because the name for the namespace is invalid.\n\n\nFAILURE_NAMESPACE_INVALID_RENTAL_FEE_SINK\n\n\nValidation failed because the specified namespace rental fee sink is invalid.\n\n\nFAILURE_NAMESPACE_INVALID_RENTAL_FEE\n\n\nValidation failed because the specified rental fee is invalid.\n\n\nFAILURE_NAMESPACE_PROVISION_TOO_EARLY\n\n\nValidation failed because the provision was done too early.\n\n\nFAILURE_NAMESPACE_NOT_CLAIMABLE\n\n\nValidation failed because the namespace contains a reserved part and is not claimable.\n\n\nFAILURE_MOSAIC_UNKNOWN\n\n\nValidation failed because the mosaic is unknown.\n\n\nFAILURE_MOSAIC_MODIFICATION_NOT_ALLOWED\n\n\nValidation failed because the modification of the existing mosaic is not allowed.\n\n\nFAILURE_MOSAIC_CREATOR_CONFLICT\n\n\nValidation failed because the transaction signer is not the creator of the mosaic.\n\n\nFAILURE_MOSAIC_SUPPLY_IMMUTABLE\n\n\nValidation failed because the mosaic supply is immutable.\n\n\nFAILURE_MOSAIC_MAX_SUPPLY_EXCEEDED\n\n\nValidation failed because the maximum overall mosaic supply is exceeded.\n\n\nFAILURE_MOSAIC_SUPPLY_NEGATIVE\n\n\nValidation failed because the resulting mosaic supply would be negative.\n\n\nFAILURE_MOSAIC_NOT_TRANSFERABLE\n\n\nValidation failed because the mosaic is not transferable.\n\n\nFAILURE_MOSAIC_DIVISIBILITY_VIOLATED\n\n\nValidation failed because the divisibility of the mosaic is violated.\n\n\nFAILURE_CONFLICTING_MOSAIC_CREATION\n\n\nValidation failed because conflicting mosaic creation is present.\n\n\nFAILURE_MOSAIC_INVALID_CREATION_FEE_SINK\n\n\nValidation failed because the mosaic creation fee sink is invalid.\n\n\nFAILURE_MOSAIC_INVALID_CREATION_FEE\n\n\nValidation failed because the specified creation fee is invalid.\n\n\nFAILURE_TOO_MANY_MOSAIC_TRANSFERS\n\n\nValidation failed because a transfer transaction had too many attached mosaic transfers.",
            "title": "Error"
        },
        {
            "location": "/documentation/error/#errors",
            "text": "In case NIS encounters an error while processing a request it returns an error.  This chapter describes the error messages that can be returned from NIS.",
            "title": "Errors"
        },
        {
            "location": "/documentation/error/#error-messages",
            "text": "Request method 'GET' not supported  The request was performed as a GET request but was expected to be a POST request.  address must be valid:  At least one address supplied in the request was invalid. Addresses are validated before processing a request. If validation fails, an error containing this message is returned.  FAILURE_SERVER_LIMIT:  The number of accounts that are allowed to harvest on NIS was exceeded.  JSON Object was expected:  A parameter is missing in the request.  FAILURE_UNKNOWN_ACCOUNT:  The account specified in the request is not known.  block not found in the db  The block that was requested could not be found in the database.  height must be positive  The block height supplied in a request was zero or negative. Block height must always be greater than zero.  network has not been booted yet  Most requests need the node that should answer the request to be already booted. If node is not booted yet, this error message will be returned.  network boot was already attempted  It was attempted to boot an already booted node. Nodes can only be booted once.  remote 123.45.67.89 attempted to call local /node/boot  It was attempted to boot a remote node. Only local node can be booted.  FAILURE_PAST_DEADLINE  The deadline for the entity has already expired. The deadline must always lie in the future.  FAILURE_FUTURE_DEADLINE  The deadline lies too far in the future. Deadlines are only allowed to lie up to 24 hours in the future.  FAILURE_INSUFFICIENT_BALANCE  The account does not have enough funds.  FAILURE_MESSAGE_TOO_LARGE  The message for the transaction exceeds the limit of 512 bytes.  FAILURE_HASH_EXISTS  The hash of the entity already exists either in the cache or in the database.  FAILURE_SIGNATURE_NOT_VERIFIABLE  The signature of the entity failed upon verification.  FAILURE_TIMESTAMP_TOO_FAR_IN_PAST  The timestamp of the entity lies to far in the past.  FAILURE_TIMESTAMP_TOO_FAR_IN_FUTURE  The timestamp of the entity lies too far in the future.  FAILURE_INELIGIBLE_BLOCK_SIGNER  Validation failed because the block had an ineligible signer. This usually occurs when remote harvesting is in the process of being activated or deactivated.  FAILURE_ENTITY_UNUSABLE_OUT_OF_SYNC  The entity cannot be processed because the remote node is out of synchronization with the local node. This happens frequently when a node is not fully synchronized and receives a new block with much larger height than its own chain.  FAILURE_INSUFFICIENT_FEE  The supplied transaction has an insufficient fee.  FAILURE_NEMESIS_ACCOUNT_TRANSACTION_AFTER_NEMESIS_BLOCK  The supplied transaction has the nemesis account as sender and cannot be included in a normal block.  FAILURE_TRANSACTION_CACHE_TOO_FULL  The transaction was rejected because the transaction cache is too full. This happens when an account tries to send too many transactions in a short time. To improve the chance that the transaction gets accepted you can try to raise the transaction fee.  FAILURE_WRONG_NETWORK  Entity was rejected because it has the wrong network specified.  FAILURE_CANNOT_HARVEST_FROM_BLOCKED_ACCOUNT  Block was rejected because it was harvested by a blocked account (typically a reserved NEM fund).  FAILURE_DESTINATION_ACCOUNT_HAS_NONZERO_BALANCE  The importance cannot be transferred to an account with nonzero balance.  FAILURE_IMPORTANCE_TRANSFER_IN_PROGRESS  The transaction is conflicting because there is already a transfer of importance in progress.  FAILURE_IMPORTANCE_TRANSFER_NEEDS_TO_BE_DEACTIVATED  The transaction is conflicting because the importance was already transferred.  FAILURE_IMPORTANCE_TRANSFER_IS_NOT_ACTIVE  The transaction is conflicting because no importance has been transferred yet.  FAILURE_TRANSACTION_NOT_ALLOWED_FOR_REMOTE  Validation failed because transaction is using remote account in an improper way.  FAILURE_MULTISIG_NOT_A_COSIGNER  The multisig transaction was rejected because the signer of the transaction is not a cosignatory of the sender account of the inner transaction.  FAILURE_MULTISIG_INVALID_COSIGNERS  Validation failed because the cosignatories attached to a multisig transaction were invalid.  FAILURE_MULTISIG_NO_MATCHING_MULTISIG  The signature transaction was rejected because the corresponding multisig transaction was not found.  FAILURE_TRANSACTION_NOT_ALLOWED_FOR_MULTISIG  The transaction was rejected because the signer is a multisig account. Multisig accounts are not allowed to initiate any transaction (only cosignatories are allowed to do so).  FAILURE_MULTISIG_ALREADY_A_COSIGNER  The transaction was rejected because it tried to add a cosignatory to a multisig account which already has this cosignatory.  FAILURE_MULTISIG_MODIFICATION_MULTIPLE_DELETES  The transaction was rejected because it tried to remove multiple cosignatories at once. It is only allowed to remove one cosignatory at a time.  FAILURE_MULTISIG_MODIFICATION_REDUNDANT_MODIFICATIONS  The transaction was rejected because it tried to do redundant modifications. This can happen if a transaction tries to add the same cosignatory two time.  FAILURE_CONFLICTING_MULTISIG_MODIFICATION  The transaction was rejected because it contained conflicting modifications to a multisig account. This can for instance happen if a transaction tries to add and then delete the same cosignatory.  FAILURE_TOO_MANY_MULTISIG_COSIGNERS  The transaction was rejected because it contains too many cosignatories. The maximum number of cosignatories allowed for a multisig account is 32.  FAILURE_MULTISIG_ACCOUNT_CANNOT_BE_COSIGNER  Validation failed because a multisig modification would result in a multisig account being a cosigner.  FAILURE_MULTISIG_MIN_COSIGNATORIES_OUT_OF_RANGE  Validation failed because the minimum number of cosignatories is negative or larger than the number of cosignatories.  FAILURE_NAMESPACE_UNKNOWN  Validation failed because the namespace is unknown.  FAILURE_NAMESPACE_ALREADY_EXISTS  Validation failed because the namespace already exists.  FAILURE_NAMESPACE_EXPIRED  Validation failed because the namespace has expired.  FAILURE_NAMESPACE_OWNER_CONFLICT  Validation failed because the transaction signer is not the owner of the namespace.  FAILURE_NAMESPACE_INVALID_NAME(  Validation failed because the name for the namespace is invalid.  FAILURE_NAMESPACE_INVALID_RENTAL_FEE_SINK  Validation failed because the specified namespace rental fee sink is invalid.  FAILURE_NAMESPACE_INVALID_RENTAL_FEE  Validation failed because the specified rental fee is invalid.  FAILURE_NAMESPACE_PROVISION_TOO_EARLY  Validation failed because the provision was done too early.  FAILURE_NAMESPACE_NOT_CLAIMABLE  Validation failed because the namespace contains a reserved part and is not claimable.  FAILURE_MOSAIC_UNKNOWN  Validation failed because the mosaic is unknown.  FAILURE_MOSAIC_MODIFICATION_NOT_ALLOWED  Validation failed because the modification of the existing mosaic is not allowed.  FAILURE_MOSAIC_CREATOR_CONFLICT  Validation failed because the transaction signer is not the creator of the mosaic.  FAILURE_MOSAIC_SUPPLY_IMMUTABLE  Validation failed because the mosaic supply is immutable.  FAILURE_MOSAIC_MAX_SUPPLY_EXCEEDED  Validation failed because the maximum overall mosaic supply is exceeded.  FAILURE_MOSAIC_SUPPLY_NEGATIVE  Validation failed because the resulting mosaic supply would be negative.  FAILURE_MOSAIC_NOT_TRANSFERABLE  Validation failed because the mosaic is not transferable.  FAILURE_MOSAIC_DIVISIBILITY_VIOLATED  Validation failed because the divisibility of the mosaic is violated.  FAILURE_CONFLICTING_MOSAIC_CREATION  Validation failed because conflicting mosaic creation is present.  FAILURE_MOSAIC_INVALID_CREATION_FEE_SINK  Validation failed because the mosaic creation fee sink is invalid.  FAILURE_MOSAIC_INVALID_CREATION_FEE  Validation failed because the specified creation fee is invalid.  FAILURE_TOO_MANY_MOSAIC_TRANSFERS  Validation failed because a transfer transaction had too many attached mosaic transfers.",
            "title": "Error messages"
        },
        {
            "location": "/guide/overview/",
            "text": "Working examples\n\n\nThe guide section shows some \nHow to\n use the NEM Library. \n\n\nYou can find the code examples pre-configured and ready to use at \ngithub.com/aleixmorgadas/nem-library-examples\n\n\nTimeWindow concept\n\n\nThe TimeWindow concept is related with the Transactions. A transaction has as \nTimeWindow\n where it can be included in a block,\nonce the deadline of the TimeWindow is after the Node timestamp, the transaction is rejected.",
            "title": "Overview"
        },
        {
            "location": "/guide/overview/#working-examples",
            "text": "The guide section shows some  How to  use the NEM Library.   You can find the code examples pre-configured and ready to use at  github.com/aleixmorgadas/nem-library-examples",
            "title": "Working examples"
        },
        {
            "location": "/guide/overview/#timewindow-concept",
            "text": "The TimeWindow concept is related with the Transactions. A transaction has as  TimeWindow  where it can be included in a block,\nonce the deadline of the TimeWindow is after the Node timestamp, the transaction is rejected.",
            "title": "TimeWindow concept"
        },
        {
            "location": "/guide/account/",
            "text": "How to receive all transactions for an account\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.allTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .subscribe(allTransactions => {\n       console.log(allTransactions);\n    });\n\n\n\n\nSource code\n\n\n How to receive all transactions for an account paginated\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport { AccountHttp, Address, NEMLibrary, NetworkTypes } from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\nlet address = new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\");\nlet accountHttp = new AccountHttp();\n\nlet pageable = accountHttp.allTransactionsPaginated(address);\n\npageable.subscribe(transactions => {\n    // do something with the info\n});\n\npageable.nextPage(); // Fetch the nexts 25 transactions\n\n\n\n\nSource code\n\n\nHow to receive incoming transactions for an account\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.incomingTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .subscribe(x => {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to receive outgoing transactions for an account\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.outgoingTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .subscribe(x => {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to get the unconfirmed transactions for an account\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.unconfirmedTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .subscribe(x => {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to get Account harvested blocks info paginated\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.getAccountImportances()\n    .subscribe(x => {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to get Account Importances\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.getAccountImportances()\n    .subscribe(x => {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to convert a Normal Account into Multisig Account\n\n\nimport {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM, MultisigAggregateModificationTransaction,\n    CosignatoryModification, CosignatoryModificationAction\n} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp();\n\n// Replace with the private key of the account that you want to convert into multisig\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst cosignatory1PublicKey: string = process.env.COSIGNATORY_1_PUBLIC_KEY;\nconst cosignatory2PublicKey: string = process.env.COSIGNATORY_2_PUBLIC_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst cosignatory1 = PublicAccount.createWithPublicKey(cosignatory1PublicKey);\nconst cosignatory2 = PublicAccount.createWithPublicKey(cosignatory2PublicKey);\n\nconst convertIntoMultisigTransaction = MultisigAggregateModificationTransaction.create(\n    TimeWindow.createWithDeadline(),\n    [\n        new CosignatoryModification(cosignatory1, CosignatoryModificationAction.ADD),\n        new CosignatoryModification(cosignatory2, CosignatoryModificationAction.ADD),\n    ],\n    2\n);\n\nconst signedTransaction = account.signTransaction(convertIntoMultisigTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe(x => console.log(x));\n\n\n\n\nSource code\n\n\nHow to enable harvesting\n\n\nimport {\n    NEMLibrary, NetworkTypes, Account, TimeWindow,\n    PublicAccount, TransactionHttp, ImportanceMode, ImportanceTransferTransaction, AccountHttp\n} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst delegateAccountHarvestingPrivateKey: string = process.env.HARVESTING_PRIVATE_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\nconst delegatedAccount = Account.createWithPublicKey(delegateAccountHarvestingPrivateKey);\n\nconst importanceTransferTransaction = ImportanceTransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    ImportanceMode.Activate,\n    PublicAccount.createWithPublicKey(delegatedAccount.publicKey)\n);\n\nconst signedTransaction = account.signTransaction(importanceTransferTransaction);\n\nconst transactionHttp = new TransactionHttp();\ntransactionHttp.announceTransaction(signedTransaction).subscribe(x => console.log(x));\n\n// Wait aproximately 6h for you delegated account to be active\n\nconst accountHttp = new AccountHttp();\n\n// Testnet supernode\nconst supernodeDomain = \"188.68.50.161\";\n\naccountHttp.unlockHarvesting(supernodeDomain, delegateAccountHarvestingPrivateKey).subscribe(success => console.log(success));\n\n\n\n\n\nSource code\n\n\nHow receive all transactions\n\n\nThe sample shows how to fetch all the transactions for an account, emulating a loop or a recursive function.\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\nconst address = new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\");\nlet pagedTransactions = accountHttp.allTransactionsPaginated(address, undefined, 100);\nlet time = 0;\npagedTransactions.subscribe(x => {\n    console.log(\"TIME \", ++time);\n    console.log(\"transactions size\", x.length);\n    // Fetch the next 100 transactions\n    pagedTransactions.nextPage();\n}, err => {\n    console.log(\"error\");\n}, () => {\n    // when this lambda is called, it means all transactions have been fetched\n    console.log(\"complete\");\n});\n\n\n\n\nSource code\n\n\nHow to sign unconfirmed multisig transactions\n\n\n/**\n * nem-library 0.3.7\n */\n\nimport { AccountHttp, TransactionHttp, Address, NEMLibrary, NetworkTypes, Account, Transaction, TransactionTypes, MultisigTransaction, MultisigSignatureTransaction, TimeWindow, PublicAccount } from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\nlet accountHttp = new AccountHttp();\nlet transactionHttp = new TransactionHttp();\n\nlet account = Account.createWithPrivateKey(\"\");\n\naccountHttp.unconfirmedTransactions(account.address)\n    // Convert result Transaction[] into Transaction\n    .flatMap(x => x )\n    // just return the Multisig Transactions\n    .filter(transaction => transaction.type == TransactionTypes.MULTISIG)\n    // Convert the multisig transaction into MultisigSignatureTransaction\n    .map((transaction: MultisigTransaction): MultisigSignatureTransaction => MultisigSignatureTransaction.create(\n        TimeWindow.createWithDeadline(),\n        transaction.otherTransaction.signer!.address,\n        transaction.hashData!\n    ))\n    // Sign the transaction\n    .map(transaction => account.signTransaction(transaction))\n    // announce the transaction to be included in a block\n    .flatMap(signedTransaction => transactionHttp.announceTransaction(signedTransaction))\n    .subscribe(result => {\n        // Listen the success\n        console.log(result);\n    }, err => {\n        // Know if something has gone wrong\n        console.error(err)\n    });\n\n\n\n\nSource code",
            "title": "Account"
        },
        {
            "location": "/guide/account/#how-to-receive-all-transactions-for-an-account",
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.allTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .subscribe(allTransactions => {\n       console.log(allTransactions);\n    });  Source code",
            "title": "How to receive all transactions for an account"
        },
        {
            "location": "/guide/account/#how-to-receive-incoming-transactions-for-an-account",
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.incomingTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .subscribe(x => {\n        console.log(x);\n    });  Source code",
            "title": "How to receive incoming transactions for an account"
        },
        {
            "location": "/guide/account/#how-to-receive-outgoing-transactions-for-an-account",
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.outgoingTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .subscribe(x => {\n        console.log(x);\n    });  Source code",
            "title": "How to receive outgoing transactions for an account"
        },
        {
            "location": "/guide/account/#how-to-get-the-unconfirmed-transactions-for-an-account",
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.unconfirmedTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .subscribe(x => {\n        console.log(x);\n    });  Source code",
            "title": "How to get the unconfirmed transactions for an account"
        },
        {
            "location": "/guide/account/#how-to-get-account-harvested-blocks-info-paginated",
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.getAccountImportances()\n    .subscribe(x => {\n        console.log(x);\n    });  Source code",
            "title": "How to get Account harvested blocks info paginated"
        },
        {
            "location": "/guide/account/#how-to-get-account-importances",
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.getAccountImportances()\n    .subscribe(x => {\n        console.log(x);\n    });  Source code",
            "title": "How to get Account Importances"
        },
        {
            "location": "/guide/account/#how-to-convert-a-normal-account-into-multisig-account",
            "text": "import {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM, MultisigAggregateModificationTransaction,\n    CosignatoryModification, CosignatoryModificationAction\n} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp();\n\n// Replace with the private key of the account that you want to convert into multisig\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst cosignatory1PublicKey: string = process.env.COSIGNATORY_1_PUBLIC_KEY;\nconst cosignatory2PublicKey: string = process.env.COSIGNATORY_2_PUBLIC_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst cosignatory1 = PublicAccount.createWithPublicKey(cosignatory1PublicKey);\nconst cosignatory2 = PublicAccount.createWithPublicKey(cosignatory2PublicKey);\n\nconst convertIntoMultisigTransaction = MultisigAggregateModificationTransaction.create(\n    TimeWindow.createWithDeadline(),\n    [\n        new CosignatoryModification(cosignatory1, CosignatoryModificationAction.ADD),\n        new CosignatoryModification(cosignatory2, CosignatoryModificationAction.ADD),\n    ],\n    2\n);\n\nconst signedTransaction = account.signTransaction(convertIntoMultisigTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe(x => console.log(x));  Source code",
            "title": "How to convert a Normal Account into Multisig Account"
        },
        {
            "location": "/guide/account/#how-to-enable-harvesting",
            "text": "import {\n    NEMLibrary, NetworkTypes, Account, TimeWindow,\n    PublicAccount, TransactionHttp, ImportanceMode, ImportanceTransferTransaction, AccountHttp\n} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst delegateAccountHarvestingPrivateKey: string = process.env.HARVESTING_PRIVATE_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\nconst delegatedAccount = Account.createWithPublicKey(delegateAccountHarvestingPrivateKey);\n\nconst importanceTransferTransaction = ImportanceTransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    ImportanceMode.Activate,\n    PublicAccount.createWithPublicKey(delegatedAccount.publicKey)\n);\n\nconst signedTransaction = account.signTransaction(importanceTransferTransaction);\n\nconst transactionHttp = new TransactionHttp();\ntransactionHttp.announceTransaction(signedTransaction).subscribe(x => console.log(x));\n\n// Wait aproximately 6h for you delegated account to be active\n\nconst accountHttp = new AccountHttp();\n\n// Testnet supernode\nconst supernodeDomain = \"188.68.50.161\";\n\naccountHttp.unlockHarvesting(supernodeDomain, delegateAccountHarvestingPrivateKey).subscribe(success => console.log(success));  Source code",
            "title": "How to enable harvesting"
        },
        {
            "location": "/guide/account/#how-receive-all-transactions",
            "text": "The sample shows how to fetch all the transactions for an account, emulating a loop or a recursive function.  import {AccountHttp, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\nconst address = new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\");\nlet pagedTransactions = accountHttp.allTransactionsPaginated(address, undefined, 100);\nlet time = 0;\npagedTransactions.subscribe(x => {\n    console.log(\"TIME \", ++time);\n    console.log(\"transactions size\", x.length);\n    // Fetch the next 100 transactions\n    pagedTransactions.nextPage();\n}, err => {\n    console.log(\"error\");\n}, () => {\n    // when this lambda is called, it means all transactions have been fetched\n    console.log(\"complete\");\n});  Source code",
            "title": "How receive all transactions"
        },
        {
            "location": "/guide/account/#how-to-sign-unconfirmed-multisig-transactions",
            "text": "/**\n * nem-library 0.3.7\n */\n\nimport { AccountHttp, TransactionHttp, Address, NEMLibrary, NetworkTypes, Account, Transaction, TransactionTypes, MultisigTransaction, MultisigSignatureTransaction, TimeWindow, PublicAccount } from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\nlet accountHttp = new AccountHttp();\nlet transactionHttp = new TransactionHttp();\n\nlet account = Account.createWithPrivateKey(\"\");\n\naccountHttp.unconfirmedTransactions(account.address)\n    // Convert result Transaction[] into Transaction\n    .flatMap(x => x )\n    // just return the Multisig Transactions\n    .filter(transaction => transaction.type == TransactionTypes.MULTISIG)\n    // Convert the multisig transaction into MultisigSignatureTransaction\n    .map((transaction: MultisigTransaction): MultisigSignatureTransaction => MultisigSignatureTransaction.create(\n        TimeWindow.createWithDeadline(),\n        transaction.otherTransaction.signer!.address,\n        transaction.hashData!\n    ))\n    // Sign the transaction\n    .map(transaction => account.signTransaction(transaction))\n    // announce the transaction to be included in a block\n    .flatMap(signedTransaction => transactionHttp.announceTransaction(signedTransaction))\n    .subscribe(result => {\n        // Listen the success\n        console.log(result);\n    }, err => {\n        // Know if something has gone wrong\n        console.error(err)\n    });  Source code",
            "title": "How to sign unconfirmed multisig transactions"
        },
        {
            "location": "/guide/transaction/",
            "text": "How to create a Transfer Transaction\n\n\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(2),\n    EmptyMessage\n);\n\n\n\n\nSource code\n\n\nHow to sign a Transaction\n\n\nimport {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM\n} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp();\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(2),\n    EmptyMessage\n);\n\nconst signedTransaction = account.signTransaction(transferTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));\n\n\n\n\nSource code\n\n\nHow to create a Transfer Transaction with a Message\n\n\n/**\n * nem-library 0.3.0\n */\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow,\n    XEM, PlainMessage\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(0),\n    PlainMessage.create(\"a transaction\")\n);\n\n\n\n\n\nSource code\n\n\nHow to create a Transfer Transaction with an Encrypted Message\n\n\n/**\n * nem-library 0.3.0\n */\nimport {\n    NEMLibrary, NetworkTypes, Account, TransferTransaction, TimeWindow,\n    TransactionHttp, XEM, PublicAccount\n} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp();\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst recipientPublicAccount = PublicAccount.createWithPublicKey(\"b254d8b2b00e1b1266eb54a6931cd7c1b0f307e41d9ebb01f025f4933758f0be\");\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst encryptedMessage = account.encryptMessage(\"a transaction\", recipientPublicAccount);\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    recipientPublicAccount.address,\n    new XEM(2),\n    encryptedMessage\n);\n\n\n\n\n\n\nSource code\n\n\nHow to create a Transfer Transaction with Mosaics\n\n\n/**\n * nem-library 0.5.1\n */\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow,\n    MosaicHttp, TransactionHttp, Account, EmptyMessage\n} from \"nem-library\";\nimport {Observable} from \"rxjs/Observable\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\n\nconst transactionHttp = new TransactionHttp();\nconst mosaicHttp = new MosaicHttp();\nconst account = Account.createWithPrivateKey(privateKey);\n\nObservable.from([\n    {namespace: \"mynamespace\", mosaic: \"mosaic1\", quantity: 10},\n    {namespace: \"mynamespace\", mosaic: \"mosaic2\", quantity: 10},\n    {namespace: \"mynamespace\", mosaic: \"mosaic3\", quantity: 10}\n]).flatMap(_ => mosaicHttp.getMosaicTransferableWithAmount(_.namespace, _.mosaic, _.quantity))\n    .toArray()\n    .map(mosaics => TransferTransaction.createWithMosaics(\n        TimeWindow.createWithDeadline(),\n        new Address(\"TBV7LE4TFDEMGVOON5MYOK2P7TU2KEKLMHOLHQT6\"),\n        mosaics,\n        EmptyMessage\n        )\n    )\n    .map(transaction => account.signTransaction(transaction))\n    .flatMap(signedTransaction => transactionHttp.announceTransaction(signedTransaction))\n    .subscribe(nemAnnounceResult => {\n        console.log(nemAnnounceResult);\n    })\n\n\n\n\n\nSource code\n\n\nHow to create a MultiSig Transaction\n\n\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, Transaction, XEM\n} from \"nem-library\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\n// Replace with the multisig account\nconst multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY;\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(2),\n    EmptyMessage\n);\n\nconst multisigTransaction: MultisigTransaction = MultisigTransaction.create(\n    TimeWindow.createWithDeadline(),\n    transferTransaction,\n    PublicAccount.createWithPublicKey(multisigAccountPublicKey)\n);\n\n\n\n\nSource code\n\n\nHow to filter Transactions by type\n\n\nimport {\n    AccountHttp, Address, MultisigTransaction, NEMLibrary, NetworkTypes, Transaction,\n    TransactionTypes\n} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.allTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .map((transactions: Transaction[]): MultisigTransaction[] => {\n        console.log(\">>>>>>>>>>>>\");\n        console.log(\"All Transactions\", transactions);\n        return <MultisigTransaction[]>transactions.filter(x => x.type == TransactionTypes.MULTISIG)\n    })\n    .subscribe((x: MultisigTransaction[]) => {\n        console.log(\"\\n\\n>>>>>>>>>>>>\");\n        console.log(\"Just Multisig\", x)\n    });\n\n\n\n\nSource code",
            "title": "Transaction"
        },
        {
            "location": "/guide/transaction/#how-to-create-a-transfer-transaction",
            "text": "import {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(2),\n    EmptyMessage\n);  Source code",
            "title": "How to create a Transfer Transaction"
        },
        {
            "location": "/guide/transaction/#how-to-sign-a-transaction",
            "text": "import {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM\n} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp();\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(2),\n    EmptyMessage\n);\n\nconst signedTransaction = account.signTransaction(transferTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));  Source code",
            "title": "How to sign a Transaction"
        },
        {
            "location": "/guide/transaction/#how-to-create-a-transfer-transaction-with-a-message",
            "text": "/**\n * nem-library 0.3.0\n */\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow,\n    XEM, PlainMessage\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(0),\n    PlainMessage.create(\"a transaction\")\n);  Source code",
            "title": "How to create a Transfer Transaction with a Message"
        },
        {
            "location": "/guide/transaction/#how-to-create-a-transfer-transaction-with-an-encrypted-message",
            "text": "/**\n * nem-library 0.3.0\n */\nimport {\n    NEMLibrary, NetworkTypes, Account, TransferTransaction, TimeWindow,\n    TransactionHttp, XEM, PublicAccount\n} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp();\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst recipientPublicAccount = PublicAccount.createWithPublicKey(\"b254d8b2b00e1b1266eb54a6931cd7c1b0f307e41d9ebb01f025f4933758f0be\");\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst encryptedMessage = account.encryptMessage(\"a transaction\", recipientPublicAccount);\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    recipientPublicAccount.address,\n    new XEM(2),\n    encryptedMessage\n);  Source code",
            "title": "How to create a Transfer Transaction with an Encrypted Message"
        },
        {
            "location": "/guide/transaction/#how-to-create-a-transfer-transaction-with-mosaics",
            "text": "/**\n * nem-library 0.5.1\n */\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow,\n    MosaicHttp, TransactionHttp, Account, EmptyMessage\n} from \"nem-library\";\nimport {Observable} from \"rxjs/Observable\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\n\nconst transactionHttp = new TransactionHttp();\nconst mosaicHttp = new MosaicHttp();\nconst account = Account.createWithPrivateKey(privateKey);\n\nObservable.from([\n    {namespace: \"mynamespace\", mosaic: \"mosaic1\", quantity: 10},\n    {namespace: \"mynamespace\", mosaic: \"mosaic2\", quantity: 10},\n    {namespace: \"mynamespace\", mosaic: \"mosaic3\", quantity: 10}\n]).flatMap(_ => mosaicHttp.getMosaicTransferableWithAmount(_.namespace, _.mosaic, _.quantity))\n    .toArray()\n    .map(mosaics => TransferTransaction.createWithMosaics(\n        TimeWindow.createWithDeadline(),\n        new Address(\"TBV7LE4TFDEMGVOON5MYOK2P7TU2KEKLMHOLHQT6\"),\n        mosaics,\n        EmptyMessage\n        )\n    )\n    .map(transaction => account.signTransaction(transaction))\n    .flatMap(signedTransaction => transactionHttp.announceTransaction(signedTransaction))\n    .subscribe(nemAnnounceResult => {\n        console.log(nemAnnounceResult);\n    })  Source code",
            "title": "How to create a Transfer Transaction with Mosaics"
        },
        {
            "location": "/guide/transaction/#how-to-create-a-multisig-transaction",
            "text": "import {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, Transaction, XEM\n} from \"nem-library\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\n// Replace with the multisig account\nconst multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY;\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"),\n    new XEM(2),\n    EmptyMessage\n);\n\nconst multisigTransaction: MultisigTransaction = MultisigTransaction.create(\n    TimeWindow.createWithDeadline(),\n    transferTransaction,\n    PublicAccount.createWithPublicKey(multisigAccountPublicKey)\n);  Source code",
            "title": "How to create a MultiSig Transaction"
        },
        {
            "location": "/guide/transaction/#how-to-filter-transactions-by-type",
            "text": "import {\n    AccountHttp, Address, MultisigTransaction, NEMLibrary, NetworkTypes, Transaction,\n    TransactionTypes\n} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.allTransactions(new Address(\"TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\"))\n    .map((transactions: Transaction[]): MultisigTransaction[] => {\n        console.log(\">>>>>>>>>>>>\");\n        console.log(\"All Transactions\", transactions);\n        return <MultisigTransaction[]>transactions.filter(x => x.type == TransactionTypes.MULTISIG)\n    })\n    .subscribe((x: MultisigTransaction[]) => {\n        console.log(\"\\n\\n>>>>>>>>>>>>\");\n        console.log(\"Just Multisig\", x)\n    });  Source code",
            "title": "How to filter Transactions by type"
        },
        {
            "location": "/guide/namespace/",
            "text": "How to create a Namespace\n\n\nimport{\n    NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp\n} from \"nem-library\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp();\n\nconst namespace = \"new-namespace\";\n\nconst provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create(\n    TimeWindow.createWithDeadline(),\n    namespace\n);\n\nconst signedTransaction = account.signTransaction(provisionNamespaceTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));\n\n\n\n\nSource code\n\n\nHow to create a Sub-Namespace\n\n\nimport {\n    NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp\n} from \"nem-library\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp();\n\nconst namespace = \"new-namespace\";\nconst subnamespace = \"subnamespace\";\n\nconst provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create(\n    TimeWindow.createWithDeadline(),\n    subnamespace,\n    namespace\n);\n\nconst signedTransaction = account.signTransaction(provisionNamespaceTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));\n\n\n\n\n\nSource code\n\n\nHow to know if a Namespace exists\n\n\nimport {\n    NEMLibrary, NetworkTypes, NamespaceHttp\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp();\nconst namespace = \"new-namespace\";\n\nnamespaceHttp.getNamespace(namespace).subscribe(namespace => console.log(namespace));\n\n\n\n\nSource code\n\n\nHow to know the owner of a Namespace\n\n\nimport {\n    NEMLibrary, NetworkTypes, NamespaceHttp\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp();\nconst namespace = \"new-namespace\";\n\nnamespaceHttp.getNamespace(namespace).subscribe(namespace => console.log(namespace));\n\n\n\n\n\nSource code",
            "title": "Namespace"
        },
        {
            "location": "/guide/namespace/#how-to-create-a-namespace",
            "text": "import{\n    NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp\n} from \"nem-library\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp();\n\nconst namespace = \"new-namespace\";\n\nconst provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create(\n    TimeWindow.createWithDeadline(),\n    namespace\n);\n\nconst signedTransaction = account.signTransaction(provisionNamespaceTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));  Source code",
            "title": "How to create a Namespace"
        },
        {
            "location": "/guide/namespace/#how-to-create-a-sub-namespace",
            "text": "import {\n    NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp\n} from \"nem-library\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp();\n\nconst namespace = \"new-namespace\";\nconst subnamespace = \"subnamespace\";\n\nconst provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create(\n    TimeWindow.createWithDeadline(),\n    subnamespace,\n    namespace\n);\n\nconst signedTransaction = account.signTransaction(provisionNamespaceTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));  Source code",
            "title": "How to create a Sub-Namespace"
        },
        {
            "location": "/guide/namespace/#how-to-know-if-a-namespace-exists",
            "text": "import {\n    NEMLibrary, NetworkTypes, NamespaceHttp\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp();\nconst namespace = \"new-namespace\";\n\nnamespaceHttp.getNamespace(namespace).subscribe(namespace => console.log(namespace));  Source code",
            "title": "How to know if a Namespace exists"
        },
        {
            "location": "/guide/namespace/#how-to-know-the-owner-of-a-namespace",
            "text": "import {\n    NEMLibrary, NetworkTypes, NamespaceHttp\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp();\nconst namespace = \"new-namespace\";\n\nnamespaceHttp.getNamespace(namespace).subscribe(namespace => console.log(namespace));  Source code",
            "title": "How to know the owner of a Namespace"
        },
        {
            "location": "/guide/mosaic/",
            "text": "How to create a Mosaic\n\n\nimport {\n    NEMLibrary, NetworkTypes, TimeWindow, Account, TransactionHttp,\n    MosaicDefinitionCreationTransaction, MosaicDefinition, PublicAccount, MosaicId, MosaicProperties, MosaicLevy,\n    MosaicLevyType\n} from \"nem-library\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp();\n\nconst mosaicDefinitionTransaction = MosaicDefinitionCreationTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new MosaicDefinition(\n        PublicAccount.createWithPublicKey(account.publicKey),\n        new MosaicId(\"new-namespace\", \"new-mosaic\"),\n        \"mosaic description\",\n        new MosaicProperties(0, 9000000, true, true),\n        new MosaicLevy(\n            MosaicLevyType.Percentil,\n            account.address,\n            new MosaicId(\"nem\", \"xem\"),\n            2\n        )\n    )\n);\n\nconst signedTransaction = account.signTransaction(mosaicDefinitionTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));\n\n\n\n\n\nSource code\n\n\nHow to get Namespace Mosaic Definitions\n\n\nimport {\n    NEMLibrary, NetworkTypes, MosaicHttp, TransactionTypes\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst mosaicHttp = new MosaicHttp();\nconst namespace = \"new-namespace\";\n\nmosaicHttp.getAllMosaicsGivenNamespace(namespace).subscribe(mosaicDefinitions => console.log(mosaicDefinitions));\n\n\n\n\nSource code",
            "title": "Mosaic"
        },
        {
            "location": "/guide/mosaic/#how-to-create-a-mosaic",
            "text": "import {\n    NEMLibrary, NetworkTypes, TimeWindow, Account, TransactionHttp,\n    MosaicDefinitionCreationTransaction, MosaicDefinition, PublicAccount, MosaicId, MosaicProperties, MosaicLevy,\n    MosaicLevyType\n} from \"nem-library\";\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp();\n\nconst mosaicDefinitionTransaction = MosaicDefinitionCreationTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new MosaicDefinition(\n        PublicAccount.createWithPublicKey(account.publicKey),\n        new MosaicId(\"new-namespace\", \"new-mosaic\"),\n        \"mosaic description\",\n        new MosaicProperties(0, 9000000, true, true),\n        new MosaicLevy(\n            MosaicLevyType.Percentil,\n            account.address,\n            new MosaicId(\"nem\", \"xem\"),\n            2\n        )\n    )\n);\n\nconst signedTransaction = account.signTransaction(mosaicDefinitionTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x => console.log(x));  Source code",
            "title": "How to create a Mosaic"
        },
        {
            "location": "/guide/mosaic/#how-to-get-namespace-mosaic-definitions",
            "text": "import {\n    NEMLibrary, NetworkTypes, MosaicHttp, TransactionTypes\n} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst mosaicHttp = new MosaicHttp();\nconst namespace = \"new-namespace\";\n\nmosaicHttp.getAllMosaicsGivenNamespace(namespace).subscribe(mosaicDefinitions => console.log(mosaicDefinitions));  Source code",
            "title": "How to get Namespace Mosaic Definitions"
        },
        {
            "location": "/guide/node/",
            "text": "How to get NEM Node information\n\n\nimport {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp();\nnodeHttp.getNodeInfo().subscribe(node => console.log(node));\n\n\n\n\n\nSource code\n\n\nHow to get extended information about a NEM Node\n\n\nimport {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp();\nnodeHttp.getNisNodeInfo().subscribe(nisNodeInfo => console.log(nisNodeInfo));\n\n\n\n\nSource code\n\n\nHow to get all active nodes\n\n\nimport {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp();\nnodeHttp.getActiveNodes().subscribe(nodes => console.log(nodes));\n\n\n\n\nSource code",
            "title": "Node"
        },
        {
            "location": "/guide/node/#how-to-get-nem-node-information",
            "text": "import {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp();\nnodeHttp.getNodeInfo().subscribe(node => console.log(node));  Source code",
            "title": "How to get NEM Node information"
        },
        {
            "location": "/guide/node/#how-to-get-extended-information-about-a-nem-node",
            "text": "import {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp();\nnodeHttp.getNisNodeInfo().subscribe(nisNodeInfo => console.log(nisNodeInfo));  Source code",
            "title": "How to get extended information about a NEM Node"
        },
        {
            "location": "/guide/node/#how-to-get-all-active-nodes",
            "text": "import {NEMLibrary, NetworkTypes, NodeHttp} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp();\nnodeHttp.getActiveNodes().subscribe(nodes => console.log(nodes));  Source code",
            "title": "How to get all active nodes"
        },
        {
            "location": "/guide/blockchain/",
            "text": "Blockchain\n\n\nHow to get a Block by Height\n\n\nimport {BlockHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst blockHttp = new BlockHttp();\nblockHttp.getBlockByHeight(1033023).subscribe(block => {\n    console.log(block);\n});\n\n\n\n\nSource code\n\n\nHow to get Last block of the blockchain\n\n\nimport {ChainHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst chainHttp = new ChainHttp();\nchainHttp.getBlockchainLastBlock().subscribe(block => {\n    console.log(block);\n});\n\n\n\n\nSource code",
            "title": "Blockchain"
        },
        {
            "location": "/guide/blockchain/#blockchain",
            "text": "",
            "title": "Blockchain"
        },
        {
            "location": "/guide/blockchain/#how-to-get-a-block-by-height",
            "text": "import {BlockHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst blockHttp = new BlockHttp();\nblockHttp.getBlockByHeight(1033023).subscribe(block => {\n    console.log(block);\n});  Source code",
            "title": "How to get a Block by Height"
        },
        {
            "location": "/guide/blockchain/#how-to-get-last-block-of-the-blockchain",
            "text": "import {ChainHttp, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst chainHttp = new ChainHttp();\nchainHttp.getBlockchainLastBlock().subscribe(block => {\n    console.log(block);\n});  Source code",
            "title": "How to get Last block of the blockchain"
        },
        {
            "location": "/guide/listener/",
            "text": "How to create a listener for account information\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {AccountListener, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\");\nlet listener = new AccountListener().given(address);\n\nlistener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});\n\n\n\n\nSource code\n\n\nHow to create a listener for new blocks information\n\n\n/**\n * nem-library 0.3.0\n */\nimport {BlockchainListener, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet blockchainListener = new BlockchainListener().newBlock();\n\nblockchainListener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});\n\n\n\n\n\n\nSource code\n\n\nHow to create a listener for new blockchain height information\n\n\n/**\n * nem-library 0.3.0\n */\nimport {BlockchainListener, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet blockchainListener = new BlockchainListener().newHeight();\n\nblockchainListener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});\n\n\n\n\nSource code\n\n\nHow to create a listener for unconfirmed transactions information\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {Address, NEMLibrary, NetworkTypes, UnconfirmedTransactionListener} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\");\n\nlet unconfirmedTransactionListener = new UnconfirmedTransactionListener().given(address);\nunconfirmedTransactionListener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});\n\n\n\n\nSource code\n\n\nHow to create a listener for confirmed transactions information\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {Address, ConfirmedTransactionListener, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\");\n\nlet confirmedTransactionListener = new ConfirmedTransactionListener().given(address);\nconfirmedTransactionListener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});\n\n\n\n\nSource code",
            "title": "Listener"
        },
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-account-information",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {AccountListener, Address, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\");\nlet listener = new AccountListener().given(address);\n\nlistener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});  Source code",
            "title": "How to create a listener for account information"
        },
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-new-blocks-information",
            "text": "/**\n * nem-library 0.3.0\n */\nimport {BlockchainListener, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet blockchainListener = new BlockchainListener().newBlock();\n\nblockchainListener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});  Source code",
            "title": "How to create a listener for new blocks information"
        },
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-new-blockchain-height-information",
            "text": "/**\n * nem-library 0.3.0\n */\nimport {BlockchainListener, NEMLibrary, NetworkTypes} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet blockchainListener = new BlockchainListener().newHeight();\n\nblockchainListener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});  Source code",
            "title": "How to create a listener for new blockchain height information"
        },
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-unconfirmed-transactions-information",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {Address, NEMLibrary, NetworkTypes, UnconfirmedTransactionListener} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\");\n\nlet unconfirmedTransactionListener = new UnconfirmedTransactionListener().given(address);\nunconfirmedTransactionListener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});  Source code",
            "title": "How to create a listener for unconfirmed transactions information"
        },
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-confirmed-transactions-information",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {Address, ConfirmedTransactionListener, NEMLibrary, NetworkTypes} from \"nem-library\";\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\"TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\");\n\nlet confirmedTransactionListener = new ConfirmedTransactionListener().given(address);\nconfirmedTransactionListener.subscribe(x => {\n    console.log(x);\n}, err => {\n    console.log(err);\n});  Source code",
            "title": "How to create a listener for confirmed transactions information"
        },
        {
            "location": "/guide/wallet/",
            "text": "How to create a Simple Wallet\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst password = new Password(\"password\");\nconst simpleWallet = SimpleWallet.create(\"simple wallet\", password);\n\n\n\n\nSource code\n\n\nHow to create a Brain Wallet\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst brainPassword =  new BrainPassword(\"entertain destruction sassy impartial morning electric limit glib bait grape icy measure\")\nconst brainWallet = BrainWallet.create(\"brain wallet\", brainPassword);\n\n\n\n\nSource code\n\n\nHow to create a Simple Wallet from a private key\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\n\n\nconst password = new Password(\"password\");\nconst simpleWallet = SimpleWallet.createWithPrivateKey(\"simple wallet\", password, privateKey);\n\n\n\n\nSource code\n\n\nHow to open a Wallet\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\n\n\nconst password = new Password(\"password\");\nconst simpleWallet = SimpleWallet.createWithPrivateKey(\"simple wallet\", password, privateKey);\nconst account = simpleWallet.open(password);\n\n\n\n\nSource code",
            "title": "Wallet"
        },
        {
            "location": "/guide/wallet/#how-to-create-a-simple-wallet",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst password = new Password(\"password\");\nconst simpleWallet = SimpleWallet.create(\"simple wallet\", password);  Source code",
            "title": "How to create a Simple Wallet"
        },
        {
            "location": "/guide/wallet/#how-to-create-a-brain-wallet",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \"nem-library\";\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst brainPassword =  new BrainPassword(\"entertain destruction sassy impartial morning electric limit glib bait grape icy measure\")\nconst brainWallet = BrainWallet.create(\"brain wallet\", brainPassword);  Source code",
            "title": "How to create a Brain Wallet"
        },
        {
            "location": "/guide/wallet/#how-to-create-a-simple-wallet-from-a-private-key",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\n\n\nconst password = new Password(\"password\");\nconst simpleWallet = SimpleWallet.createWithPrivateKey(\"simple wallet\", password, privateKey);  Source code",
            "title": "How to create a Simple Wallet from a private key"
        },
        {
            "location": "/guide/wallet/#how-to-open-a-wallet",
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \"nem-library\";\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\n\n\nconst password = new Password(\"password\");\nconst simpleWallet = SimpleWallet.createWithPrivateKey(\"simple wallet\", password, privateKey);\nconst account = simpleWallet.open(password);  Source code",
            "title": "How to open a Wallet"
        },
        {
            "location": "/support/",
            "text": "Bug reports\n\n\nIf you think you have found a bug in NEM Library, first make sure that you \nare testing against the latest version of NEM Library - your issue may already \nhave been fixed. If not, search our issues list on GitHub in case a similar \nissue has already been opened.\n\n\nIt is very helpful if you can prepare a reproduction of the bug. In other words, \nprovide a small test case which we can run to confirm your bug. It makes it easier to \nfind the problem and to fix it.\n\n\nPlease, take in consideration the next template to report your issue:\n\n\n\n\nExpected Behaviour\n\n\nShort and expressive sentence explaining what the code should do.\n\n\nCurrent Behaviour\n\n\nA short sentence enplaning what the code does.\n\n\nSteps to reproduce\n\n\nFor faster issue detection, we would need a step by step description do reproduce the issue.\n\n\n\n\nProvide as much information as you can.\n\n\nOpen a new issue \nhere\n.\n\n\nFeature requests\n\n\nIf you find yourself wishing for a feature that doesn't exist in NEM Library, \nyou are probably not alone. There are bound to be others out there with similar \nneeds. Many of the features that NEM Library has today have been added because \nour users saw the need. Open an \nissue\n on our issues list on GitHub which describes \nthe feature you would like to see, why you need it, and how it should work.\n\n\nJoin the development discussion\n\n\nWe love to listen your thoughts about NEM Library, you can find us in \nGitter\n or checkout our \nAbout section",
            "title": "Support"
        },
        {
            "location": "/support/#bug-reports",
            "text": "If you think you have found a bug in NEM Library, first make sure that you \nare testing against the latest version of NEM Library - your issue may already \nhave been fixed. If not, search our issues list on GitHub in case a similar \nissue has already been opened.  It is very helpful if you can prepare a reproduction of the bug. In other words, \nprovide a small test case which we can run to confirm your bug. It makes it easier to \nfind the problem and to fix it.  Please, take in consideration the next template to report your issue:   Expected Behaviour  Short and expressive sentence explaining what the code should do.  Current Behaviour  A short sentence enplaning what the code does.  Steps to reproduce  For faster issue detection, we would need a step by step description do reproduce the issue.   Provide as much information as you can.",
            "title": "Bug reports"
        },
        {
            "location": "/support/#open-a-new-issue-here",
            "text": "",
            "title": "Open a new issue here."
        },
        {
            "location": "/support/#feature-requests",
            "text": "If you find yourself wishing for a feature that doesn't exist in NEM Library, \nyou are probably not alone. There are bound to be others out there with similar \nneeds. Many of the features that NEM Library has today have been added because \nour users saw the need. Open an  issue  on our issues list on GitHub which describes \nthe feature you would like to see, why you need it, and how it should work.",
            "title": "Feature requests"
        },
        {
            "location": "/support/#join-the-development-discussion",
            "text": "We love to listen your thoughts about NEM Library, you can find us in  Gitter  or checkout our  About section",
            "title": "Join the development discussion"
        },
        {
            "location": "/internal_development_process/",
            "text": "Agile\n\n\nNEM Library is developed following the \nAgile Manifesto\n\u2019s values:\n\n\n\n\nIndividuals and interactions over processes and tools\n\n\nWorking software over extensive documentation\n\n\nCustomer collaboration over contract negotiation\n\n\nResponding to change over following the plan\n\n\n\n\nDevelopment Methodology\n\n\nNEM Library is developed applying \nTest-Driven Development\n and \n\neXtreme Programming\n.",
            "title": "Internal Development Process"
        },
        {
            "location": "/internal_development_process/#agile",
            "text": "NEM Library is developed following the  Agile Manifesto \u2019s values:   Individuals and interactions over processes and tools  Working software over extensive documentation  Customer collaboration over contract negotiation  Responding to change over following the plan",
            "title": "Agile"
        },
        {
            "location": "/internal_development_process/#development-methodology",
            "text": "NEM Library is developed applying  Test-Driven Development  and  eXtreme Programming .",
            "title": "Development Methodology"
        },
        {
            "location": "/about/",
            "text": "About NEM Library\n\n\nThe origin of NEM Library is the need of a new development approach for enterprise-ready solutions built on top of the \nNEM Blockchain\n.\n\n\nThe characteristics of the NEM Library are similar to the \nNEM Framework\n definition, but\nNEM Library has not the same roadmap or scope as described in the NEM Framework document. Hence, NEM Library's future is guided\nby the needs of the NEM Library usage and products build on top of it.\n\n\nNEM Library is developed independently of any institution by \nGuillem\n and \nAleix\n.\n\n\nFollow us on our social networks!\n\n\n\n\nGuillem: \nTwitter\n, \nGitHub\n Email; guillemchain at gmail.com\n\n\nAleix: \nTwitter\n, \nGitHub\n, \nMedium\n, Email; aleix602 at gmail.com",
            "title": "About"
        },
        {
            "location": "/about/#about-nem-library",
            "text": "The origin of NEM Library is the need of a new development approach for enterprise-ready solutions built on top of the  NEM Blockchain .  The characteristics of the NEM Library are similar to the  NEM Framework  definition, but\nNEM Library has not the same roadmap or scope as described in the NEM Framework document. Hence, NEM Library's future is guided\nby the needs of the NEM Library usage and products build on top of it.  NEM Library is developed independently of any institution by  Guillem  and  Aleix .  Follow us on our social networks!   Guillem:  Twitter ,  GitHub  Email; guillemchain at gmail.com  Aleix:  Twitter ,  GitHub ,  Medium , Email; aleix602 at gmail.com",
            "title": "About NEM Library"
        }
    ]
}