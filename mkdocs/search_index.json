{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nNEM Library is an abstraction for \nNEM Blockchain\n using a \nReactive\n approach\nfor creating Blockchain applications.\n\n\n\n\nstable version 0.2.34\n\n\nCheck the \nnpm repostory\n for the latest updates\n\n\nInstallation\n\n\nnpm install nem-library --save\n\n\n\n\nNEM Library is build with \nTypeScript Language\n, so be sure that you have \nthe latest version installed.\n\n\nWe recommend to use TypeScript instead of JavaScript for building applications for \n\nNEM Blockchain\n due the type  system and how the nem-library is meant \nto be used, without counting other great benefits that TypeScript provides.\n\n\nnpm install -g typescript\n\n\n\n\n\n\nPlatforms supported\n\n\n\n\n\n\n\n\nPlatform\n\n\nVersion\n\n\n\n\n\n\n\n\n\n\nTypeScript\n\n\n>= 2.4.0\n\n\n\n\n\n\nNodeJS\n\n\n>= 6.11.1 (but 8.x.x is recommended)\n\n\n\n\n\n\nAngular\n\n\n>= 4.2\n\n\n\n\n\n\nIonic\n\n\n>= 4.0\n\n\n\n\n\n\nFirefox\n\n\n>= 53.0\n\n\n\n\n\n\nChrome\n\n\n>= 58.0.3029.81\n\n\n\n\n\n\nChromium\n\n\n>= 59.0.3071.86\n\n\n\n\n\n\nOpera\n\n\n>= 46.0.2597.46\n\n\n\n\n\n\nEdge\n\n\n>= 40.15063.0.0\n\n\n\n\n\n\nSafari\n\n\n>= 10.0\n\n\n\n\n\n\nAndroid\n\n\n>= 5.0.0\n\n\n\n\n\n\niOS\n\n\n>= 9.3.5\n\n\n\n\n\n\n\n\nBecause of Ionic generates mobile applications, Android and iOS, the support is provided.\n\nRemark that \nWindows Phone\n is not supported yet.\n\n\n\n\nTypeScript compiler options\n\n\nUntil nem-library upgrade into \nRxJS 6.0\n, \n\"noStrictGenericChecks\"\n has to be set to true in \ntsconfig.json\n file.\n\n\n{\n  \ncompilerOptions\n: {\n    // ...\n    \nnoStrictGenericChecks\n: true\n  }\n}\n\n\n\n\nUsage\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nChangelog\n\n\n0.3.0-RC4\n\n\n\n\nEncrypted Message\n\n\n\n\n0.3.0-RC1\n\n\n\n\nPagination\n\n\nListeners\n\n\nWallets\n\n\n\n\n0.2.34\n\n\nStable version", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "NEM Library is an abstraction for  NEM Blockchain  using a  Reactive  approach\nfor creating Blockchain applications.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#stable-version-0234", 
            "text": "Check the  npm repostory  for the latest updates", 
            "title": "stable version 0.2.34"
        }, 
        {
            "location": "/#installation", 
            "text": "npm install nem-library --save  NEM Library is build with  TypeScript Language , so be sure that you have \nthe latest version installed.  We recommend to use TypeScript instead of JavaScript for building applications for  NEM Blockchain  due the type  system and how the nem-library is meant \nto be used, without counting other great benefits that TypeScript provides.  npm install -g typescript", 
            "title": "Installation"
        }, 
        {
            "location": "/#platforms-supported", 
            "text": "Platform  Version      TypeScript  >= 2.4.0    NodeJS  >= 6.11.1 (but 8.x.x is recommended)    Angular  >= 4.2    Ionic  >= 4.0    Firefox  >= 53.0    Chrome  >= 58.0.3029.81    Chromium  >= 59.0.3071.86    Opera  >= 46.0.2597.46    Edge  >= 40.15063.0.0    Safari  >= 10.0    Android  >= 5.0.0    iOS  >= 9.3.5     Because of Ionic generates mobile applications, Android and iOS, the support is provided. \nRemark that  Windows Phone  is not supported yet.", 
            "title": "Platforms supported"
        }, 
        {
            "location": "/#typescript-compiler-options", 
            "text": "Until nem-library upgrade into  RxJS 6.0 ,  \"noStrictGenericChecks\"  has to be set to true in  tsconfig.json  file.  {\n   compilerOptions : {\n    // ...\n     noStrictGenericChecks : true\n  }\n}", 
            "title": "TypeScript compiler options"
        }, 
        {
            "location": "/#usage", 
            "text": "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "Usage"
        }, 
        {
            "location": "/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/#030-rc4", 
            "text": "Encrypted Message", 
            "title": "0.3.0-RC4"
        }, 
        {
            "location": "/#030-rc1", 
            "text": "Pagination  Listeners  Wallets", 
            "title": "0.3.0-RC1"
        }, 
        {
            "location": "/#0234", 
            "text": "Stable version", 
            "title": "0.2.34"
        }, 
        {
            "location": "/documentation/architecture/", 
            "text": "Architecture\n\n\nNEM Library works perfect in a \nmultitier architecture\n, because \nit is the layer between your business logic and the data tier. It enables the developers focus on the product rather than the \nNEM Blockchain specific API details due its higher abstraction.\n\n\n\n\n\n\nNEM Blockchain\n: Persistent layer.\n\n\nNEM Library\n: Abstraction layer.\n\n\nYour Application\n: Where the business logic resides.\n\n\nFinal Users\n: People who benefit the NEM Blockchain Technology.\n\n\n\n\nNEM Library has a functional programming approach to deal with the immutability of the NEM Blockchain. So, the developer will find\nhimself/herself comfortable with the easy way to fetch the state, and create new Transactions in order to change that state.\n\n\n\n\nBrief description of NEM Library organization\n\n\nNEM Library follows the next rules:\n\n\n\n\n\n\nInfrastructure\n: The HTTP requests are done following the \nRepository Pattern\n, and they return NEM Domain immutable \nmodels via the \nObservable Pattern\n. So, the state fetched from the NEM Blockchain cannot be changed via code. \n\n\n\n\n\n\nNEM Domain models\n: The NEM Domain models are \nimmutable\n by definition, the developer cannot change its attributes. \nInstead, the developer have to create new Transactions and dispatch them to NEM Blockchain via TransactionHTTP, in order to change the NEM Blockchain state.\n\n\n\n\n\n\nCharacteristics\n\n\n\n\n\n\nStandardized Contracts\n: Guaranteeing interoperability and harmonization of data models.\n\n\n\n\n\n\nLoose Coupling\n: Reducing the degree of component coupling fosters.\n\n\n\n\n\n\nAbstraction\n: Increasing long-term consistency of interoperability and allowing underlying components to evolve independently.\n\n\n\n\n\n\nReusability\n: Enabling high-level interoperability between modules and potential component consumers.\n\n\n\n\n\n\nStateless\n: Increasing availability and scalability of components allowing them to interoperate more frequent and reliable.\n\n\n\n\n\n\nComposability\n: For components to be effectively composable they must be interoperable.\n\n\n\n\n\n\nA key objective is for interoperability to become a natural design of the NEM Library, \nideally to extend that components to work with other products or systems.\n\n\nReactive\n\n\nNEM Library uses \nRxJS\n as Reactive Library. See its docs \nhere\n\n\n\n\n\n\nFunctional\n: Developers can avoid intricate stateful programs using clean input/output functions over\nobservable streams.\n\n\n\n\n\n\nLess is more\n:ReactiveX's operators often reduce what was once an elaborate challenge into a few lines\nof code.\n\n\n\n\n\n\nAsync error handling\n: Traditional try/catch is powerless for errors handling in asynchronous computations, but\nReactiveX will offer developers the proper tools to handling these sort of errors.\n\n\n\n\n\n\nConcurrency made easy\n: Observables and Schedulers in ReactiveX allow the programmer to abstract away\nlow-level threading, synchronization, and concurrency issues.\n\n\n\n\n\n\nFrontend\n: Simple manipulation of UI events and API responses on the Web using RxJS\n\n\n\n\n\n\nBackend\n: Embrace ReactiveX's asynchronicity, enabling concurrency and implementation independence.\n\n\n\n\n\n\nConnection Pool\n: NEM Library will offer a Connection Pool feature that will distribute load throughout the\nnetwork ensuring maintained connectivity, higher speeds and higher availability.", 
            "title": "Architecture"
        }, 
        {
            "location": "/documentation/architecture/#architecture", 
            "text": "NEM Library works perfect in a  multitier architecture , because \nit is the layer between your business logic and the data tier. It enables the developers focus on the product rather than the \nNEM Blockchain specific API details due its higher abstraction.    NEM Blockchain : Persistent layer.  NEM Library : Abstraction layer.  Your Application : Where the business logic resides.  Final Users : People who benefit the NEM Blockchain Technology.   NEM Library has a functional programming approach to deal with the immutability of the NEM Blockchain. So, the developer will find\nhimself/herself comfortable with the easy way to fetch the state, and create new Transactions in order to change that state.", 
            "title": "Architecture"
        }, 
        {
            "location": "/documentation/architecture/#brief-description-of-nem-library-organization", 
            "text": "NEM Library follows the next rules:    Infrastructure : The HTTP requests are done following the  Repository Pattern , and they return NEM Domain immutable \nmodels via the  Observable Pattern . So, the state fetched from the NEM Blockchain cannot be changed via code.     NEM Domain models : The NEM Domain models are  immutable  by definition, the developer cannot change its attributes. \nInstead, the developer have to create new Transactions and dispatch them to NEM Blockchain via TransactionHTTP, in order to change the NEM Blockchain state.", 
            "title": "Brief description of NEM Library organization"
        }, 
        {
            "location": "/documentation/architecture/#characteristics", 
            "text": "Standardized Contracts : Guaranteeing interoperability and harmonization of data models.    Loose Coupling : Reducing the degree of component coupling fosters.    Abstraction : Increasing long-term consistency of interoperability and allowing underlying components to evolve independently.    Reusability : Enabling high-level interoperability between modules and potential component consumers.    Stateless : Increasing availability and scalability of components allowing them to interoperate more frequent and reliable.    Composability : For components to be effectively composable they must be interoperable.    A key objective is for interoperability to become a natural design of the NEM Library, \nideally to extend that components to work with other products or systems.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/documentation/architecture/#reactive", 
            "text": "NEM Library uses  RxJS  as Reactive Library. See its docs  here    Functional : Developers can avoid intricate stateful programs using clean input/output functions over\nobservable streams.    Less is more :ReactiveX's operators often reduce what was once an elaborate challenge into a few lines\nof code.    Async error handling : Traditional try/catch is powerless for errors handling in asynchronous computations, but\nReactiveX will offer developers the proper tools to handling these sort of errors.    Concurrency made easy : Observables and Schedulers in ReactiveX allow the programmer to abstract away\nlow-level threading, synchronization, and concurrency issues.    Frontend : Simple manipulation of UI events and API responses on the Web using RxJS    Backend : Embrace ReactiveX's asynchronicity, enabling concurrency and implementation independence.    Connection Pool : NEM Library will offer a Connection Pool feature that will distribute load throughout the\nnetwork ensuring maintained connectivity, higher speeds and higher availability.", 
            "title": "Reactive"
        }, 
        {
            "location": "/documentation/overview/", 
            "text": "Installation\n\n\nStep1\n: Add nem-library dependency to \npackage.json\n\n\n$\n npm install nem-library --save\n\n\n\n\nStep2\n: Setup phase\n\n\nIn your application startup file, initialize NEMLibrary.\n\n\nimport { NEMLibrary, NetworkTypes } from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\n\n\n\nYour application can have two modes, \nNetworkTypes.TEST_NET\n and \nNetworkTypes.MAIN_NET\n.\nDepending on the environment that you want to use, you should call the bootstrap method, with \nMAIN_NET\n\nor \nTEST_NET\n.\n\n\nBecause the application should have a unique environment, call two times \nNEMLibrary.bootstrap(_)\n will throw an \nError\n.\nIn case that you need to change between environments in runtime, call \nNEMLibrary.reset()\n first.\n\n\nConfigure endpoints\n\n\nEach infrastructure endpoints share the same constructor.\n\n\n// Using custom NIS Node\nconst accountHttp = new AccountHttp({\n    protocol: \nhttp\n,\n    domain: \n104.128.226.60\n,\n    port: \n7890\n\n});\n\n// Using default NIS Node\nconst accountHttpWithDefaultConfig = new AccountHttp();\n\n\n\n\nThe default values are:\n\n\nTEST NET\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nprotocol\n\n\nhttp\n\n\n\n\n\n\ndomain\n\n\nbigalice2.nem.ninja\n\n\n\n\n\n\nport\n\n\n7890\n\n\n\n\n\n\n\n\nMAIN NET\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nprotocol\n\n\nhttp\n\n\n\n\n\n\ndomain\n\n\nalice6.nem.ninja\n\n\n\n\n\n\nport\n\n\n7890", 
            "title": "Overview"
        }, 
        {
            "location": "/documentation/overview/#installation", 
            "text": "Step1 : Add nem-library dependency to  package.json  $  npm install nem-library --save  Step2 : Setup phase  In your application startup file, initialize NEMLibrary.  import { NEMLibrary, NetworkTypes } from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);  Your application can have two modes,  NetworkTypes.TEST_NET  and  NetworkTypes.MAIN_NET .\nDepending on the environment that you want to use, you should call the bootstrap method, with  MAIN_NET \nor  TEST_NET .  Because the application should have a unique environment, call two times  NEMLibrary.bootstrap(_)  will throw an  Error .\nIn case that you need to change between environments in runtime, call  NEMLibrary.reset()  first.", 
            "title": "Installation"
        }, 
        {
            "location": "/documentation/overview/#configure-endpoints", 
            "text": "Each infrastructure endpoints share the same constructor.  // Using custom NIS Node\nconst accountHttp = new AccountHttp({\n    protocol:  http ,\n    domain:  104.128.226.60 ,\n    port:  7890 \n});\n\n// Using default NIS Node\nconst accountHttpWithDefaultConfig = new AccountHttp();  The default values are:  TEST NET     Parameter  Value      protocol  http    domain  bigalice2.nem.ninja    port  7890     MAIN NET     Parameter  Value      protocol  http    domain  alice6.nem.ninja    port  7890", 
            "title": "Configure endpoints"
        }, 
        {
            "location": "/documentation/account/", 
            "text": "Account related requests\n\n\nThis chapter will guide you through the process of retrieving account information from a NEM Infrastructure Server. The information that can be retrieved is the durable account data, its meta data and information about transactions and harvested blocks.\n\n\nNIS supports two different kind of accounts: normal accounts and multsig (short for: multi signature) accounts:\n\n\nNormal accounts:\n\n\nNormal accounts are created and controlled by a private key. Any action for the account like sending NEM to another account via a transfer transaction is signed with this private key. If an attacker gains knowledge of the private key, he/she can rob the account. The private key must therefore be kept secret by all means.\n\n\nMultisig accounts:\n\n\nMultisig accounts can be created by converting a normal account to a multisig account via a aggregate modification transaction. This adds cosignatories to the account. After that modification, only the cosignatories can initiate an action for the account. Any action must be signed by all cosignatories. This makes a multisig account significantly more secure than a normal account. When a single cosignatory private key is gained by an attacker, the attacker still can`t initiate any action on the account since all cosignatories must sign. It is strongly recommended to convert any account holding a significantly high amount of NEM into a multisig account with at least 3 cosignatories. Once converted to a multisig account, the original private key for the account plays no role any more.\n\n\nOfficial Source\n\n\nKeypair concept\n\n\nNEM Library replaces the Keypair model, which usually holds the public and private key, with the \nAccount\n model. The reason is that we aim to keep the private key as secret as possible, just providing a set of methods where the private key is involved.\n\n\nAccountHttp definition\n\n\nexport declare class AccountHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets an AccountInfoWithMetaData for an account.\n     * @param address - Address\n     * @return Observable\nAccountInfoWithMetaData\n\n     */\n    getFromAddress(address: Address): Observable\nAccountInfoWithMetaData\n;\n\n    /**\n     * Gets an AccountInfoWithMetaData for an account with publicKey\n     * @param publicKey - NEM\n     * @return Observable\nAccountInfoWithMetaData\n\n     */\n    getFromPublicKey(publicKey: string): Observable\nAccountInfoWithMetaData\n;\n\n    /**\n     * Given a delegate (formerly known as remote) account`s address, gets the AccountMetaDataPair for the account for which the given account is the delegate account.\n     * If the given account address is not a delegate account for any account, the request returns the AccountMetaDataPair for the given address.\n     * @param address - Address\n     * @return Observable\nAccountInfoWithMetaData\n\n     */\n    getOriginalAccountDataFromDelegatedAccountAddress(address: Address): Observable\nAccountInfoWithMetaData\n;\n\n    /**\n     * retrieve the original account data by providing the public key of the delegate account.\n     * @param publicKey - string\n     * @return Observable\nAccountInfoWithMetaData\n\n     */\n    getOriginalAccountDataFromDelegatedAccountPublicKey(publicKey: string): Observable\nAccountInfoWithMetaData\n;\n\n    /**\n     * Gets the AccountMetaData from an account.\n     * @param address - NEM Address\n     * @return Observable\nAccountStatus\n\n     */\n    status(address: Address): Observable\nAccountStatus\n;\n\n    /**\n     * A transaction is said to be incoming with respect to an account if the account is the recipient of the transaction.\n     * In the same way outgoing transaction are the transactions where the account is the sender of the transaction.\n     * Unconfirmed transactions are those transactions that have not yet been included in a block.\n     * Unconfirmed transactions are not guaranteed to be included in any block\n     * @param address - The address of the account.\n     * @param hash - (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned.\n     * @param id - (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash.\n     * @return Observable\nTransaction[]\n\n     */\n    incomingTransactions(address: Address, hash?: string, id?: string): Observable\nTransaction[]\n;\n\n    /**\n     * Paginaged version of incomingTransactions request\n     * @param address\n     * @param hash\n     * @returns {IncomingTransactionsPageable}\n     */\n    incomingTransactionsPaginated(address: Address, hash?: string): Pageable\nTransaction[]\n;\n\n    /**\n     * Gets an array of transaction meta data pairs where the recipient has the address given as parameter to the request.\n     * A maximum of 25 transaction meta data pairs is returned. For details about sorting and discussion of the second parameter see Incoming transactions.\n     * @param address - The address of the account.\n     * @param hash - (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned.\n     * @param id - (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash.\n     * @return Observable\nTransaction[]\n\n     */\n    outgoingTransactions(address: Address, hash?: string, id?: string): Observable\nTransaction[]\n;\n\n    /**\n     * Paginaged version of outgoingTransactions request\n     * @param address\n     * @param hash\n     * @returns {OutgoingTransactionsPageable}\n     */\n    outgoingTransactionsPaginated(address: Address, hash?: string): Pageable\nTransaction[]\n;\n\n    /**\n     * Gets an array of transaction meta data pairs for which an account is the sender or receiver.\n     * A maximum of 25 transaction meta data pairs is returned.\n     * For details about sorting and discussion of the second parameter see Incoming transactions.\n     * @param address - The address of the account.\n     * @param hash - (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned.\n     * @param id - (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash.\n     * @return Observable\nTransaction[]\n\n     */\n    allTransactions(address: Address, hash?: string, id?: string): Observable\nTransaction[]\n;\n\n    /**\n     * Paginaged version of allTransactions request\n     * @param address\n     * @param hash\n     * @returns {AllTransactionsPageable}\n     */\n    allTransactionsPaginated(address: Address, hash?: string): Pageable\nTransaction[]\n;\n\n    /**\n     * Gets the array of transactions for which an account is the sender or receiver and which have not yet been included in a block\n     * @param address - NEM Address\n     * @return Observable\nTransaction[]\n\n     */\n    unconfirmedTransactions(address: Address): Observable\nTransaction[]\n;\n\n    /**\n     * Gets an array of harvest info objects for an account.\n     * @param address - Address\n     * @param id - string (optional)\n     * @return Observable\nAccountHarvestInfo[]\n\n     */\n    getHarvestInfoDataForAnAccount(address: Address, id?: string): Observable\nAccountHarvestInfo[]\n;\n\n    /**\n     * Paginaged version of allTransactions request\n     * @param address\n     * @param id\n     * @returns {HarvestInfoPageable}\n     */\n    getHarvestInfoDataForAnAccountPaginated(address: Address, id?: string): Pageable\nAccountHarvestInfo[]\n;\n\n    /**\n     * Gets an array of account importance view model objects.\n     * @return Observable\nAccountImportanceInfo[]\n\n     */\n    getAccountImportances(): Observable\nAccountImportanceInfo[]\n;\n\n    /**\n     * Gets an array of namespace objects for a given account address.\n     * The parent parameter is optional. If supplied, only sub-namespaces of the parent namespace are returned.\n     * @param address - Address\n     * @param parent - The optional parent namespace id.\n     * @param id - The optional namespace database id up to which namespaces are returned.\n     * @param pageSize - The (optional) number of namespaces to be returned.\n     * @return Observable\nNamespace[]\n\n     */\n    getNamespaceOwnedByAddress(address: Address, parent?: string, id?: string, pageSize?: number): Observable\nNamespace[]\n;\n\n    /**\n     * Gets an array of mosaic definition objects for a given account address. The parent parameter is optional.\n     * If supplied, only mosaic definitions for the given parent namespace are returned.\n     * The id parameter is optional and allows retrieving mosaic definitions in batches of 25 mosaic definitions.\n     * @param address - The address of the account.\n     * @param parent - The optional parent namespace id.\n     * @param id - The optional mosaic definition database id up to which mosaic definitions are returned.\n     * @return Observable\nMosaicDefinition[]\n\n     */\n    getMosaicCreatedByAddress(address: Address, parent?: string, id?: string): Observable\nMosaicDefinition[]\n;\n\n    /**\n     * Gets an array of mosaic objects for a given account address.\n     * @param address - Address\n     * @return Observable\nMosaic[]\n\n     */\n    getMosaicOwnedByAddress(address: Address): Observable\nMosaic[]\n;\n\n    /**\n     * Unlocks an account (starts harvesting).\n     * @param host - string\n     * @param privateKey - string\n     * @return Observable\nboolean\n\n     */\n    unlockHarvesting(host: string, privateKey: string): Observable\nboolean\n;\n\n    /**\n     * Locks an account (stops harvesting).\n     * @param host - string\n     * @param privateKey - string\n     * @return Observable\nboolean\n\n     */\n    lockHarvesting(host: string, privateKey: string): Observable\nboolean\n;\n\n    /**\n     * Each node can allow users to harvest with their delegated key on that node.\n     * The NIS configuration has entries for configuring the maximum number of allowed harvesters and optionally allow harvesting only for certain account addresses.\n     * The unlock info gives information about the maximum number of allowed harvesters and how many harvesters are already using the node.\n     * @return Observable\nNodeHarvestInfo\n\n     */\n    unlockInfo(): Observable\nNodeHarvestInfo\n;\n\n    /**\n     * Gets historical information for an account.\n     * @param address - The address of the account.\n     * @param startHeight - The block height from which on the data should be supplied.\n     * @param endHeight - The block height up to which the data should be supplied. The end height must be greater than or equal to the start height.\n     * @param increment - The value by which the height is incremented between each data point. The value must be greater than 0. NIS can supply up to 1000 data points with one request. Requesting more than 1000 data points results in an error.\n     * @return Observable\nAccountHistoricalInfo[]\n\n     */\n    getHistoricalAccountData(address: Address, startHeight: number, endHeight: number, increment: number): Observable\nAccountHistoricalInfo[]\n;\n}\n\n\n\n\nAccountHttp usage\n\n\nimport {AccountHttp, NEMLibrary, NetworkTypes, Address} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\n);\n\nconst accountHttp = new AccountHttp({domain: \n104.128.226.60\n});\naccountHttp.getFromAddress(address).subscribe(accountInfoWithMetaData =\n {\n    console.log(accountInfoWithMetaData);\n});\n\n\n\n\nOutput:\n\n\nAccountInfoWithMetaData {\n  balance: \n   Balance {\n     balance: 50481110745315,\n     vestedBalance: 50480744575985,\n     unvestedBalance: 366169330 },\n  importance: 0.005735794657626706,\n  publicAccount: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C',\n        networkType: 152 },\n     publicKey: '74375c15c6ce6bdbde59be88a069745a0de34444ea933f8c9f46ef407cf30196' },\n  harvestedBlocks: 116319,\n  cosignatoriesCount: undefined,\n  minCosignatories: undefined,\n  status: 'UNLOCKED',\n  remoteStatus: 'INACTIVE',\n  cosignatoryOf: [],\n  cosignatories: [] }\n\n\n\n\nRun the code\n\n\nModels\n\n\n Account\n\n\n/**\n * Account model\n */\nexport declare class Account extends PublicAccount {\n\n    private readonly privateKey;\n    /**\n     * Sign a transaction\n     * @param transaction\n     * @returns {{data: any, signature: string}}\n     */\n    signTransaction(transaction: Transaction): SignedTransaction;\n\n    /**\n     * constructor with private key\n     * @param privateKey\n     * @returns {Account}\n     */\n    static createWithPrivateKey(privateKey: string): Account;\n\n    /**\n     * Create a new encrypted Message\n     * @param message\n     * @param recipientPublicAccount\n     * @returns {EncryptedMessage}\n     */\n    encryptMessage(message: string, recipientPublicAccount: PublicAccount): EncryptedMessage;\n\n    /**\n     * Decrypts an encrypted message\n     * @param encryptedMessage\n     * @param recipientPublicAccount\n     * @returns {EncryptedMessage}\n     */\n    decryptMessage(encryptedMessage: EncryptedMessage, recipientPublicAccount: PublicAccount): EncryptedMessage;\n}\n\n\n\n\nPublicAccount\n\n\n\n/**\n * Public account\n */\nexport declare class PublicAccount {\n\n    readonly address: Address;\n    readonly publicKey: string;\n\n    /**\n     * @returns {boolean}\n     */\n    hasPublicKey(): boolean;\n\n    /**\n     * Creates a new PublicAccount from a public key\n     * @param publicKey\n     * @returns {PublicAccount}\n     */\n    static createWithPublicKey(publicKey: string): PublicAccount;\n}\n\n\n\n\nAddress\n\n\n/**\n * Address model\n */\nexport declare class Address {\n\n    private readonly value;\n    private readonly networkType;\n    constructor(address: string);\n\n    /**\n     * Get address in plain format ex: TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C\n     * @returns {string}\n     */\n    plain(): string;\n\n    /**\n     * Get address in pretty format ex: TALICE-ROONSJ-CPHC63-F52V6F-Y3SDMS-VAEUGH-MB7C\n     * @returns {string}\n     */\n    pretty(): string;\n\n    /**\n     * Address network\n     * @returns {number}\n     */\n    network(): NetworkTypes;\n}\n\n\n\n\n\nBalance\n\n\n/**\n * Balance model\n */\nexport declare class Balance {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: number;\n\n    /**\n     * The vested part of the balance of the account in micro NEM.\n     */\n    readonly vestedBalance: number;\n\n    /**\n     * The unvested part of the balance of the account in micro NEM.\n     */\n    readonly unvestedBalance: number;\n}\n\n\n\n\n\nAccountInfo\n\n\nexport declare enum RemoteStatus {\n    REMOTE = \nREMOTE\n,\n    ACTIVATING = \nACTIVATING\n,\n    ACTIVE = \nACTIVE\n,\n    DEACTIVATING = \nDEACTIVATING\n,\n    INACTIVE = \nINACTIVE\n,\n}\nexport declare enum Status {\n    UNKNOWN = \nUNKNOWN\n,\n    LOCKED = \nLOCKED\n,\n    UNLOCKED = \nUNLOCKED\n,\n}\n\n/**\n * The account structure describes basic information for an account.\n */\nexport declare class AccountInfo {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: Balance;\n\n    /**\n     * The importance of the account.\n     */\n    readonly importance: number;\n\n    /**\n     * The public key of the account.\n     */\n    readonly publicAccount: PublicAccount;\n\n    /**\n     * The number blocks that the account already harvested.\n     */\n    readonly harvestedBlocks: number;\n\n    /**\n     * Total number of cosignatories\n     */\n    readonly cosignatoriesCount?: number;\n\n    /**\n     * Minimum number of cosignatories needed for a transaction to be processed\n     */\n    readonly minCosignatories?: number;\n}\n\nexport declare class AccountInfoWithMetaData extends AccountInfo {\n\n    /**\n     * The harvesting status of a queried account\n     */\n    readonly status: Status;\n\n    /**\n     * The status of remote harvesting of a queried account\n     */\n    readonly remoteStatus: RemoteStatus;\n\n    /**\n     * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array.\n     */\n    readonly cosignatoryOf: AccountInfo[];\n\n    /**\n     * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account.\n     */\n    readonly cosignatories: AccountInfo[];\n}\n\nexport declare class AccountStatus {\n\n    /**\n     * The harvesting status of a queried account\n     */\n    readonly status: Status;\n\n    /**\n     * The status of remote harvesting of a queried account\n     */\n    readonly remoteStatus: RemoteStatus;\n\n    /**\n     * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array.\n     */\n    readonly cosignatoryOf: AccountInfo[];\n\n    /**\n     * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account.\n     */\n    readonly cosignatories: AccountInfo[];\n}\n\n\n\n\n\nAccountHarvestInfo\n\n\n/**\n * A HarvestInfo object contains information about a block that an account harvested.\n */\nexport declare class AccountHarvestInfo {\n\n    /**\n     * The number of seconds elapsed since the creation of the nemesis block.\n     */\n    readonly timeStamp: number;\n\n    /**\n     * The database id for the harvested block.\n     */\n    readonly id: number;\n\n    /**\n     * The block difficulty. The initial difficulty was set to 100000000000000. The block difficulty is always between one tenth and ten times the initial difficulty.\n     */\n    readonly difficulty: number;\n\n    /**\n     * The total fee collected by harvesting the block.\n     */\n    readonly totalFee: number;\n\n    /**\n     * The height of the harvested block.\n     */\n    readonly height: number;\n}\n\n\n\n\n\nAccountHistoricalInfo\n\n\n/**\n * Nodes can support a feature for retrieving historical data of accounts.\n * If this is supported, it returns an array of AccountHistoricalInfo\n */\nexport declare class AccountHistoricalInfo {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: Balance;\n\n    /**\n     * The importance of the account.\n     */\n    readonly importance: number;\n\n    /**\n     * The public key of the account.\n     */\n    readonly address: Address;\n\n    /**\n     * The page rank part of the importance.\n     */\n    readonly pageRank: number;\n}\n\n\n\n\nAccountImportanceInfo\n\n\n/**\n * Each account is assigned an importance in the NEM network. The ability of an account to generate new blocks is proportional to its importance. The importance is a number between 0 and 1.\n */\nexport declare class AccountImportanceInfo {\n\n    /**\n     * The address of the account.\n     */\n    readonly address: Address;\n\n    /**\n     * Substructure that describes the importance of the account.\n     */\n    readonly importance: AccountImportanceData;\n}\n\n/**\n * Substructure that describes the importance of the account.\n */\nexport declare class AccountImportanceData {\n    /**\n     * Indicates if the fields \nscore\n, \nev\n and \nheight\n are available.isSet can have the values 0 or 1. In case isSet is 0 the fields are not available.\n     */\n    readonly isSet: number;\n\n    /**\n     * The importance of the account. The importance ranges between 0 and 1.\n     */\n    readonly score?: number;\n\n    /**\n     * The page rank portion of the importance. The page rank ranges between 0 and 1.\n     */\n    readonly ev?: number;\n\n    /**\n     * The height at which the importance calculation was performed.\n     */\n    readonly height?: number;\n}\n\n\n\n\n\nNodeHarvestInfo\n\n\nexport declare class NodeHarvestInfo {\n\n    /**\n     * Maximum unlocked slots\n     */\n    readonly maxUnlocked: number;\n\n    /**\n     * Number of slots unlocked\n     */\n    readonly numUnlocked: number;\n}", 
            "title": "Account"
        }, 
        {
            "location": "/documentation/account/#account-related-requests", 
            "text": "This chapter will guide you through the process of retrieving account information from a NEM Infrastructure Server. The information that can be retrieved is the durable account data, its meta data and information about transactions and harvested blocks.  NIS supports two different kind of accounts: normal accounts and multsig (short for: multi signature) accounts:  Normal accounts:  Normal accounts are created and controlled by a private key. Any action for the account like sending NEM to another account via a transfer transaction is signed with this private key. If an attacker gains knowledge of the private key, he/she can rob the account. The private key must therefore be kept secret by all means.  Multisig accounts:  Multisig accounts can be created by converting a normal account to a multisig account via a aggregate modification transaction. This adds cosignatories to the account. After that modification, only the cosignatories can initiate an action for the account. Any action must be signed by all cosignatories. This makes a multisig account significantly more secure than a normal account. When a single cosignatory private key is gained by an attacker, the attacker still can`t initiate any action on the account since all cosignatories must sign. It is strongly recommended to convert any account holding a significantly high amount of NEM into a multisig account with at least 3 cosignatories. Once converted to a multisig account, the original private key for the account plays no role any more.  Official Source", 
            "title": "Account related requests"
        }, 
        {
            "location": "/documentation/account/#keypair-concept", 
            "text": "NEM Library replaces the Keypair model, which usually holds the public and private key, with the  Account  model. The reason is that we aim to keep the private key as secret as possible, just providing a set of methods where the private key is involved.", 
            "title": "Keypair concept"
        }, 
        {
            "location": "/documentation/account/#accounthttp-definition", 
            "text": "export declare class AccountHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets an AccountInfoWithMetaData for an account.\n     * @param address - Address\n     * @return Observable AccountInfoWithMetaData \n     */\n    getFromAddress(address: Address): Observable AccountInfoWithMetaData ;\n\n    /**\n     * Gets an AccountInfoWithMetaData for an account with publicKey\n     * @param publicKey - NEM\n     * @return Observable AccountInfoWithMetaData \n     */\n    getFromPublicKey(publicKey: string): Observable AccountInfoWithMetaData ;\n\n    /**\n     * Given a delegate (formerly known as remote) account`s address, gets the AccountMetaDataPair for the account for which the given account is the delegate account.\n     * If the given account address is not a delegate account for any account, the request returns the AccountMetaDataPair for the given address.\n     * @param address - Address\n     * @return Observable AccountInfoWithMetaData \n     */\n    getOriginalAccountDataFromDelegatedAccountAddress(address: Address): Observable AccountInfoWithMetaData ;\n\n    /**\n     * retrieve the original account data by providing the public key of the delegate account.\n     * @param publicKey - string\n     * @return Observable AccountInfoWithMetaData \n     */\n    getOriginalAccountDataFromDelegatedAccountPublicKey(publicKey: string): Observable AccountInfoWithMetaData ;\n\n    /**\n     * Gets the AccountMetaData from an account.\n     * @param address - NEM Address\n     * @return Observable AccountStatus \n     */\n    status(address: Address): Observable AccountStatus ;\n\n    /**\n     * A transaction is said to be incoming with respect to an account if the account is the recipient of the transaction.\n     * In the same way outgoing transaction are the transactions where the account is the sender of the transaction.\n     * Unconfirmed transactions are those transactions that have not yet been included in a block.\n     * Unconfirmed transactions are not guaranteed to be included in any block\n     * @param address - The address of the account.\n     * @param hash - (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned.\n     * @param id - (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash.\n     * @return Observable Transaction[] \n     */\n    incomingTransactions(address: Address, hash?: string, id?: string): Observable Transaction[] ;\n\n    /**\n     * Paginaged version of incomingTransactions request\n     * @param address\n     * @param hash\n     * @returns {IncomingTransactionsPageable}\n     */\n    incomingTransactionsPaginated(address: Address, hash?: string): Pageable Transaction[] ;\n\n    /**\n     * Gets an array of transaction meta data pairs where the recipient has the address given as parameter to the request.\n     * A maximum of 25 transaction meta data pairs is returned. For details about sorting and discussion of the second parameter see Incoming transactions.\n     * @param address - The address of the account.\n     * @param hash - (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned.\n     * @param id - (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash.\n     * @return Observable Transaction[] \n     */\n    outgoingTransactions(address: Address, hash?: string, id?: string): Observable Transaction[] ;\n\n    /**\n     * Paginaged version of outgoingTransactions request\n     * @param address\n     * @param hash\n     * @returns {OutgoingTransactionsPageable}\n     */\n    outgoingTransactionsPaginated(address: Address, hash?: string): Pageable Transaction[] ;\n\n    /**\n     * Gets an array of transaction meta data pairs for which an account is the sender or receiver.\n     * A maximum of 25 transaction meta data pairs is returned.\n     * For details about sorting and discussion of the second parameter see Incoming transactions.\n     * @param address - The address of the account.\n     * @param hash - (Optional) The 256 bit sha3 hash of the transaction up to which transactions are returned.\n     * @param id - (Optional) The transaction id up to which transactions are returned. This parameter will prevail over hash.\n     * @return Observable Transaction[] \n     */\n    allTransactions(address: Address, hash?: string, id?: string): Observable Transaction[] ;\n\n    /**\n     * Paginaged version of allTransactions request\n     * @param address\n     * @param hash\n     * @returns {AllTransactionsPageable}\n     */\n    allTransactionsPaginated(address: Address, hash?: string): Pageable Transaction[] ;\n\n    /**\n     * Gets the array of transactions for which an account is the sender or receiver and which have not yet been included in a block\n     * @param address - NEM Address\n     * @return Observable Transaction[] \n     */\n    unconfirmedTransactions(address: Address): Observable Transaction[] ;\n\n    /**\n     * Gets an array of harvest info objects for an account.\n     * @param address - Address\n     * @param id - string (optional)\n     * @return Observable AccountHarvestInfo[] \n     */\n    getHarvestInfoDataForAnAccount(address: Address, id?: string): Observable AccountHarvestInfo[] ;\n\n    /**\n     * Paginaged version of allTransactions request\n     * @param address\n     * @param id\n     * @returns {HarvestInfoPageable}\n     */\n    getHarvestInfoDataForAnAccountPaginated(address: Address, id?: string): Pageable AccountHarvestInfo[] ;\n\n    /**\n     * Gets an array of account importance view model objects.\n     * @return Observable AccountImportanceInfo[] \n     */\n    getAccountImportances(): Observable AccountImportanceInfo[] ;\n\n    /**\n     * Gets an array of namespace objects for a given account address.\n     * The parent parameter is optional. If supplied, only sub-namespaces of the parent namespace are returned.\n     * @param address - Address\n     * @param parent - The optional parent namespace id.\n     * @param id - The optional namespace database id up to which namespaces are returned.\n     * @param pageSize - The (optional) number of namespaces to be returned.\n     * @return Observable Namespace[] \n     */\n    getNamespaceOwnedByAddress(address: Address, parent?: string, id?: string, pageSize?: number): Observable Namespace[] ;\n\n    /**\n     * Gets an array of mosaic definition objects for a given account address. The parent parameter is optional.\n     * If supplied, only mosaic definitions for the given parent namespace are returned.\n     * The id parameter is optional and allows retrieving mosaic definitions in batches of 25 mosaic definitions.\n     * @param address - The address of the account.\n     * @param parent - The optional parent namespace id.\n     * @param id - The optional mosaic definition database id up to which mosaic definitions are returned.\n     * @return Observable MosaicDefinition[] \n     */\n    getMosaicCreatedByAddress(address: Address, parent?: string, id?: string): Observable MosaicDefinition[] ;\n\n    /**\n     * Gets an array of mosaic objects for a given account address.\n     * @param address - Address\n     * @return Observable Mosaic[] \n     */\n    getMosaicOwnedByAddress(address: Address): Observable Mosaic[] ;\n\n    /**\n     * Unlocks an account (starts harvesting).\n     * @param host - string\n     * @param privateKey - string\n     * @return Observable boolean \n     */\n    unlockHarvesting(host: string, privateKey: string): Observable boolean ;\n\n    /**\n     * Locks an account (stops harvesting).\n     * @param host - string\n     * @param privateKey - string\n     * @return Observable boolean \n     */\n    lockHarvesting(host: string, privateKey: string): Observable boolean ;\n\n    /**\n     * Each node can allow users to harvest with their delegated key on that node.\n     * The NIS configuration has entries for configuring the maximum number of allowed harvesters and optionally allow harvesting only for certain account addresses.\n     * The unlock info gives information about the maximum number of allowed harvesters and how many harvesters are already using the node.\n     * @return Observable NodeHarvestInfo \n     */\n    unlockInfo(): Observable NodeHarvestInfo ;\n\n    /**\n     * Gets historical information for an account.\n     * @param address - The address of the account.\n     * @param startHeight - The block height from which on the data should be supplied.\n     * @param endHeight - The block height up to which the data should be supplied. The end height must be greater than or equal to the start height.\n     * @param increment - The value by which the height is incremented between each data point. The value must be greater than 0. NIS can supply up to 1000 data points with one request. Requesting more than 1000 data points results in an error.\n     * @return Observable AccountHistoricalInfo[] \n     */\n    getHistoricalAccountData(address: Address, startHeight: number, endHeight: number, increment: number): Observable AccountHistoricalInfo[] ;\n}", 
            "title": "AccountHttp definition"
        }, 
        {
            "location": "/documentation/account/#accounthttp-usage", 
            "text": "import {AccountHttp, NEMLibrary, NetworkTypes, Address} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address( );\n\nconst accountHttp = new AccountHttp({domain:  104.128.226.60 });\naccountHttp.getFromAddress(address).subscribe(accountInfoWithMetaData =  {\n    console.log(accountInfoWithMetaData);\n});  Output:  AccountInfoWithMetaData {\n  balance: \n   Balance {\n     balance: 50481110745315,\n     vestedBalance: 50480744575985,\n     unvestedBalance: 366169330 },\n  importance: 0.005735794657626706,\n  publicAccount: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C',\n        networkType: 152 },\n     publicKey: '74375c15c6ce6bdbde59be88a069745a0de34444ea933f8c9f46ef407cf30196' },\n  harvestedBlocks: 116319,\n  cosignatoriesCount: undefined,\n  minCosignatories: undefined,\n  status: 'UNLOCKED',\n  remoteStatus: 'INACTIVE',\n  cosignatoryOf: [],\n  cosignatories: [] }  Run the code", 
            "title": "AccountHttp usage"
        }, 
        {
            "location": "/documentation/account/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/documentation/account/#publicaccount", 
            "text": "/**\n * Public account\n */\nexport declare class PublicAccount {\n\n    readonly address: Address;\n    readonly publicKey: string;\n\n    /**\n     * @returns {boolean}\n     */\n    hasPublicKey(): boolean;\n\n    /**\n     * Creates a new PublicAccount from a public key\n     * @param publicKey\n     * @returns {PublicAccount}\n     */\n    static createWithPublicKey(publicKey: string): PublicAccount;\n}", 
            "title": "PublicAccount"
        }, 
        {
            "location": "/documentation/account/#address", 
            "text": "/**\n * Address model\n */\nexport declare class Address {\n\n    private readonly value;\n    private readonly networkType;\n    constructor(address: string);\n\n    /**\n     * Get address in plain format ex: TALICEROONSJCPHC63F52V6FY3SDMSVAEUGHMB7C\n     * @returns {string}\n     */\n    plain(): string;\n\n    /**\n     * Get address in pretty format ex: TALICE-ROONSJ-CPHC63-F52V6F-Y3SDMS-VAEUGH-MB7C\n     * @returns {string}\n     */\n    pretty(): string;\n\n    /**\n     * Address network\n     * @returns {number}\n     */\n    network(): NetworkTypes;\n}", 
            "title": "Address"
        }, 
        {
            "location": "/documentation/account/#balance", 
            "text": "/**\n * Balance model\n */\nexport declare class Balance {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: number;\n\n    /**\n     * The vested part of the balance of the account in micro NEM.\n     */\n    readonly vestedBalance: number;\n\n    /**\n     * The unvested part of the balance of the account in micro NEM.\n     */\n    readonly unvestedBalance: number;\n}", 
            "title": "Balance"
        }, 
        {
            "location": "/documentation/account/#accountinfo", 
            "text": "export declare enum RemoteStatus {\n    REMOTE =  REMOTE ,\n    ACTIVATING =  ACTIVATING ,\n    ACTIVE =  ACTIVE ,\n    DEACTIVATING =  DEACTIVATING ,\n    INACTIVE =  INACTIVE ,\n}\nexport declare enum Status {\n    UNKNOWN =  UNKNOWN ,\n    LOCKED =  LOCKED ,\n    UNLOCKED =  UNLOCKED ,\n}\n\n/**\n * The account structure describes basic information for an account.\n */\nexport declare class AccountInfo {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: Balance;\n\n    /**\n     * The importance of the account.\n     */\n    readonly importance: number;\n\n    /**\n     * The public key of the account.\n     */\n    readonly publicAccount: PublicAccount;\n\n    /**\n     * The number blocks that the account already harvested.\n     */\n    readonly harvestedBlocks: number;\n\n    /**\n     * Total number of cosignatories\n     */\n    readonly cosignatoriesCount?: number;\n\n    /**\n     * Minimum number of cosignatories needed for a transaction to be processed\n     */\n    readonly minCosignatories?: number;\n}\n\nexport declare class AccountInfoWithMetaData extends AccountInfo {\n\n    /**\n     * The harvesting status of a queried account\n     */\n    readonly status: Status;\n\n    /**\n     * The status of remote harvesting of a queried account\n     */\n    readonly remoteStatus: RemoteStatus;\n\n    /**\n     * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array.\n     */\n    readonly cosignatoryOf: AccountInfo[];\n\n    /**\n     * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account.\n     */\n    readonly cosignatories: AccountInfo[];\n}\n\nexport declare class AccountStatus {\n\n    /**\n     * The harvesting status of a queried account\n     */\n    readonly status: Status;\n\n    /**\n     * The status of remote harvesting of a queried account\n     */\n    readonly remoteStatus: RemoteStatus;\n\n    /**\n     * JSON array of AccountInfo structures. The account is cosignatory for each of the accounts in the array.\n     */\n    readonly cosignatoryOf: AccountInfo[];\n\n    /**\n     * JSON array of AccountInfo structures. The array holds all accounts that are a cosignatory for this account.\n     */\n    readonly cosignatories: AccountInfo[];\n}", 
            "title": "AccountInfo"
        }, 
        {
            "location": "/documentation/account/#accountharvestinfo", 
            "text": "/**\n * A HarvestInfo object contains information about a block that an account harvested.\n */\nexport declare class AccountHarvestInfo {\n\n    /**\n     * The number of seconds elapsed since the creation of the nemesis block.\n     */\n    readonly timeStamp: number;\n\n    /**\n     * The database id for the harvested block.\n     */\n    readonly id: number;\n\n    /**\n     * The block difficulty. The initial difficulty was set to 100000000000000. The block difficulty is always between one tenth and ten times the initial difficulty.\n     */\n    readonly difficulty: number;\n\n    /**\n     * The total fee collected by harvesting the block.\n     */\n    readonly totalFee: number;\n\n    /**\n     * The height of the harvested block.\n     */\n    readonly height: number;\n}", 
            "title": "AccountHarvestInfo"
        }, 
        {
            "location": "/documentation/account/#accounthistoricalinfo", 
            "text": "/**\n * Nodes can support a feature for retrieving historical data of accounts.\n * If this is supported, it returns an array of AccountHistoricalInfo\n */\nexport declare class AccountHistoricalInfo {\n\n    /**\n     * The balance of the account in micro NEM.\n     */\n    readonly balance: Balance;\n\n    /**\n     * The importance of the account.\n     */\n    readonly importance: number;\n\n    /**\n     * The public key of the account.\n     */\n    readonly address: Address;\n\n    /**\n     * The page rank part of the importance.\n     */\n    readonly pageRank: number;\n}", 
            "title": "AccountHistoricalInfo"
        }, 
        {
            "location": "/documentation/account/#accountimportanceinfo", 
            "text": "/**\n * Each account is assigned an importance in the NEM network. The ability of an account to generate new blocks is proportional to its importance. The importance is a number between 0 and 1.\n */\nexport declare class AccountImportanceInfo {\n\n    /**\n     * The address of the account.\n     */\n    readonly address: Address;\n\n    /**\n     * Substructure that describes the importance of the account.\n     */\n    readonly importance: AccountImportanceData;\n}\n\n/**\n * Substructure that describes the importance of the account.\n */\nexport declare class AccountImportanceData {\n    /**\n     * Indicates if the fields  score ,  ev  and  height  are available.isSet can have the values 0 or 1. In case isSet is 0 the fields are not available.\n     */\n    readonly isSet: number;\n\n    /**\n     * The importance of the account. The importance ranges between 0 and 1.\n     */\n    readonly score?: number;\n\n    /**\n     * The page rank portion of the importance. The page rank ranges between 0 and 1.\n     */\n    readonly ev?: number;\n\n    /**\n     * The height at which the importance calculation was performed.\n     */\n    readonly height?: number;\n}", 
            "title": "AccountImportanceInfo"
        }, 
        {
            "location": "/documentation/account/#nodeharvestinfo", 
            "text": "export declare class NodeHarvestInfo {\n\n    /**\n     * Maximum unlocked slots\n     */\n    readonly maxUnlocked: number;\n\n    /**\n     * Number of slots unlocked\n     */\n    readonly numUnlocked: number;\n}", 
            "title": "NodeHarvestInfo"
        }, 
        {
            "location": "/documentation/transaction/", 
            "text": "Initiating transactions requests\n\n\nTransactions are the way of transferring NEM and/or messages from one account to another. Once a transaction is initiated, it is still unconfirmed and thus not yet accepted by the network. At this point it is not yet clear if it will get included in a block. Never rely on a transaction which has the state 'unconfirmed'. Once it is included in a block, the transaction gets processed and, in case of a transfer transaction, the amount stated in the transaction gets transferred from the sender's account to the recipient's account. Additionally the transaction fee is deducted from the sender's account. The transaction is said to have 0 confirmations at this point. When another block is added to the block chain the transaction has 1 confirmation. The next block added to the chain will give it 2 confirmations and so on.\n\n\nCrypto currencies have the ability to roll back part the block chain. This is essential for being able to resolve forks of the block chain. There is however a maximum number of blocks that can be rolled back, this is called the rewrite limit. Hence forks can only be resolved up to a certain depth too. NEM has a rewrite limit of 360 blocks. Once a transaction has more than 360 confirmations, it cannot be reversed. In real life, forks that are deeper than 20 blocks do not happen, unless there was some severe problem with the block chain due to a bug in the code or an attack of some kind.\n\n\nOfficial Source\n\n\nTransactionHttp definition\n\n\nexport declare class TransactionHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Send the signed transaction\n     * @param transaction\n     * @returns Observable\nNemAnnounceResult\n\n     */\n    announceTransaction(transaction: SignedTransaction): Observable\nNemAnnounceResult\n;\n}\n\n\n\n\nTransactionHttp usage\n\n\nimport {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, SignedTransaction\n} from \nnem-library\n;\nimport {XEM} from \nnem-library/dist/src/models/mosaic/XEM\n;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY;\n\nconst cosignerAccount = Account.createWithPrivateKey(privateKey);\n\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n),\n    XEM(2),\n    EmptyMessage\n);\n\nconst multisigTransaction = MultisigTransaction.create(\n    TimeWindow.createWithDeadline(),\n    transferTransaction,\n    PublicAccount.createWithPublicKey(multisigAccountPublicKey)\n);\n\nconst transactionHttp = new TransactionHttp({domain: \n104.128.226.60\n});\n\nconst signedTransaction: SignedTransaction = cosignerAccount.signTransaction(multisigTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =\n console.log(x));\n\n\n\n\nOutput\n\n\n\nNemAnnounceResult {\n  type: 1,\n  code: 1,\n  message: 'SUCCESS',\n  transactionHash: { data: '56b4d3e38cb5b707d4b96776116396c2885fd09be6945637f5657204528001b7' },\n  innerTransactionHash: { data: 'a61ce8d0df9aac98ae68e7d88a2f2bb453deb202fd95cf3cf375fde35e4e6794' } }\n\n\n\n\n\nRun the code\n\n\nModels\n\n\nTimeWindow\n\n\nexport declare class TimeWindow {\n    static timestampNemesisBlock: number;\n\n    /**\n     * The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block.\n     * If a transaction does not get included in a block before the deadline is reached, it is deleted.\n     */\n    deadline: LocalDateTime;\n\n    /**\n     * The number of seconds elapsed since the creation of the nemesis block.\n     */\n    timeStamp: LocalDateTime;\n\n    /**\n     * @param deadline\n     * @param chronoUnit\n     * @returns {TimeWindow}\n     */\n    static createWithDeadline(deadline?: number, chronoUnit?: ChronoUnit): TimeWindow;\n}\n\n\n\n\n\nTransactionInfo\n\n\nexport declare class TransactionInfo {\n\n    /**\n     * The height of the block in which the transaction was included.\n     */\n    readonly height: number;\n\n    /**\n     *  The id of the transaction.\n     */\n    readonly id: number;\n\n    /**\n     *  The transaction hash.\n     */\n    readonly hash: HashData;\n\n    /**\n     * constructor\n     * @param height\n     * @param id\n     * @param hash\n     */\n    constructor(height: number, id: number, hash: HashData);\n}\n\nexport declare class MultisigTransactionInfo extends TransactionInfo {\n\n    /**\n     * The hash of the inner transaction. This entry is only available for multisig transactions.\n     */\n    readonly innerHash: HashData;\n\n    /**\n     * constructor\n     * @param height\n     * @param id\n     * @param hash\n     * @param innerHash\n     */\n    constructor(height: number, id: number, hash: HashData, innerHash: HashData);\n}\n\n\n\n\n\nTransactionTypes\n\n\n/**\n * Static class containing transaction type constants.\n */\nexport declare class TransactionTypes {\n\n    /**\n     * Transfer Transaction\n     * @type {number}\n     */\n    static readonly TRANSFER: number;\n\n    /**\n     * Importance transfer transaction.\n     * @type {number}\n     */\n    static readonly IMPORTANCE_TRANSFER: number;\n\n    /**\n     * A new asset transaction.\n     * @type {number}\n     */\n    static readonly ASSET_NEW: number;\n\n    /**\n     * An asset ask transaction.\n     * @type {number}\n     */\n    static readonly ASSET_ASK: number;\n\n    /**\n     * An asset bid transaction.\n     * @type {number}\n     */\n    static readonly ASSET_BID: number;\n\n    /**\n     * A snapshot transaction.\n     * @type {number}\n     */\n    static readonly SNAPSHOT: number;\n\n    /**\n     * A multisig change transaction (e.g. announce an account as multi-sig).\n     * @type {number}\n     */\n    static readonly MULTISIG_AGGREGATE_MODIFICATION: number;\n\n    /**\n     * A multisig signature transaction.\n     * @type {number}\n     */\n    static readonly MULTISIG_SIGNATURE: number;\n\n    /**\n     * A multisig transaction.\n     * @type {number}\n     */\n    static readonly MULTISIG: number;\n\n    /**\n     * A provision namespace transaction.\n     * @type {number}\n     */\n    static readonly PROVISION_NAMESPACE: number;\n\n    /**\n     * A mosaic definition creation transaction.\n     * @type {number}\n     */\n    static readonly MOSAIC_DEFINITION_CREATION: number;\n\n    /**\n     * A mosaic supply change transaction.\n     * @type {number}\n     */\n    static readonly MOSAIC_SUPPLY_CHANGE: number;\n\n    /**\n     * Gets all multisig embeddable types.\n     * @returns {number[]}\n     */\n    static getMultisigEmbeddableTypes(): number[];\n\n    /**\n     * Gets all block embeddable types.\n     * @returns {number[]}\n     */\n    static getBlockEmbeddableTypes(): number[];\n\n    /**\n     * Gets all active types.\n     * @returns {number[]}\n     */\n    static getActiveTypes(): number[];\n}\n\n\n\n\n\nTransaction\n\n\n/**\n * An abstract transaction class that serves as the base class of all NEM transactions.\n */\nexport declare abstract class Transaction {\n\n    /**\n     * The transaction type.\n     */\n    readonly type: number;\n\n    /**\n     * The version of the structure.\n     */\n    readonly version: number;\n\n    /**\n     * The transaction signature (missing if part of a multisig transaction).\n     */\n    readonly signature?: string;\n\n    /**\n     * The public key of the account that created the transaction.\n     */\n    signer?: string;\n\n    /**\n     * TimeWindow\n     */\n    readonly timeWindow: TimeWindow;\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly abstract fee: number;\n\n    /**\n     * Transactions meta data object contains additional information about the transaction.\n     */\n    protected readonly transactionInfo?: TransactionInfo;\n\n    /**\n     * Checks if the transaction has been confirmed and included in a block\n     */\n    isConfirmed(): boolean;\n\n    /**\n     * Get transaction info\n     */\n    getTransactionInfo(): TransactionInfo;\n}\n\n\n\n\n\nTransferTransaction\n\n\n/**\n * Transfer transactions contain data about transfers of XEM or mosaics to another account.\n */\nexport declare class TransferTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The address of the recipient.\n     */\n    readonly recipient: Address;\n\n    /**\n     * The amount of micro NEM that is transferred from sender to recipient.\n     */\n    readonly amount: number;\n\n    /**\n     * Optionally a transaction can contain a message. In this case the transaction contains a message substructure. If not the field is null.\n     */\n    readonly message: PlainMessage | EncryptedMessage;\n\n    /**\n     * The array of Mosaic objects.\n     */\n    readonly mosaics?: Mosaic[];\n\n    /**\n     * Create a TransferTransaction object\n     * @param timeWindow\n     * @param recipient\n     * @param amount\n     * @param message\n     * @param mosaics\n     * @returns {TransferTransaction}\n     */\n    static create(timeWindow: TimeWindow, recipient: Address, amount: number, message: PlainMessage | EncryptedMessage): TransferTransaction;\n\n    /**\n     * Create a TransferTransaction object\n     * @param timeWindow\n     * @param recipient\n     * @param mosaics\n     * @param message\n     * @returns {TransferTransaction}\n     */\n    static createWithMosaics(timeWindow: TimeWindow, recipient: Address, mosaics: Mosaic[], message: PlainMessage | EncryptedMessage): TransferTransaction;\n}\n\n\n\n\n\nMessage\n\n\n/**\n * Message model\n */\nexport declare abstract class Message {\n\n    /**\n     * Message payload\n     */\n    readonly payload: string;\n\n}\n\n\n\n\n\nPlainMessage\n\n\n/**\n * Plain Message model\n */\nexport declare class PlainMessage extends Message {\n\n    constructor(payload: string);\n\n    /**\n     * Create new constructor\n     * @returns {boolean}\n     */\n    static create(message: string): PlainMessage;\n\n    /**\n     * Message string\n     * @returns {string}\n     */\n    plain(): string;\n\n}\nexport declare const EmptyMessage: PlainMessage;\n\n\n\n\n\nEncryptedMessage\n\n\n/**\n * Encrypted Message model\n */\nexport declare class EncryptedMessage extends Message {\n    readonly recipientPublicAccount?: PublicAccount;\n}\n\n\n\n\n\n\nImportanceTransferTransaction\n\n\n\nexport declare enum ImportanceMode {\n    Activate = 1,\n    Deactivate = 2,\n}\n\n/**\n * NIS has the ability to transfer the importance of one account to another account for harvesting.\n * The account receiving the importance is called the remote account.\n * Importance transfer transactions are part of the secure harvesting feature of NEM.\n * Once an importance transaction has been included in a block it needs 6 hours to become active.\n */\nexport declare class ImportanceTransferTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The public key of the receiving account as hexadecimal string.\n     */\n    readonly remoteAccount: PublicAccount;\n\n    /**\n     * The mode, activate or deactivate\n     */\n    readonly mode: ImportanceMode;\n\n    /**\n     * Create a ImportanceTransferTransaction object\n     * @param timeWindow\n     * @param mode\n     * @param remoteAccount\n     * @returns {ImportanceTransferTransaction}\n     */\n    static create(timeWindow: TimeWindow, mode: ImportanceMode, remoteAccount: PublicAccount): ImportanceTransferTransaction;\n}\n\n\n\n\n\nProvisionNamespaceTransaction\n\n\n/**\n * Accounts can rent a namespace for one year and after a year renew the contract. This is done via a ProvisionNamespaceTransaction.\n */\nexport declare class ProvisionNamespaceTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The Address to which the rental fee is transferred.\n     */\n    readonly rentalFeeSink: Address;\n\n    /**\n     * The fee for renting the namespace.\n     */\n    readonly rentalFee: number;\n\n    /**\n     * The parent namespace. This can be undefined if the transaction rents a root namespace.\n     */\n    readonly parent?: string;\n\n    /**\n     * The new part which is concatenated to the parent with a '.' as separator.\n     */\n    readonly newPart: string;\n\n    /**\n     * Create a ProvisionNamespaceTransaction object\n     * @param timeWindow\n     * @param newPart\n     * @param parent\n     * @returns {ProvisionNamespaceTransaction}\n     */\n    static create(timeWindow: TimeWindow, newPart: string, parent?: string): ProvisionNamespaceTransaction;\n}\n\n\n\n\nMosaicDefinitionCreationTransaction\n\n\n/**\n * Before a mosaic can be created or transferred, a corresponding definition of the mosaic has to be created and published to the network.\n * This is done via a mosaic definition creation transaction.\n */\nexport declare class MosaicDefinitionCreationTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The fee for the creation of the mosaic.\n     */\n    readonly creationFee: number;\n\n    /**\n     * The public account to which the creation fee is tranferred.\n     */\n    readonly creationFeeSink: Address;\n\n    /**\n     * The actual mosaic definition.\n     */\n    readonly mosaicDefinition: MosaicDefinition;\n\n    /**\n     * Create a MosaicDefinitionCreationTransaction object\n     * @param timeWindow\n     * @param mosaicDefinition\n     * @returns {MosaicDefinitionCreationTransaction}\n     */\n    static create(timeWindow: TimeWindow, mosaicDefinition: MosaicDefinition): MosaicDefinitionCreationTransaction;\n}\n\n\n\n\n\nMosaicSupplyChangeTransaction\n\n\nexport declare enum MosaicSupplyType {\n    Increase = 1,\n    Decrease = 2,\n}\n\n/**\n * In case a mosaic definition has the property 'supplyMutable' set to true, the creator of the mosaic definition can change the supply, i.e. increase or decrease the supply.\n */\nexport declare class MosaicSupplyChangeTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The mosaic id.\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The supply type.\n     */\n    readonly supplyType: MosaicSupplyType;\n\n    /**\n     * The supply change in units for the mosaic.\n     */\n    readonly delta: number;\n\n    /**\n     * Create a MosaicSupplyChangeTransaction object\n     * @param timeWindow\n     * @param mosaicId\n     * @param supplyType\n     * @param delta\n     * @returns {MosaicSupplyChangeTransaction}\n     */\n    static create(timeWindow: TimeWindow, mosaicId: MosaicId, supplyType: MosaicSupplyType, delta: number): MosaicSupplyChangeTransaction;\n}\n\n\n\n\n\nMultisigTransaction\n\n\n/**\n * Multisig transaction are the only way to make transaction from a multisig account to another account.\n * A multisig transaction carries another transaction inside (often referred to as \ninner\n transaction).\n * The inner transaction can be a transfer, an importance transfer or an aggregate modification transaction.\n * A multisig transaction also has multisig signature transactions from the cosignatories of the multisig account inside.\n */\nexport declare class MultisigTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction.\n     */\n    readonly fee: number;\n\n    /**\n     * The JSON array of MulsigSignatureTransaction objects.\n     */\n    readonly signatures: MultisigSignatureTransaction[];\n\n    /**\n     * The inner transaction. The inner transaction can be a transfer transaction, an importance transfer transaction or a multisig aggregate modification transaction.\n     * The inner transaction does not have a valid signature.\n     */\n    readonly otherTransaction: Transaction;\n\n    /**\n     * Hash data\n     */\n    readonly hashData?: HashData;\n\n    /**\n     * Check if transaction is pending to sign\n     * @returns {boolean}\n     */\n    isPendingToSign(): boolean;\n\n    /**\n     * Create a MultisigTransaction object\n     * @param timeWindow\n     * @param otherTrans\n     * @param multisig\n     * @returns {MultisigTransaction}\n     */\n    static create(timeWindow: TimeWindow, otherTrans: Transaction, multisig: PublicAccount): MultisigTransaction;\n}\n\n\n\n\n\nMultisigAggregateModificationTransaction\n\n\n/**\n * Multisig aggregate modification transactions are part of the NEM's multisig account system.\n * A multisig aggregate modification transaction holds an array of multisig cosignatory modifications and a single multisig minimum cosignatories modification inside the transaction.\n * A multisig aggregate modification transaction can be wrapped by a multisig transaction.\n */\nexport declare class MultisigAggregateModificationTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    fee: number;\n\n    /**\n     * Value indicating the relative change of the minimum cosignatories.\n     */\n    readonly relativeChange?: number;\n\n    /**\n     * The JSON array of multisig modifications.\n     */\n    readonly modifications: CosignatoryModification[];\n\n    /**\n     * Create a MultisigAggregateModificationTransaction object\n     * @param timeWindow\n     * @param modifications\n     * @param relativeChange\n     * @returns {MultisigAggregateModificationTransaction}\n     */\n    static create(timeWindow: TimeWindow, modifications: CosignatoryModification[], relativeChange?: number): MultisigAggregateModificationTransaction;\n}\n\n/**\n * The type of modification. Possible values are:\n * 1: Add a new cosignatory.\n * 2: Delete an existing cosignatory.\n */\nexport declare enum CosignatoryModificationAction {\n    ADD = 1,\n    DELETE = 2,\n}\n\nexport declare class CosignatoryModification {\n    readonly cosignatoryAccount: PublicAccount;\n    readonly action: CosignatoryModificationAction;\n\n    /**\n     * constructor\n     * @param cosignatoryAccount\n     * @param action\n     */\n    constructor(cosignatoryAccount: PublicAccount, action: CosignatoryModificationAction);\n}\n\n\n\n\n\nMultisigSignatureTransaction\n\n\n/**\n * Multisig signature transactions are part of the NEM's multisig account system. Multisig signature transactions are included in the corresponding multisig transaction and are the way a cosignatory of a multisig account can sign a multisig transaction for that account.\n */\nexport declare class MultisigSignatureTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The address of the corresponding multisig account.\n     */\n    readonly otherAccount: Address;\n\n    /**\n     * The hash of the inner transaction of the corresponding multisig transaction.\n     */\n    readonly otherHash: HashData;\n\n    /**\n     * Create a MultisigSignatureTransaction object\n     * @param timeWindow\n     * @param otherAccount\n     * @param otherHash\n     * @returns {MultisigSignatureTransaction}\n     */\n    static create(timeWindow: TimeWindow, otherAccount: Address, otherHash: HashData): MultisigSignatureTransaction;\n}\n\n\n\n\n\nSignedTransaction\n\n\n/**\n * SignedTransaction object is used to transfer the transaction data and the signature to NIS in order to initiate and broadcast a transaction.\n */\nexport interface SignedTransaction {\n\n    /**\n     * The transaction data as string.\n     */\n    readonly data: string;\n\n    /**\n     * The signature for the transaction as hexadecimal string.\n     */\n    readonly signature: string;\n}\n\n\n\n\n\nNemAnnounceResult\n\n\n\nexport declare enum TypeNemAnnounceResult {\n    Validation = 1,\n    HeartBeat = 2,\n    Status = 4,\n}\n\nexport declare type CodeNemAnnounceResult = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19;\n\n/**\n * The NemAnnounceResult extends the NemRequestResult by supplying the additional fields 'transactionHash' and in case of a multisig transaction 'innerTransactionHash'.\n */\nexport declare class NemAnnounceResult {\n\n    /**\n     * The type is dependent on the request which was answered.\n     */\n    readonly type: TypeNemAnnounceResult;\n\n    /**\n     * The meaning of the code is dependent on the type.\n     */\n    readonly code: CodeNemAnnounceResult;\n\n    /**\n     * Error or success message\n     */\n    readonly message: string;\n\n    /**\n     * The JSON hash object of the transaction.\n     */\n    readonly transactionHash: HashData;\n\n    /**\n     * The JSON hash object of the inner transaction or null if the transaction is not a multisig transaction.\n     */\n    readonly innerTransactionHash: HashData;\n}", 
            "title": "Transaction"
        }, 
        {
            "location": "/documentation/transaction/#initiating-transactions-requests", 
            "text": "Transactions are the way of transferring NEM and/or messages from one account to another. Once a transaction is initiated, it is still unconfirmed and thus not yet accepted by the network. At this point it is not yet clear if it will get included in a block. Never rely on a transaction which has the state 'unconfirmed'. Once it is included in a block, the transaction gets processed and, in case of a transfer transaction, the amount stated in the transaction gets transferred from the sender's account to the recipient's account. Additionally the transaction fee is deducted from the sender's account. The transaction is said to have 0 confirmations at this point. When another block is added to the block chain the transaction has 1 confirmation. The next block added to the chain will give it 2 confirmations and so on.  Crypto currencies have the ability to roll back part the block chain. This is essential for being able to resolve forks of the block chain. There is however a maximum number of blocks that can be rolled back, this is called the rewrite limit. Hence forks can only be resolved up to a certain depth too. NEM has a rewrite limit of 360 blocks. Once a transaction has more than 360 confirmations, it cannot be reversed. In real life, forks that are deeper than 20 blocks do not happen, unless there was some severe problem with the block chain due to a bug in the code or an attack of some kind.  Official Source", 
            "title": "Initiating transactions requests"
        }, 
        {
            "location": "/documentation/transaction/#transactionhttp-definition", 
            "text": "export declare class TransactionHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Send the signed transaction\n     * @param transaction\n     * @returns Observable NemAnnounceResult \n     */\n    announceTransaction(transaction: SignedTransaction): Observable NemAnnounceResult ;\n}", 
            "title": "TransactionHttp definition"
        }, 
        {
            "location": "/documentation/transaction/#transactionhttp-usage", 
            "text": "import {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, SignedTransaction\n} from  nem-library ;\nimport {XEM} from  nem-library/dist/src/models/mosaic/XEM ;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY;\n\nconst cosignerAccount = Account.createWithPrivateKey(privateKey);\n\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ),\n    XEM(2),\n    EmptyMessage\n);\n\nconst multisigTransaction = MultisigTransaction.create(\n    TimeWindow.createWithDeadline(),\n    transferTransaction,\n    PublicAccount.createWithPublicKey(multisigAccountPublicKey)\n);\n\nconst transactionHttp = new TransactionHttp({domain:  104.128.226.60 });\n\nconst signedTransaction: SignedTransaction = cosignerAccount.signTransaction(multisigTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =  console.log(x));  Output  \nNemAnnounceResult {\n  type: 1,\n  code: 1,\n  message: 'SUCCESS',\n  transactionHash: { data: '56b4d3e38cb5b707d4b96776116396c2885fd09be6945637f5657204528001b7' },\n  innerTransactionHash: { data: 'a61ce8d0df9aac98ae68e7d88a2f2bb453deb202fd95cf3cf375fde35e4e6794' } }  Run the code", 
            "title": "TransactionHttp usage"
        }, 
        {
            "location": "/documentation/transaction/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/documentation/transaction/#timewindow", 
            "text": "export declare class TimeWindow {\n    static timestampNemesisBlock: number;\n\n    /**\n     * The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block.\n     * If a transaction does not get included in a block before the deadline is reached, it is deleted.\n     */\n    deadline: LocalDateTime;\n\n    /**\n     * The number of seconds elapsed since the creation of the nemesis block.\n     */\n    timeStamp: LocalDateTime;\n\n    /**\n     * @param deadline\n     * @param chronoUnit\n     * @returns {TimeWindow}\n     */\n    static createWithDeadline(deadline?: number, chronoUnit?: ChronoUnit): TimeWindow;\n}", 
            "title": "TimeWindow"
        }, 
        {
            "location": "/documentation/transaction/#transactioninfo", 
            "text": "export declare class TransactionInfo {\n\n    /**\n     * The height of the block in which the transaction was included.\n     */\n    readonly height: number;\n\n    /**\n     *  The id of the transaction.\n     */\n    readonly id: number;\n\n    /**\n     *  The transaction hash.\n     */\n    readonly hash: HashData;\n\n    /**\n     * constructor\n     * @param height\n     * @param id\n     * @param hash\n     */\n    constructor(height: number, id: number, hash: HashData);\n}\n\nexport declare class MultisigTransactionInfo extends TransactionInfo {\n\n    /**\n     * The hash of the inner transaction. This entry is only available for multisig transactions.\n     */\n    readonly innerHash: HashData;\n\n    /**\n     * constructor\n     * @param height\n     * @param id\n     * @param hash\n     * @param innerHash\n     */\n    constructor(height: number, id: number, hash: HashData, innerHash: HashData);\n}", 
            "title": "TransactionInfo"
        }, 
        {
            "location": "/documentation/transaction/#transactiontypes", 
            "text": "/**\n * Static class containing transaction type constants.\n */\nexport declare class TransactionTypes {\n\n    /**\n     * Transfer Transaction\n     * @type {number}\n     */\n    static readonly TRANSFER: number;\n\n    /**\n     * Importance transfer transaction.\n     * @type {number}\n     */\n    static readonly IMPORTANCE_TRANSFER: number;\n\n    /**\n     * A new asset transaction.\n     * @type {number}\n     */\n    static readonly ASSET_NEW: number;\n\n    /**\n     * An asset ask transaction.\n     * @type {number}\n     */\n    static readonly ASSET_ASK: number;\n\n    /**\n     * An asset bid transaction.\n     * @type {number}\n     */\n    static readonly ASSET_BID: number;\n\n    /**\n     * A snapshot transaction.\n     * @type {number}\n     */\n    static readonly SNAPSHOT: number;\n\n    /**\n     * A multisig change transaction (e.g. announce an account as multi-sig).\n     * @type {number}\n     */\n    static readonly MULTISIG_AGGREGATE_MODIFICATION: number;\n\n    /**\n     * A multisig signature transaction.\n     * @type {number}\n     */\n    static readonly MULTISIG_SIGNATURE: number;\n\n    /**\n     * A multisig transaction.\n     * @type {number}\n     */\n    static readonly MULTISIG: number;\n\n    /**\n     * A provision namespace transaction.\n     * @type {number}\n     */\n    static readonly PROVISION_NAMESPACE: number;\n\n    /**\n     * A mosaic definition creation transaction.\n     * @type {number}\n     */\n    static readonly MOSAIC_DEFINITION_CREATION: number;\n\n    /**\n     * A mosaic supply change transaction.\n     * @type {number}\n     */\n    static readonly MOSAIC_SUPPLY_CHANGE: number;\n\n    /**\n     * Gets all multisig embeddable types.\n     * @returns {number[]}\n     */\n    static getMultisigEmbeddableTypes(): number[];\n\n    /**\n     * Gets all block embeddable types.\n     * @returns {number[]}\n     */\n    static getBlockEmbeddableTypes(): number[];\n\n    /**\n     * Gets all active types.\n     * @returns {number[]}\n     */\n    static getActiveTypes(): number[];\n}", 
            "title": "TransactionTypes"
        }, 
        {
            "location": "/documentation/transaction/#transaction", 
            "text": "/**\n * An abstract transaction class that serves as the base class of all NEM transactions.\n */\nexport declare abstract class Transaction {\n\n    /**\n     * The transaction type.\n     */\n    readonly type: number;\n\n    /**\n     * The version of the structure.\n     */\n    readonly version: number;\n\n    /**\n     * The transaction signature (missing if part of a multisig transaction).\n     */\n    readonly signature?: string;\n\n    /**\n     * The public key of the account that created the transaction.\n     */\n    signer?: string;\n\n    /**\n     * TimeWindow\n     */\n    readonly timeWindow: TimeWindow;\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly abstract fee: number;\n\n    /**\n     * Transactions meta data object contains additional information about the transaction.\n     */\n    protected readonly transactionInfo?: TransactionInfo;\n\n    /**\n     * Checks if the transaction has been confirmed and included in a block\n     */\n    isConfirmed(): boolean;\n\n    /**\n     * Get transaction info\n     */\n    getTransactionInfo(): TransactionInfo;\n}", 
            "title": "Transaction"
        }, 
        {
            "location": "/documentation/transaction/#transfertransaction", 
            "text": "/**\n * Transfer transactions contain data about transfers of XEM or mosaics to another account.\n */\nexport declare class TransferTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The address of the recipient.\n     */\n    readonly recipient: Address;\n\n    /**\n     * The amount of micro NEM that is transferred from sender to recipient.\n     */\n    readonly amount: number;\n\n    /**\n     * Optionally a transaction can contain a message. In this case the transaction contains a message substructure. If not the field is null.\n     */\n    readonly message: PlainMessage | EncryptedMessage;\n\n    /**\n     * The array of Mosaic objects.\n     */\n    readonly mosaics?: Mosaic[];\n\n    /**\n     * Create a TransferTransaction object\n     * @param timeWindow\n     * @param recipient\n     * @param amount\n     * @param message\n     * @param mosaics\n     * @returns {TransferTransaction}\n     */\n    static create(timeWindow: TimeWindow, recipient: Address, amount: number, message: PlainMessage | EncryptedMessage): TransferTransaction;\n\n    /**\n     * Create a TransferTransaction object\n     * @param timeWindow\n     * @param recipient\n     * @param mosaics\n     * @param message\n     * @returns {TransferTransaction}\n     */\n    static createWithMosaics(timeWindow: TimeWindow, recipient: Address, mosaics: Mosaic[], message: PlainMessage | EncryptedMessage): TransferTransaction;\n}", 
            "title": "TransferTransaction"
        }, 
        {
            "location": "/documentation/transaction/#message", 
            "text": "/**\n * Message model\n */\nexport declare abstract class Message {\n\n    /**\n     * Message payload\n     */\n    readonly payload: string;\n\n}", 
            "title": "Message"
        }, 
        {
            "location": "/documentation/transaction/#plainmessage", 
            "text": "/**\n * Plain Message model\n */\nexport declare class PlainMessage extends Message {\n\n    constructor(payload: string);\n\n    /**\n     * Create new constructor\n     * @returns {boolean}\n     */\n    static create(message: string): PlainMessage;\n\n    /**\n     * Message string\n     * @returns {string}\n     */\n    plain(): string;\n\n}\nexport declare const EmptyMessage: PlainMessage;", 
            "title": "PlainMessage"
        }, 
        {
            "location": "/documentation/transaction/#encryptedmessage", 
            "text": "/**\n * Encrypted Message model\n */\nexport declare class EncryptedMessage extends Message {\n    readonly recipientPublicAccount?: PublicAccount;\n}", 
            "title": "EncryptedMessage"
        }, 
        {
            "location": "/documentation/transaction/#importancetransfertransaction", 
            "text": "export declare enum ImportanceMode {\n    Activate = 1,\n    Deactivate = 2,\n}\n\n/**\n * NIS has the ability to transfer the importance of one account to another account for harvesting.\n * The account receiving the importance is called the remote account.\n * Importance transfer transactions are part of the secure harvesting feature of NEM.\n * Once an importance transaction has been included in a block it needs 6 hours to become active.\n */\nexport declare class ImportanceTransferTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The public key of the receiving account as hexadecimal string.\n     */\n    readonly remoteAccount: PublicAccount;\n\n    /**\n     * The mode, activate or deactivate\n     */\n    readonly mode: ImportanceMode;\n\n    /**\n     * Create a ImportanceTransferTransaction object\n     * @param timeWindow\n     * @param mode\n     * @param remoteAccount\n     * @returns {ImportanceTransferTransaction}\n     */\n    static create(timeWindow: TimeWindow, mode: ImportanceMode, remoteAccount: PublicAccount): ImportanceTransferTransaction;\n}", 
            "title": "ImportanceTransferTransaction"
        }, 
        {
            "location": "/documentation/transaction/#provisionnamespacetransaction", 
            "text": "/**\n * Accounts can rent a namespace for one year and after a year renew the contract. This is done via a ProvisionNamespaceTransaction.\n */\nexport declare class ProvisionNamespaceTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The Address to which the rental fee is transferred.\n     */\n    readonly rentalFeeSink: Address;\n\n    /**\n     * The fee for renting the namespace.\n     */\n    readonly rentalFee: number;\n\n    /**\n     * The parent namespace. This can be undefined if the transaction rents a root namespace.\n     */\n    readonly parent?: string;\n\n    /**\n     * The new part which is concatenated to the parent with a '.' as separator.\n     */\n    readonly newPart: string;\n\n    /**\n     * Create a ProvisionNamespaceTransaction object\n     * @param timeWindow\n     * @param newPart\n     * @param parent\n     * @returns {ProvisionNamespaceTransaction}\n     */\n    static create(timeWindow: TimeWindow, newPart: string, parent?: string): ProvisionNamespaceTransaction;\n}", 
            "title": "ProvisionNamespaceTransaction"
        }, 
        {
            "location": "/documentation/transaction/#mosaicdefinitioncreationtransaction", 
            "text": "/**\n * Before a mosaic can be created or transferred, a corresponding definition of the mosaic has to be created and published to the network.\n * This is done via a mosaic definition creation transaction.\n */\nexport declare class MosaicDefinitionCreationTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The fee for the creation of the mosaic.\n     */\n    readonly creationFee: number;\n\n    /**\n     * The public account to which the creation fee is tranferred.\n     */\n    readonly creationFeeSink: Address;\n\n    /**\n     * The actual mosaic definition.\n     */\n    readonly mosaicDefinition: MosaicDefinition;\n\n    /**\n     * Create a MosaicDefinitionCreationTransaction object\n     * @param timeWindow\n     * @param mosaicDefinition\n     * @returns {MosaicDefinitionCreationTransaction}\n     */\n    static create(timeWindow: TimeWindow, mosaicDefinition: MosaicDefinition): MosaicDefinitionCreationTransaction;\n}", 
            "title": "MosaicDefinitionCreationTransaction"
        }, 
        {
            "location": "/documentation/transaction/#mosaicsupplychangetransaction", 
            "text": "export declare enum MosaicSupplyType {\n    Increase = 1,\n    Decrease = 2,\n}\n\n/**\n * In case a mosaic definition has the property 'supplyMutable' set to true, the creator of the mosaic definition can change the supply, i.e. increase or decrease the supply.\n */\nexport declare class MosaicSupplyChangeTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The mosaic id.\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The supply type.\n     */\n    readonly supplyType: MosaicSupplyType;\n\n    /**\n     * The supply change in units for the mosaic.\n     */\n    readonly delta: number;\n\n    /**\n     * Create a MosaicSupplyChangeTransaction object\n     * @param timeWindow\n     * @param mosaicId\n     * @param supplyType\n     * @param delta\n     * @returns {MosaicSupplyChangeTransaction}\n     */\n    static create(timeWindow: TimeWindow, mosaicId: MosaicId, supplyType: MosaicSupplyType, delta: number): MosaicSupplyChangeTransaction;\n}", 
            "title": "MosaicSupplyChangeTransaction"
        }, 
        {
            "location": "/documentation/transaction/#multisigtransaction", 
            "text": "/**\n * Multisig transaction are the only way to make transaction from a multisig account to another account.\n * A multisig transaction carries another transaction inside (often referred to as  inner  transaction).\n * The inner transaction can be a transfer, an importance transfer or an aggregate modification transaction.\n * A multisig transaction also has multisig signature transactions from the cosignatories of the multisig account inside.\n */\nexport declare class MultisigTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction.\n     */\n    readonly fee: number;\n\n    /**\n     * The JSON array of MulsigSignatureTransaction objects.\n     */\n    readonly signatures: MultisigSignatureTransaction[];\n\n    /**\n     * The inner transaction. The inner transaction can be a transfer transaction, an importance transfer transaction or a multisig aggregate modification transaction.\n     * The inner transaction does not have a valid signature.\n     */\n    readonly otherTransaction: Transaction;\n\n    /**\n     * Hash data\n     */\n    readonly hashData?: HashData;\n\n    /**\n     * Check if transaction is pending to sign\n     * @returns {boolean}\n     */\n    isPendingToSign(): boolean;\n\n    /**\n     * Create a MultisigTransaction object\n     * @param timeWindow\n     * @param otherTrans\n     * @param multisig\n     * @returns {MultisigTransaction}\n     */\n    static create(timeWindow: TimeWindow, otherTrans: Transaction, multisig: PublicAccount): MultisigTransaction;\n}", 
            "title": "MultisigTransaction"
        }, 
        {
            "location": "/documentation/transaction/#multisigaggregatemodificationtransaction", 
            "text": "/**\n * Multisig aggregate modification transactions are part of the NEM's multisig account system.\n * A multisig aggregate modification transaction holds an array of multisig cosignatory modifications and a single multisig minimum cosignatories modification inside the transaction.\n * A multisig aggregate modification transaction can be wrapped by a multisig transaction.\n */\nexport declare class MultisigAggregateModificationTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    fee: number;\n\n    /**\n     * Value indicating the relative change of the minimum cosignatories.\n     */\n    readonly relativeChange?: number;\n\n    /**\n     * The JSON array of multisig modifications.\n     */\n    readonly modifications: CosignatoryModification[];\n\n    /**\n     * Create a MultisigAggregateModificationTransaction object\n     * @param timeWindow\n     * @param modifications\n     * @param relativeChange\n     * @returns {MultisigAggregateModificationTransaction}\n     */\n    static create(timeWindow: TimeWindow, modifications: CosignatoryModification[], relativeChange?: number): MultisigAggregateModificationTransaction;\n}\n\n/**\n * The type of modification. Possible values are:\n * 1: Add a new cosignatory.\n * 2: Delete an existing cosignatory.\n */\nexport declare enum CosignatoryModificationAction {\n    ADD = 1,\n    DELETE = 2,\n}\n\nexport declare class CosignatoryModification {\n    readonly cosignatoryAccount: PublicAccount;\n    readonly action: CosignatoryModificationAction;\n\n    /**\n     * constructor\n     * @param cosignatoryAccount\n     * @param action\n     */\n    constructor(cosignatoryAccount: PublicAccount, action: CosignatoryModificationAction);\n}", 
            "title": "MultisigAggregateModificationTransaction"
        }, 
        {
            "location": "/documentation/transaction/#multisigsignaturetransaction", 
            "text": "/**\n * Multisig signature transactions are part of the NEM's multisig account system. Multisig signature transactions are included in the corresponding multisig transaction and are the way a cosignatory of a multisig account can sign a multisig transaction for that account.\n */\nexport declare class MultisigSignatureTransaction extends Transaction {\n\n    /**\n     * The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.\n     */\n    readonly fee: number;\n\n    /**\n     * The address of the corresponding multisig account.\n     */\n    readonly otherAccount: Address;\n\n    /**\n     * The hash of the inner transaction of the corresponding multisig transaction.\n     */\n    readonly otherHash: HashData;\n\n    /**\n     * Create a MultisigSignatureTransaction object\n     * @param timeWindow\n     * @param otherAccount\n     * @param otherHash\n     * @returns {MultisigSignatureTransaction}\n     */\n    static create(timeWindow: TimeWindow, otherAccount: Address, otherHash: HashData): MultisigSignatureTransaction;\n}", 
            "title": "MultisigSignatureTransaction"
        }, 
        {
            "location": "/documentation/transaction/#signedtransaction", 
            "text": "/**\n * SignedTransaction object is used to transfer the transaction data and the signature to NIS in order to initiate and broadcast a transaction.\n */\nexport interface SignedTransaction {\n\n    /**\n     * The transaction data as string.\n     */\n    readonly data: string;\n\n    /**\n     * The signature for the transaction as hexadecimal string.\n     */\n    readonly signature: string;\n}", 
            "title": "SignedTransaction"
        }, 
        {
            "location": "/documentation/transaction/#nemannounceresult", 
            "text": "export declare enum TypeNemAnnounceResult {\n    Validation = 1,\n    HeartBeat = 2,\n    Status = 4,\n}\n\nexport declare type CodeNemAnnounceResult = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19;\n\n/**\n * The NemAnnounceResult extends the NemRequestResult by supplying the additional fields 'transactionHash' and in case of a multisig transaction 'innerTransactionHash'.\n */\nexport declare class NemAnnounceResult {\n\n    /**\n     * The type is dependent on the request which was answered.\n     */\n    readonly type: TypeNemAnnounceResult;\n\n    /**\n     * The meaning of the code is dependent on the type.\n     */\n    readonly code: CodeNemAnnounceResult;\n\n    /**\n     * Error or success message\n     */\n    readonly message: string;\n\n    /**\n     * The JSON hash object of the transaction.\n     */\n    readonly transactionHash: HashData;\n\n    /**\n     * The JSON hash object of the inner transaction or null if the transaction is not a multisig transaction.\n     */\n    readonly innerTransactionHash: HashData;\n}", 
            "title": "NemAnnounceResult"
        }, 
        {
            "location": "/documentation/namespace/", 
            "text": "Namespace related requests\n\n\nNEM supports the concept of namespaces which is the NEM analog of internet domain names. A namespace is an identification string that consists of one or more parts that are concatenated by dots, for example 'makoto.metals.silver'. All namespaces are unique and thus can only have one owner at a time. A namespace that has only one part is called a root namespace, otherwise sub-namespace. Root namespaces can be rented by accounts for the duration of one year. One month before the root namespace expires the rental contract can be renewed for another year. If a root namespace rental contract is renewed, all sub-namespaces are valid for another year as well. If the root namespace is not renewed, it exires together with all sub-namespaces. One month after a root namespace expires, another account is able to rent that root namespace. The new owner does not inherit the sub-namespaces from the previous owner however. An account can only rent a sub-namespace if it owns the corresponding root namespace.\n\n\nNamespaces have certain restrictions with respected to the characters being allowed in the parts as well as the length of a part. A root namespace may have a length of 16 characters while sub-namespaces may have a length of 64 characters.\n\n\nOfficial Source\n\n\nNamespaceHttp definition\n\n\nexport declare class NamespaceHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets the root namespaces. The requests supports paging, i.e. retrieving the root namespaces in batches of a specified size.\n     * @param id - The topmost namespace database id up to which root namespaces are returned. The parameter is optional. If not supplied the most recent rented root namespaces are returned.\n     * @param pageSize - (Optional) The number of namespace objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100.\n     * @returns Observable\nNamespace[]\n\n     */\n    getRootNamespaces(id: number, pageSize?: string): Observable\nNamespace[]\n;\n\n    /**\n     * Gets the namespace with given id.\n     * @param namespace - The namespace id.\n     * @returns Observable\nNamespace\n\n     */\n    getNamespace(namespace: string): Observable\nNamespace\n;\n}\n\n\n\n\n\nNamespaceHttp usage\n\n\nimport {NamespaceHttp, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp({domain: \n104.128.226.60\n});\nconst id = 12344;\n\nnamespaceHttp.getRootNamespaces(id).subscribe(namespaces =\n {\n    console.log(namespaces);\n});\n\n\n\n\nOutput\n\n\n[ Namespace {\n    name: 'ajkshgkerhkjerg',\n    owner:\n     Address {\n       value: 'TDQJM2LZPKM4WRI44CF5TEUHRES5JCWQ3YRKGKUB',\n       networkType: 152 },\n    height: 1034366,\n    id: 409 },\n  Namespace {\n    name: 'hitori',\n    owner:\n     Address {\n       value: 'TCIY4MHDHZJ42NGHQ67PJXSWHLFACNMJLSM56VE3',\n       networkType: 152 },\n    height: 1033761,\n    id: 408 },\n  Namespace {\n    name: 'vandelay',\n    owner:\n     Address {\n       value: 'TAB5AEUDM3ALLDRLRLNMQYQXJXJZUSMDSEN5TND5',\n       networkType: 152 },\n    height: 1032986,\n    id: 405 },\n  Namespace {\n    name: 'girish',\n    owner:\n     Address {\n       value: 'TAFHY34ZKCJIYI6LPEJXVOCMVK5QHQXJ5AAPO5RG',\n       networkType: 152 },\n    height: 1031091,\n    id: 403 },\n  Namespace {\n    name: 'multisigns',\n    owner:\n     Address {\n       value: 'TDAEIWWYWZRE3VSUHXG77L5TW22BHNGV5FAPH2XJ',\n       networkType: 152 },\n    height: 1029552,\n    id: 402 },\n  Namespace {\n    name: 'foobarltd',\n    owner:\n     Address {\n       value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH',\n       networkType: 152 },\n    height: 1029471,\n    id: 401 },\n  Namespace {\n    name: 'jabo',\n    owner:\n     Address {\n       value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH',\n       networkType: 152 },\n    height: 1029471,\n    id: 400 },\n  Namespace {\n    name: 'newpart',\n    owner:\n     Address {\n       value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA',\n       networkType: 152 },\n    height: 1028225,\n    id: 399 },\n  Namespace {\n    name: 'govegan',\n    owner:\n     Address {\n       value: 'TBXWZW35ZJDHLXYDQ6EQTWKHJSWQG2EQYWDRKXXU',\n       networkType: 152 },\n    height: 1027004,\n    id: 398 },\n  Namespace {\n    name: 'tescik11',\n    owner:\n     Address {\n       value: 'TCWHXK5EI3RJIUV5DXURIIEASECB57L4N5EEGI24',\n       networkType: 152 },\n    height: 1026918,\n    id: 397 },\n  Namespace {\n    name: 'fintech',\n    owner:\n     Address {\n       value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT',\n       networkType: 152 },\n    height: 1026764,\n    id: 396 },\n  Namespace {\n    name: 'kung',\n    owner:\n     Address {\n       value: 'TAU5HO3DRQZNELFEMZZTUKQEZGQ7IUAHKPO7OOLK',\n       networkType: 152 },\n    height: 1025402,\n    id: 395 },\n  Namespace {\n    name: 'dim',\n    owner:\n     Address {\n       value: 'TDXTBQUI5PCPHBZKTHBSLMCJGKDWV3RVHHOCPX2V',\n       networkType: 152 },\n    height: 1022794,\n    id: 393 },\n  Namespace {\n    name: 'multisig',\n    owner:\n     Address {\n       value: 'TAVBSWJV3XNA7MRVEH3XQQYRTJGXM3VRKCQDKHR7',\n       networkType: 152 },\n    height: 1021094,\n    id: 392 },\n  Namespace {\n    name: 'jeffmcdonald',\n    owner:\n     Address {\n       value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344',\n       networkType: 152 },\n    height: 1019783,\n    id: 391 },\n  Namespace {\n    name: 'lonwon',\n    owner:\n     Address {\n       value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344',\n       networkType: 152 },\n    height: 1019768,\n    id: 390 },\n  Namespace {\n    name: 'bok_tor',\n    owner:\n     Address {\n       value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT',\n       networkType: 152 },\n    height: 1018248,\n    id: 389 },\n  Namespace {\n    name: 'macy',\n    owner:\n     Address {\n       value: 'TCF2JGBTB7LM6Y3VP22DSSFRUGDYZYVQMUGDX4TL',\n       networkType: 152 },\n    height: 1018245,\n    id: 388 },\n  Namespace {\n    name: 'foo',\n    owner:\n     Address {\n       value: 'TAOMBDIWECBSP7QGEKGUE476QOCRRN6MEOSQQ4RP',\n       networkType: 152 },\n    height: 1017249,\n    id: 387 },\n  Namespace {\n    name: 'namespace_root1',\n    owner:\n     Address {\n       value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK',\n       networkType: 152 },\n    height: 1017028,\n    id: 385 },\n  Namespace {\n    name: 'root_namespace1',\n    owner:\n     Address {\n       value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK',\n       networkType: 152 },\n    height: 1017028,\n    id: 384 },\n  Namespace {\n    name: 'rivalkingdoms',\n    owner:\n     Address {\n       value: 'TCBAR5KG4HHTF3EBBCQETVYUJVONF7XKWSYCI2CA',\n       networkType: 152 },\n    height: 1016967,\n    id: 382 },\n  Namespace {\n    name: 'szpregel',\n    owner:\n     Address {\n       value: 'TDFPX267BPLVUB2VF3OY2LSACGSF4XWLVPUXY3FC',\n       networkType: 152 },\n    height: 1016780,\n    id: 381 },\n  Namespace {\n    name: 'marvel',\n    owner:\n     Address {\n       value: 'TDSPQOUYI6VBGD2SAERJ73ZYMNY5ACJSYNTZSUHP',\n       networkType: 152 },\n    height: 1016477,\n    id: 379 },\n  Namespace {\n    name: 'test',\n    owner:\n     Address {\n       value: 'TADEADUYY4FE5JSHL22VNASNYXYXEJVZ7BF2E3IO',\n       networkType: 152 },\n    height: 1015685,\n    id: 378 } ]\n\n\n\n\nRun the code\n\n\nModels\n\n\nNamespace\n\n\n/**\n * A namespace is the NEM version of a domain. You can rent a namespace for the duration of a year by paying a fee.\n * The naming of the parts of a namespace has certain restrictions, see the corresponding chapter on namespaces.\n */\nexport declare class Namespace {\n    /**\n     * The fully qualified name of the namespace, also named namespace id.\n     */\n    readonly name: string;\n\n    /**\n     * The owner of the namespace.\n     */\n    readonly owner: Address;\n\n    /**\n     * The height at which the ownership begins.\n     */\n    readonly height: number;\n\n    /**\n     * The database id for the namespace object.\n     */\n    readonly id?: number;\n\n}", 
            "title": "Namespace"
        }, 
        {
            "location": "/documentation/namespace/#namespace-related-requests", 
            "text": "NEM supports the concept of namespaces which is the NEM analog of internet domain names. A namespace is an identification string that consists of one or more parts that are concatenated by dots, for example 'makoto.metals.silver'. All namespaces are unique and thus can only have one owner at a time. A namespace that has only one part is called a root namespace, otherwise sub-namespace. Root namespaces can be rented by accounts for the duration of one year. One month before the root namespace expires the rental contract can be renewed for another year. If a root namespace rental contract is renewed, all sub-namespaces are valid for another year as well. If the root namespace is not renewed, it exires together with all sub-namespaces. One month after a root namespace expires, another account is able to rent that root namespace. The new owner does not inherit the sub-namespaces from the previous owner however. An account can only rent a sub-namespace if it owns the corresponding root namespace.  Namespaces have certain restrictions with respected to the characters being allowed in the parts as well as the length of a part. A root namespace may have a length of 16 characters while sub-namespaces may have a length of 64 characters.  Official Source", 
            "title": "Namespace related requests"
        }, 
        {
            "location": "/documentation/namespace/#namespacehttp-definition", 
            "text": "export declare class NamespaceHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets the root namespaces. The requests supports paging, i.e. retrieving the root namespaces in batches of a specified size.\n     * @param id - The topmost namespace database id up to which root namespaces are returned. The parameter is optional. If not supplied the most recent rented root namespaces are returned.\n     * @param pageSize - (Optional) The number of namespace objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100.\n     * @returns Observable Namespace[] \n     */\n    getRootNamespaces(id: number, pageSize?: string): Observable Namespace[] ;\n\n    /**\n     * Gets the namespace with given id.\n     * @param namespace - The namespace id.\n     * @returns Observable Namespace \n     */\n    getNamespace(namespace: string): Observable Namespace ;\n}", 
            "title": "NamespaceHttp definition"
        }, 
        {
            "location": "/documentation/namespace/#namespacehttp-usage", 
            "text": "import {NamespaceHttp, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp({domain:  104.128.226.60 });\nconst id = 12344;\n\nnamespaceHttp.getRootNamespaces(id).subscribe(namespaces =  {\n    console.log(namespaces);\n});  Output  [ Namespace {\n    name: 'ajkshgkerhkjerg',\n    owner:\n     Address {\n       value: 'TDQJM2LZPKM4WRI44CF5TEUHRES5JCWQ3YRKGKUB',\n       networkType: 152 },\n    height: 1034366,\n    id: 409 },\n  Namespace {\n    name: 'hitori',\n    owner:\n     Address {\n       value: 'TCIY4MHDHZJ42NGHQ67PJXSWHLFACNMJLSM56VE3',\n       networkType: 152 },\n    height: 1033761,\n    id: 408 },\n  Namespace {\n    name: 'vandelay',\n    owner:\n     Address {\n       value: 'TAB5AEUDM3ALLDRLRLNMQYQXJXJZUSMDSEN5TND5',\n       networkType: 152 },\n    height: 1032986,\n    id: 405 },\n  Namespace {\n    name: 'girish',\n    owner:\n     Address {\n       value: 'TAFHY34ZKCJIYI6LPEJXVOCMVK5QHQXJ5AAPO5RG',\n       networkType: 152 },\n    height: 1031091,\n    id: 403 },\n  Namespace {\n    name: 'multisigns',\n    owner:\n     Address {\n       value: 'TDAEIWWYWZRE3VSUHXG77L5TW22BHNGV5FAPH2XJ',\n       networkType: 152 },\n    height: 1029552,\n    id: 402 },\n  Namespace {\n    name: 'foobarltd',\n    owner:\n     Address {\n       value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH',\n       networkType: 152 },\n    height: 1029471,\n    id: 401 },\n  Namespace {\n    name: 'jabo',\n    owner:\n     Address {\n       value: 'TANXPOUPPCJHL3PLUHY5M6AE6B47H3YZ5ZCDFMXH',\n       networkType: 152 },\n    height: 1029471,\n    id: 400 },\n  Namespace {\n    name: 'newpart',\n    owner:\n     Address {\n       value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA',\n       networkType: 152 },\n    height: 1028225,\n    id: 399 },\n  Namespace {\n    name: 'govegan',\n    owner:\n     Address {\n       value: 'TBXWZW35ZJDHLXYDQ6EQTWKHJSWQG2EQYWDRKXXU',\n       networkType: 152 },\n    height: 1027004,\n    id: 398 },\n  Namespace {\n    name: 'tescik11',\n    owner:\n     Address {\n       value: 'TCWHXK5EI3RJIUV5DXURIIEASECB57L4N5EEGI24',\n       networkType: 152 },\n    height: 1026918,\n    id: 397 },\n  Namespace {\n    name: 'fintech',\n    owner:\n     Address {\n       value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT',\n       networkType: 152 },\n    height: 1026764,\n    id: 396 },\n  Namespace {\n    name: 'kung',\n    owner:\n     Address {\n       value: 'TAU5HO3DRQZNELFEMZZTUKQEZGQ7IUAHKPO7OOLK',\n       networkType: 152 },\n    height: 1025402,\n    id: 395 },\n  Namespace {\n    name: 'dim',\n    owner:\n     Address {\n       value: 'TDXTBQUI5PCPHBZKTHBSLMCJGKDWV3RVHHOCPX2V',\n       networkType: 152 },\n    height: 1022794,\n    id: 393 },\n  Namespace {\n    name: 'multisig',\n    owner:\n     Address {\n       value: 'TAVBSWJV3XNA7MRVEH3XQQYRTJGXM3VRKCQDKHR7',\n       networkType: 152 },\n    height: 1021094,\n    id: 392 },\n  Namespace {\n    name: 'jeffmcdonald',\n    owner:\n     Address {\n       value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344',\n       networkType: 152 },\n    height: 1019783,\n    id: 391 },\n  Namespace {\n    name: 'lonwon',\n    owner:\n     Address {\n       value: 'TBNDYR4AVGYFEEUQ5LBPNEON42HSQ37NYGLZC344',\n       networkType: 152 },\n    height: 1019768,\n    id: 390 },\n  Namespace {\n    name: 'bok_tor',\n    owner:\n     Address {\n       value: 'TBN24GPJMXTMI3VRFRDKWL6A2FIM2YGHMHD4OPUT',\n       networkType: 152 },\n    height: 1018248,\n    id: 389 },\n  Namespace {\n    name: 'macy',\n    owner:\n     Address {\n       value: 'TCF2JGBTB7LM6Y3VP22DSSFRUGDYZYVQMUGDX4TL',\n       networkType: 152 },\n    height: 1018245,\n    id: 388 },\n  Namespace {\n    name: 'foo',\n    owner:\n     Address {\n       value: 'TAOMBDIWECBSP7QGEKGUE476QOCRRN6MEOSQQ4RP',\n       networkType: 152 },\n    height: 1017249,\n    id: 387 },\n  Namespace {\n    name: 'namespace_root1',\n    owner:\n     Address {\n       value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK',\n       networkType: 152 },\n    height: 1017028,\n    id: 385 },\n  Namespace {\n    name: 'root_namespace1',\n    owner:\n     Address {\n       value: 'TDUI4FXZDEMSFMGM7BOQOLENGX7P7Q6I7ISIH7NK',\n       networkType: 152 },\n    height: 1017028,\n    id: 384 },\n  Namespace {\n    name: 'rivalkingdoms',\n    owner:\n     Address {\n       value: 'TCBAR5KG4HHTF3EBBCQETVYUJVONF7XKWSYCI2CA',\n       networkType: 152 },\n    height: 1016967,\n    id: 382 },\n  Namespace {\n    name: 'szpregel',\n    owner:\n     Address {\n       value: 'TDFPX267BPLVUB2VF3OY2LSACGSF4XWLVPUXY3FC',\n       networkType: 152 },\n    height: 1016780,\n    id: 381 },\n  Namespace {\n    name: 'marvel',\n    owner:\n     Address {\n       value: 'TDSPQOUYI6VBGD2SAERJ73ZYMNY5ACJSYNTZSUHP',\n       networkType: 152 },\n    height: 1016477,\n    id: 379 },\n  Namespace {\n    name: 'test',\n    owner:\n     Address {\n       value: 'TADEADUYY4FE5JSHL22VNASNYXYXEJVZ7BF2E3IO',\n       networkType: 152 },\n    height: 1015685,\n    id: 378 } ]  Run the code", 
            "title": "NamespaceHttp usage"
        }, 
        {
            "location": "/documentation/namespace/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/documentation/namespace/#namespace", 
            "text": "/**\n * A namespace is the NEM version of a domain. You can rent a namespace for the duration of a year by paying a fee.\n * The naming of the parts of a namespace has certain restrictions, see the corresponding chapter on namespaces.\n */\nexport declare class Namespace {\n    /**\n     * The fully qualified name of the namespace, also named namespace id.\n     */\n    readonly name: string;\n\n    /**\n     * The owner of the namespace.\n     */\n    readonly owner: Address;\n\n    /**\n     * The height at which the ownership begins.\n     */\n    readonly height: number;\n\n    /**\n     * The database id for the namespace object.\n     */\n    readonly id?: number;\n\n}", 
            "title": "Namespace"
        }, 
        {
            "location": "/documentation/mosaic/", 
            "text": "Mosaic related requests\n\n\nNEM mosaics are assets that expose additional properties and other features. Each mosaic has an underlying mosaic definition. To be able to create a mosaic definition, an account must rent at least one root namespace which the mosaic definition can then refer to.\n\n\nOfficial Source\n\n\nMosaicHttp definition\n\n\nexport declare class MosaicHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets the mosaic definitions for a given namespace. The request supports paging.\n     * @param namespace\n     * @param id - The topmost mosaic definition database id up to which root mosaic definitions are returned. The parameter is optional. If not supplied the most recent mosaic definitiona are returned.\n     * @param pageSize - The number of mosaic definition objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100.\n     * @returns Observable\nMosaicDefinition[]\n\n     */\n    getMosaicDefinitions(namespace: string, id?: number, pageSize?: string): Observable\nMosaicDefinition[]\n;\n}\n\n\n\n\n\nMosaicHttp usage\n\n\nimport {MosaicHttp, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst mosaicHttp = new MosaicHttp({domain: \n104.128.226.60\n});\nconst namespace = \nserver\n;\n\nmosaicHttp.getMosaicDefinitions(namespace).subscribe(mosaicDefinitions =\n {\n    console.log(mosaicDefinitions);\n});\n\n\n\n\nOutput\n\n\n[ MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'testmosaic' },\n    description: 'descritpio',\n    properties:\n     MosaicProperties {\n       initialSupply: 1000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: undefined,\n    metaId: 447 },\n  MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'alcapone' },\n    description: 'the one and only al capone',\n    properties:\n     MosaicProperties {\n       initialSupply: 10000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 385 },\n  MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' },\n    description: 'description',\n    properties:\n     MosaicProperties {\n       initialSupply: 100000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 384 } ]\n\n\n\n\nRun the code\n\n\nModels\n\n\nMosaicId\n\n\n/**\n * A mosaic id uniquely identifies an underlying mosaic definition.\n */\nexport declare class MosaicId {\n\n    /**\n     * The corresponding namespace id\n     */\n    readonly namespaceId: string;\n\n    /**\n     * The name of the mosaic definition.\n     */\n    readonly name: string;\n\n    /**\n     * constructor\n     * @param namespaceId\n     * @param name\n     */\n    constructor(namespaceId: string, name: string);\n}\n\n\n\n\n\nMosaic\n\n\n/**\n * A mosaic describes an instance of a mosaic definition. Mosaics can be transferred by means of a transfer transaction.\n */\nexport declare class Mosaic {\n\n    /**\n     * The mosaic id\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The mosaic quantity. The quantity is always given in smallest units for the mosaic, i.e. if it has a divisibility of 3 the quantity is given in millis.\n     */\n    readonly quantity: number;\n\n    /**\n     * constructor\n     * @param mosaicId\n     * @param quantity\n     */\n    constructor(mosaicId: MosaicId, quantity: number);\n}\n\n\n\n\n\nMosaicDefinition\n\n\n\n/**\n * A mosaic definition describes an asset class. Some fields are mandatory while others are optional.\n * The properties of a mosaic definition always have a default value and only need to be supplied if they differ from the default value.\n */\nexport declare class MosaicDefinition {\n\n    /**\n     *  The public key of the mosaic definition creator.\n     */\n    readonly creator: PublicAccount;\n\n    /**\n     * The mosaic id\n     */\n    readonly id: MosaicId;\n\n    /**\n     * The mosaic description. The description may have a length of up to 512 characters and cannot be empty.\n     */\n    readonly description: string;\n\n    /**\n    * Mosaic properties \n    */\n    readonly properties: MosaicProperties;\n\n    /**\n     * The optional levy for the mosaic. A creator can demand that each mosaic transfer induces an additional fee\n     */\n    readonly levy?: MosaicLevy;\n\n    /**\n     * The id for the mosaic definition object.\n     */\n    readonly metaId?: number;\n\n    /**\n     * constructor\n     * @param creator\n     * @param id\n     * @param description\n     * @param properties\n     * @param levy\n     * @param metaId\n     */\n    constructor(creator: PublicAccount, id: MosaicId, description: string, properties: MosaicProperties, levy?: MosaicLevy, metaId?: number);\n}\n\n/**\n * Each mosaic definition comes with a set of properties.\n * Each property has a default value which will be applied in case it was not specified.\n * Future release may add additional properties to the set of available properties\n */\nexport declare class MosaicProperties {\n\n    /**\n     * initialSupply: The creator can specify an initial supply of mosaics when creating the definition.\n     * The supply is given in entire units of the mosaic, not in smallest sub-units.\n     * The initial supply must be in the range of 0 and 9,000,000,000. The default value is \n1000\n.\n     */\n    readonly initialSupply: number;\n\n    /**\n     * The creator can choose between a definition that allows a mosaic supply change at a later point or an immutable supply.\n     * Allowed values for the property are \ntrue\n and \nfalse\n. The default value is \nfalse\n.\n     */\n    readonly supplyMutable: boolean;\n\n    /**\n     * The creator can choose if the mosaic definition should allow for transfers of the mosaic among accounts other than the creator.\n     * If the property 'transferable' is set to \nfalse\n, only transfer transactions having the creator as sender or as recipient can transfer mosaics of that type.\n     * If set to \ntrue\n the mosaics can be transferred to and from arbitrary accounts.\n     * Allowed values for the property are thus \ntrue\n and \nfalse\n. The default value is \ntrue\n.\n     */\n    readonly transferable: boolean;\n\n    /**\n     * The divisibility determines up to what decimal place the mosaic can be divided into.\n     * Thus a divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics, i.e. milli mosaics is the smallest sub-unit.\n     * When transferring mosaics via a transfer transaction the quantity transferred is given in multiples of those smallest parts.\n     * The divisibility must be in the range of 0 and 6. The default value is \n0\n.\n     */\n    readonly divisibility: number;\n\n    /**\n     * constructor\n     * @param divisibility\n     * @param initialSupply\n     * @param supplyMutable\n     * @param transferable\n     */\n    constructor(divisibility?: number, initialSupply?: number, transferable?: boolean, supplyMutable?: boolean);\n}\n\n\n\n\nMosaicLevy\n\n\n\nexport declare enum MosaicLevyType {\n    Absolute = 1,\n    Percentil = 2,\n}\n\n/**\n * A mosaic definition can optionally specify a levy for transferring those mosaics. This might be needed by legal entities needing to collect some taxes for transfers.\n */\nexport declare class MosaicLevy {\n\n    /**\n     *  The levy type\n     */\n    readonly type: MosaicLevyType;\n\n    /**\n     * The recipient of the levy.\n     */\n    readonly recipient: Address;\n\n    /**\n     * The mosaic in which the levy is paid.\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The fee. The interpretation is dependent on the type of the levy\n     */\n    readonly fee: number;\n\n    /**\n     * constructor\n     * @param type\n     * @param recipient\n     * @param mosaicId\n     * @param fee\n     */\n    constructor(type: MosaicLevyType, recipient: Address, mosaicId: MosaicId, fee: number);\n}", 
            "title": "Mosaic"
        }, 
        {
            "location": "/documentation/mosaic/#mosaic-related-requests", 
            "text": "NEM mosaics are assets that expose additional properties and other features. Each mosaic has an underlying mosaic definition. To be able to create a mosaic definition, an account must rent at least one root namespace which the mosaic definition can then refer to.  Official Source", 
            "title": "Mosaic related requests"
        }, 
        {
            "location": "/documentation/mosaic/#mosaichttp-definition", 
            "text": "export declare class MosaicHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets the mosaic definitions for a given namespace. The request supports paging.\n     * @param namespace\n     * @param id - The topmost mosaic definition database id up to which root mosaic definitions are returned. The parameter is optional. If not supplied the most recent mosaic definitiona are returned.\n     * @param pageSize - The number of mosaic definition objects to be returned for each request. The parameter is optional. The default value is 25, the minimum value is 5 and hte maximum value is 100.\n     * @returns Observable MosaicDefinition[] \n     */\n    getMosaicDefinitions(namespace: string, id?: number, pageSize?: string): Observable MosaicDefinition[] ;\n}", 
            "title": "MosaicHttp definition"
        }, 
        {
            "location": "/documentation/mosaic/#mosaichttp-usage", 
            "text": "import {MosaicHttp, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst mosaicHttp = new MosaicHttp({domain:  104.128.226.60 });\nconst namespace =  server ;\n\nmosaicHttp.getMosaicDefinitions(namespace).subscribe(mosaicDefinitions =  {\n    console.log(mosaicDefinitions);\n});  Output  [ MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'testmosaic' },\n    description: 'descritpio',\n    properties:\n     MosaicProperties {\n       initialSupply: 1000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: undefined,\n    metaId: 447 },\n  MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'alcapone' },\n    description: 'the one and only al capone',\n    properties:\n     MosaicProperties {\n       initialSupply: 10000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 385 },\n  MosaicDefinition {\n    creator:\n     PublicAccount {\n       address: [Object],\n       publicKey: '0e4573c386c5f891d2e61bfb5a96144fbd9881980b885751dba471ae1807dc34' },\n    id: MosaicId { namespaceId: 'server', name: 'masteroftheworld' },\n    description: 'description',\n    properties:\n     MosaicProperties {\n       initialSupply: 100000000,\n       supplyMutable: true,\n       transferable: true,\n       divisibility: 0 },\n    levy: MosaicLevy { type: 1, recipient: [Object], mosaicId: [Object], fee: 5 },\n    metaId: 384 } ]  Run the code", 
            "title": "MosaicHttp usage"
        }, 
        {
            "location": "/documentation/mosaic/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/documentation/mosaic/#mosaicid", 
            "text": "/**\n * A mosaic id uniquely identifies an underlying mosaic definition.\n */\nexport declare class MosaicId {\n\n    /**\n     * The corresponding namespace id\n     */\n    readonly namespaceId: string;\n\n    /**\n     * The name of the mosaic definition.\n     */\n    readonly name: string;\n\n    /**\n     * constructor\n     * @param namespaceId\n     * @param name\n     */\n    constructor(namespaceId: string, name: string);\n}", 
            "title": "MosaicId"
        }, 
        {
            "location": "/documentation/mosaic/#mosaic", 
            "text": "/**\n * A mosaic describes an instance of a mosaic definition. Mosaics can be transferred by means of a transfer transaction.\n */\nexport declare class Mosaic {\n\n    /**\n     * The mosaic id\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The mosaic quantity. The quantity is always given in smallest units for the mosaic, i.e. if it has a divisibility of 3 the quantity is given in millis.\n     */\n    readonly quantity: number;\n\n    /**\n     * constructor\n     * @param mosaicId\n     * @param quantity\n     */\n    constructor(mosaicId: MosaicId, quantity: number);\n}", 
            "title": "Mosaic"
        }, 
        {
            "location": "/documentation/mosaic/#mosaicdefinition", 
            "text": "/**\n * A mosaic definition describes an asset class. Some fields are mandatory while others are optional.\n * The properties of a mosaic definition always have a default value and only need to be supplied if they differ from the default value.\n */\nexport declare class MosaicDefinition {\n\n    /**\n     *  The public key of the mosaic definition creator.\n     */\n    readonly creator: PublicAccount;\n\n    /**\n     * The mosaic id\n     */\n    readonly id: MosaicId;\n\n    /**\n     * The mosaic description. The description may have a length of up to 512 characters and cannot be empty.\n     */\n    readonly description: string;\n\n    /**\n    * Mosaic properties \n    */\n    readonly properties: MosaicProperties;\n\n    /**\n     * The optional levy for the mosaic. A creator can demand that each mosaic transfer induces an additional fee\n     */\n    readonly levy?: MosaicLevy;\n\n    /**\n     * The id for the mosaic definition object.\n     */\n    readonly metaId?: number;\n\n    /**\n     * constructor\n     * @param creator\n     * @param id\n     * @param description\n     * @param properties\n     * @param levy\n     * @param metaId\n     */\n    constructor(creator: PublicAccount, id: MosaicId, description: string, properties: MosaicProperties, levy?: MosaicLevy, metaId?: number);\n}\n\n/**\n * Each mosaic definition comes with a set of properties.\n * Each property has a default value which will be applied in case it was not specified.\n * Future release may add additional properties to the set of available properties\n */\nexport declare class MosaicProperties {\n\n    /**\n     * initialSupply: The creator can specify an initial supply of mosaics when creating the definition.\n     * The supply is given in entire units of the mosaic, not in smallest sub-units.\n     * The initial supply must be in the range of 0 and 9,000,000,000. The default value is  1000 .\n     */\n    readonly initialSupply: number;\n\n    /**\n     * The creator can choose between a definition that allows a mosaic supply change at a later point or an immutable supply.\n     * Allowed values for the property are  true  and  false . The default value is  false .\n     */\n    readonly supplyMutable: boolean;\n\n    /**\n     * The creator can choose if the mosaic definition should allow for transfers of the mosaic among accounts other than the creator.\n     * If the property 'transferable' is set to  false , only transfer transactions having the creator as sender or as recipient can transfer mosaics of that type.\n     * If set to  true  the mosaics can be transferred to and from arbitrary accounts.\n     * Allowed values for the property are thus  true  and  false . The default value is  true .\n     */\n    readonly transferable: boolean;\n\n    /**\n     * The divisibility determines up to what decimal place the mosaic can be divided into.\n     * Thus a divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics, i.e. milli mosaics is the smallest sub-unit.\n     * When transferring mosaics via a transfer transaction the quantity transferred is given in multiples of those smallest parts.\n     * The divisibility must be in the range of 0 and 6. The default value is  0 .\n     */\n    readonly divisibility: number;\n\n    /**\n     * constructor\n     * @param divisibility\n     * @param initialSupply\n     * @param supplyMutable\n     * @param transferable\n     */\n    constructor(divisibility?: number, initialSupply?: number, transferable?: boolean, supplyMutable?: boolean);\n}", 
            "title": "MosaicDefinition"
        }, 
        {
            "location": "/documentation/mosaic/#mosaiclevy", 
            "text": "export declare enum MosaicLevyType {\n    Absolute = 1,\n    Percentil = 2,\n}\n\n/**\n * A mosaic definition can optionally specify a levy for transferring those mosaics. This might be needed by legal entities needing to collect some taxes for transfers.\n */\nexport declare class MosaicLevy {\n\n    /**\n     *  The levy type\n     */\n    readonly type: MosaicLevyType;\n\n    /**\n     * The recipient of the levy.\n     */\n    readonly recipient: Address;\n\n    /**\n     * The mosaic in which the levy is paid.\n     */\n    readonly mosaicId: MosaicId;\n\n    /**\n     * The fee. The interpretation is dependent on the type of the levy\n     */\n    readonly fee: number;\n\n    /**\n     * constructor\n     * @param type\n     * @param recipient\n     * @param mosaicId\n     * @param fee\n     */\n    constructor(type: MosaicLevyType, recipient: Address, mosaicId: MosaicId, fee: number);\n}", 
            "title": "MosaicLevy"
        }, 
        {
            "location": "/documentation/node/", 
            "text": "Node related requests\n\n\nNodes are the entities that exchange data in a network. A node is essentially a NIS instance running on a computer. To be able to communicate with the network, a node needs to be booted. Through node requests it is possible to discover other nodes in the network, learn about other nodes experiences and get information about their current chain height.\n\n\nOfficial Source\n\n\nNodeHttp definition\n\n\nexport declare class NodeHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets basic information about a node\n     * @returns Observable\nNode\n\n     */\n    getNodeInfo(): Observable\nNode\n;\n\n    /**\n     * Gets extended information about a node\n     * @returns Observable\nNisNodeInfo\n\n     */\n    getNisNodeInfo(): Observable\nNisNodeInfo\n;\n\n    /**\n     * Gets an array of all known nodes in the neighborhood.\n     * @returns Observable\nNodeCollection\n\n     */\n    getAllNodes(): Observable\nNodeCollection\n;\n\n    /**\n     * Gets an array of all nodes with status 'active' in the neighborhood.\n     * @returns Observable\nNode[]\n\n     */\n    getActiveNodes(): Observable\nNode[]\n;\n\n    /**\n     * Gets an array of active nodes in the neighborhood that are selected for broadcasts.\n     * @returns Observable\nNode[]\n\n     */\n    getActiveNeighbourNodes(): Observable\nNode[]\n;\n\n    /**\n     * Requests the chain height from every node in the active node list and returns the maximum height seen.\n     * @returns Observable\nBlockHeight\n\n     */\n    getMaximumChainHeightInActiveNeighborhood(): Observable\nBlockHeight\n;\n\n    /**\n     * Requests the chain height from every node in the active node list and returns the maximum height seen.\n     * @returns Observable\nExtendedNodeExperience[]\n\n     */\n    getNodeExperiences(): Observable\nExtendedNodeExperience[]\n;\n}\n\n\n\n\nNodeHttp usage\n\n\nimport {NodeHttp, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp({domain: \n104.128.226.60\n});\nnodeHttp.getNodeInfo().subscribe(node =\n {\n    console.log(node);\n});\n\n\n\n\nOutput:\n\n\nNode {\n  metaData: \n   NodeMetaData {\n     features: 3,\n     network: -104,\n     application: null,\n     version: '0.6.92-BETA',\n     platform: 'Oracle Corporation (1.8.0_40) on Linux' },\n  endpoint: NodeEndpoint { protocol: 'http', port: 7890, host: '104.128.226.60' },\n  identity: NodeIdentity { name: 'Hi, I am BigAlice2', publickey: undefined } }\n\n\n\n\nRun the code\n\n\nModels\n\n\nNode\n\n\n/**\n * Nodes are the entities that perform communication in the network like sending and receiving data.\n * A node has an identity which is tied to an account through which the node can identify itself to the network.\n * The communication is done through the endpoint of the node. Additionally a node provides meta data information.\n */\nexport declare class Node {\n\n    /**\n     * Denotes the beginning of the meta data substructure.\n     */\n    readonly metaData: NodeMetaData;\n\n    /**\n     * Denotes the beginning of the endpoint substructure.\n     */\n    readonly endpoint: NodeEndpoint;\n\n    /**\n     * Denotes the beginning of the identity substructure.\n     */\n    readonly identity: NodeIdentity;\n\n}\n\n/**\n * Node meta data\n */\nexport declare class NodeMetaData {\n\n    /**\n     * The number of features the nodes has.\n     */\n    readonly features: number;\n\n    /**\n     * The network id\n     */\n    readonly network: NetworkTypes;\n\n    /**\n     * The name of the application that is running the node.\n     */\n    readonly application: string;\n\n    /**\n     * The version of the application.\n     */\n    readonly version: string;\n\n    /**\n     * The underlying platform (OS, java version).\n     */\n    readonly platform: string;\n}\n\n/**\n * Node endpoint\n */\nexport declare class NodeEndpoint {\n\n    /**\n     * The protocol used for the communication (HTTP or HTTPS).\n     */\n    readonly protocol: string;\n\n    /**\n     * The port used for the communication.\n     */\n    readonly port: number;\n\n    /**\n     * The IP address of the endpoint.\n     */\n    readonly host: string;\n}\n\n/**\n * Node identity\n */\nexport declare class NodeIdentity {\n\n    /**\n     * The name of the node.\n     */\n    readonly name: string;\n\n    /**\n     * The public key used to identify the node.\n     */\n    readonly publickey: string;\n}\n\n\n\n\n\nNisNodeInfo\n\n\n/**\n * A NodeCollection object holds arrays of nodes with different statuses.\n */\nexport declare class NisNodeInfo {\n\n    /**\n     * Denotes the beginning of the node substructure.\n     */\n    readonly node: Node;\n\n    /**\n     * Denotes the beginning of the application meta data substructure.\n     */\n    readonly nisInfo: ApplicationMetaData;\n}\n\n/**\n * The application meta data object supplies additional information about the application running on a node.\n */\nexport declare class ApplicationMetaData {\n\n    /**\n     * The current network time, i.e. the number of seconds that have elapsed since the creation of the nemesis block.\n     */\n    readonly currentTime: number;\n\n    /**\n     * The name of the application running on the node.\n     */\n    readonly application: string;\n\n    /**\n     * The network time when the application was started.\n     */\n    readonly startTime: number;\n\n    /**\n     * The application version.\n     */\n    readonly version: string;\n\n    /**\n     * The signer of the certificate used by the application.\n     */\n    readonly signer: string;\n}\n\n\n\n\nNodeCollection\n\n\n/**\n * A NodeCollection object holds arrays of nodes with different statuses.\n */\nexport declare class NodeCollection {\n\n    /**\n     * A connection to the node cannot be established.\n     */\n    readonly inactive: Node[];\n\n    /**\n     * A connection can be established and the remote node responds in a timely manner.\n     */\n    readonly active: Node[];\n\n    /**\n     * A connection can be established but the node cannot provide information within the timeout limits.\n     */\n    readonly busy: Node[];\n\n    /**\n     * A fatal error occurs when trying to establish a connection or the node couldn't authenticate itself correctly.\n     */\n    readonly failure: Node[];\n}\n\n\n\n\nExtendedNodeExperience\n\n\n/**\n * When exchanging data with other nodes the result of the communication is divided into three\n * different outcomes: success, neutral and failure.\n * In the cases of success and failure the result is saved to be able to judge the quality of a node.\n * This has influence on the probability that a certain node is selected as partner.\n */\nexport declare class ExtendedNodeExperience {\n\n    /**\n     * Denotes the beginning of the of the Node substructure.\n     */\n    readonly node: Node;\n\n    /**\n     * The number of synchronization attempts the node had with the remote node.\n     */\n    readonly syncs: number;\n\n    /**\n     * Denotes the beginning of the of the NodeExperience substructure.\n     */\n    readonly experience: ExtendedNodeExperienceData;\n}\n\n/**\n * Node experience data\n */\nexport declare class ExtendedNodeExperienceData {\n\n    /**\n     * The number of successful communications with the remote node.\n     */\n    readonly s: number;\n\n    /**\n     * The number of failed communications with the remote node.\n     */\n    readonly f: number;\n}", 
            "title": "Node"
        }, 
        {
            "location": "/documentation/node/#node-related-requests", 
            "text": "Nodes are the entities that exchange data in a network. A node is essentially a NIS instance running on a computer. To be able to communicate with the network, a node needs to be booted. Through node requests it is possible to discover other nodes in the network, learn about other nodes experiences and get information about their current chain height.  Official Source", 
            "title": "Node related requests"
        }, 
        {
            "location": "/documentation/node/#nodehttp-definition", 
            "text": "export declare class NodeHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets basic information about a node\n     * @returns Observable Node \n     */\n    getNodeInfo(): Observable Node ;\n\n    /**\n     * Gets extended information about a node\n     * @returns Observable NisNodeInfo \n     */\n    getNisNodeInfo(): Observable NisNodeInfo ;\n\n    /**\n     * Gets an array of all known nodes in the neighborhood.\n     * @returns Observable NodeCollection \n     */\n    getAllNodes(): Observable NodeCollection ;\n\n    /**\n     * Gets an array of all nodes with status 'active' in the neighborhood.\n     * @returns Observable Node[] \n     */\n    getActiveNodes(): Observable Node[] ;\n\n    /**\n     * Gets an array of active nodes in the neighborhood that are selected for broadcasts.\n     * @returns Observable Node[] \n     */\n    getActiveNeighbourNodes(): Observable Node[] ;\n\n    /**\n     * Requests the chain height from every node in the active node list and returns the maximum height seen.\n     * @returns Observable BlockHeight \n     */\n    getMaximumChainHeightInActiveNeighborhood(): Observable BlockHeight ;\n\n    /**\n     * Requests the chain height from every node in the active node list and returns the maximum height seen.\n     * @returns Observable ExtendedNodeExperience[] \n     */\n    getNodeExperiences(): Observable ExtendedNodeExperience[] ;\n}", 
            "title": "NodeHttp definition"
        }, 
        {
            "location": "/documentation/node/#nodehttp-usage", 
            "text": "import {NodeHttp, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp({domain:  104.128.226.60 });\nnodeHttp.getNodeInfo().subscribe(node =  {\n    console.log(node);\n});  Output:  Node {\n  metaData: \n   NodeMetaData {\n     features: 3,\n     network: -104,\n     application: null,\n     version: '0.6.92-BETA',\n     platform: 'Oracle Corporation (1.8.0_40) on Linux' },\n  endpoint: NodeEndpoint { protocol: 'http', port: 7890, host: '104.128.226.60' },\n  identity: NodeIdentity { name: 'Hi, I am BigAlice2', publickey: undefined } }  Run the code", 
            "title": "NodeHttp usage"
        }, 
        {
            "location": "/documentation/node/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/documentation/node/#node", 
            "text": "/**\n * Nodes are the entities that perform communication in the network like sending and receiving data.\n * A node has an identity which is tied to an account through which the node can identify itself to the network.\n * The communication is done through the endpoint of the node. Additionally a node provides meta data information.\n */\nexport declare class Node {\n\n    /**\n     * Denotes the beginning of the meta data substructure.\n     */\n    readonly metaData: NodeMetaData;\n\n    /**\n     * Denotes the beginning of the endpoint substructure.\n     */\n    readonly endpoint: NodeEndpoint;\n\n    /**\n     * Denotes the beginning of the identity substructure.\n     */\n    readonly identity: NodeIdentity;\n\n}\n\n/**\n * Node meta data\n */\nexport declare class NodeMetaData {\n\n    /**\n     * The number of features the nodes has.\n     */\n    readonly features: number;\n\n    /**\n     * The network id\n     */\n    readonly network: NetworkTypes;\n\n    /**\n     * The name of the application that is running the node.\n     */\n    readonly application: string;\n\n    /**\n     * The version of the application.\n     */\n    readonly version: string;\n\n    /**\n     * The underlying platform (OS, java version).\n     */\n    readonly platform: string;\n}\n\n/**\n * Node endpoint\n */\nexport declare class NodeEndpoint {\n\n    /**\n     * The protocol used for the communication (HTTP or HTTPS).\n     */\n    readonly protocol: string;\n\n    /**\n     * The port used for the communication.\n     */\n    readonly port: number;\n\n    /**\n     * The IP address of the endpoint.\n     */\n    readonly host: string;\n}\n\n/**\n * Node identity\n */\nexport declare class NodeIdentity {\n\n    /**\n     * The name of the node.\n     */\n    readonly name: string;\n\n    /**\n     * The public key used to identify the node.\n     */\n    readonly publickey: string;\n}", 
            "title": "Node"
        }, 
        {
            "location": "/documentation/node/#nisnodeinfo", 
            "text": "/**\n * A NodeCollection object holds arrays of nodes with different statuses.\n */\nexport declare class NisNodeInfo {\n\n    /**\n     * Denotes the beginning of the node substructure.\n     */\n    readonly node: Node;\n\n    /**\n     * Denotes the beginning of the application meta data substructure.\n     */\n    readonly nisInfo: ApplicationMetaData;\n}\n\n/**\n * The application meta data object supplies additional information about the application running on a node.\n */\nexport declare class ApplicationMetaData {\n\n    /**\n     * The current network time, i.e. the number of seconds that have elapsed since the creation of the nemesis block.\n     */\n    readonly currentTime: number;\n\n    /**\n     * The name of the application running on the node.\n     */\n    readonly application: string;\n\n    /**\n     * The network time when the application was started.\n     */\n    readonly startTime: number;\n\n    /**\n     * The application version.\n     */\n    readonly version: string;\n\n    /**\n     * The signer of the certificate used by the application.\n     */\n    readonly signer: string;\n}", 
            "title": "NisNodeInfo"
        }, 
        {
            "location": "/documentation/node/#nodecollection", 
            "text": "/**\n * A NodeCollection object holds arrays of nodes with different statuses.\n */\nexport declare class NodeCollection {\n\n    /**\n     * A connection to the node cannot be established.\n     */\n    readonly inactive: Node[];\n\n    /**\n     * A connection can be established and the remote node responds in a timely manner.\n     */\n    readonly active: Node[];\n\n    /**\n     * A connection can be established but the node cannot provide information within the timeout limits.\n     */\n    readonly busy: Node[];\n\n    /**\n     * A fatal error occurs when trying to establish a connection or the node couldn't authenticate itself correctly.\n     */\n    readonly failure: Node[];\n}", 
            "title": "NodeCollection"
        }, 
        {
            "location": "/documentation/node/#extendednodeexperience", 
            "text": "/**\n * When exchanging data with other nodes the result of the communication is divided into three\n * different outcomes: success, neutral and failure.\n * In the cases of success and failure the result is saved to be able to judge the quality of a node.\n * This has influence on the probability that a certain node is selected as partner.\n */\nexport declare class ExtendedNodeExperience {\n\n    /**\n     * Denotes the beginning of the of the Node substructure.\n     */\n    readonly node: Node;\n\n    /**\n     * The number of synchronization attempts the node had with the remote node.\n     */\n    readonly syncs: number;\n\n    /**\n     * Denotes the beginning of the of the NodeExperience substructure.\n     */\n    readonly experience: ExtendedNodeExperienceData;\n}\n\n/**\n * Node experience data\n */\nexport declare class ExtendedNodeExperienceData {\n\n    /**\n     * The number of successful communications with the remote node.\n     */\n    readonly s: number;\n\n    /**\n     * The number of failed communications with the remote node.\n     */\n    readonly f: number;\n}", 
            "title": "ExtendedNodeExperience"
        }, 
        {
            "location": "/documentation/blockchain/", 
            "text": "Blockchain related requests\n\n\nNEM builds a block chain which contains every bit of information needed. Subsequent blocks in the block chain have increasing heights that differ by one. Each block can contain transactions. Transactions build the basis of all account activity. It is therefore important to understand the concept and the structures of blocks and transactions.\n\n\nBlocks are generated by accounts. If an account generates a block and the block gets included in the block chain, the generating account, called the harvester, gets all the transaction fees for transactions that are included in the block. A harvester will therefore usually include as many transactions as possible.\n\n\nTransactions reflect all account activities. In order for a client to have an up to date balance for every account it is crucial to know about every transaction that occurred and therefore the client must have knowledge about every single block in the chain (one says: the client must be synchronized with the block chain).\n\n\nOfficial Source\n\n\nBlockHttp definition\n\n\nexport declare type BlockHeight = number;\n\nexport declare type BlockChainScore = number;\n\nexport declare class BlockHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets a block from the chain that has a given hash.\n     * @param BlockHeight - A BlockHeight JSON object\n     * @returns Observable\nBlock\n\n     */\n    getBlockByHeight(blockHeight: BlockHeight): Observable\nBlock\n;\n}\n\n\n\n\n\nBlockHttp usage\n\n\nimport {BlockHttp, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst blockHttp = new BlockHttp({domain: \n104.128.226.60\n});\nblockHttp.getBlockByHeight(1033023).subscribe(block =\n {\n    console.log(block);\n});\n\n\n\n\nOutput\n\n\nBlock {\n  height: 1033023,\n  type: 1,\n  timeStamp: 72650707,\n  prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' },\n  signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00',\n  signer: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a',\n  transactions: [],\n  version: -1744830463 }\n\n\n\n\nRun the code\n\n\nChainHttp definition\n\n\nexport declare class ChainHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n    /**\n     * Gets the current height of the block chain.\n     * @returns Observable\nBlockHeight\n\n     */\n    getBlockchainHeight(): Observable\nBlockHeight\n;\n    /**\n     * Gets the current score of the block chain. The higher the score, the better the chain.\n     * During synchronization, nodes try to get the best block chain in the network.\n     * @returns Observable\nBlockChainScore\n\n     */\n    getBlockchainScore(): Observable\nBlockChainScore\n;\n    /**\n     * Gets the current last block of the chain.\n     * @returns Observable\nBlock\n\n     */\n    getBlockchainLastBlock(): Observable\nBlock\n;\n}\n\n\n\n\n\n\nChainHttp usage\n\n\nimport {ChainHttp, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst chainHttp = new ChainHttp({domain: \n104.128.226.60\n});\nchainHttp.getBlockchainLastBlock().subscribe(block =\n {\n    console.log(block);\n});\n\n\n\n\nOutput\n\n\nBlock {\n  height: 1035218,\n  type: 1,\n  timeStamp: 72783289,\n  prevBlockHash: { data: '551c478f401323be74da2618bd686d30c8c805c2d7bb3c19c49a8c0be6333d7f' },\n  signature: '0ccb28a63fe3fb1f65c0815c76ba7bad5896b71a9e696d28dd29f3b5294e977b51ecbf4add3f528c965ef67eba1c62acbb74c0779f2fc1a1c7bda6cb467fdb05',\n  signer: 'b3180ba3814a293f6b0ade952a65abc2aad6a430e4c33a20c216c8c6ceba584f',\n  transactions: [],\n  version: -1744830463 }\n\n\n\n\n\nRun the code\n\n\nModels\n\n\nBlock\n\n\n\nexport declare enum BlockVersion {\n  MAIN_NET = 0x68,\n  TEST_NET = 0x98\n}\n\nexport declare enum BlockType {\n  NEMESIS = -1,\n  REGULAR = 1\n}\n\n/**\n * A blockchain is the structure that contains the transaction information. A blockchain can contain up to 120 transactions. Blocks are generated and signed by accounts and are the instrument by which information is spread in the network.\n */\nexport declare class Block  {\n\n  /**\n   * The height of the blockchain. Each blockchain has a unique height. Subsequent blocks differ in height by 1.\n   */\n  readonly height: BlockHeight;\n\n  /**\n   * The blockchain type\n   */\n  readonly type: BlockType;\n\n  /**\n   * The number of seconds elapsed since the creation of the nemesis blockchain.\n   */\n  readonly timeStamp: number;\n\n  /**\n   * The sha3-256 hash of the last blockchain as hex-string.\n   */\n  readonly prevBlockHash: HashData;\n\n  /**\n   * The signature of the blockchain. The signature was generated by the signer and can be used to validate that the blockchain data was not modified by a node.\n   */\n  readonly signature: string;\n\n  /**\n   * The public key of the harvester of the blockchain as hexadecimal number.\n   */\n  readonly signer: string;\n\n  /**\n   * The array of transaction\n   */\n  readonly transactions: Transaction[];\n\n  /**\n   * The blockchain version\n   */\n  readonly version: BlockVersion;\n }", 
            "title": "Blockchain"
        }, 
        {
            "location": "/documentation/blockchain/#blockchain-related-requests", 
            "text": "NEM builds a block chain which contains every bit of information needed. Subsequent blocks in the block chain have increasing heights that differ by one. Each block can contain transactions. Transactions build the basis of all account activity. It is therefore important to understand the concept and the structures of blocks and transactions.  Blocks are generated by accounts. If an account generates a block and the block gets included in the block chain, the generating account, called the harvester, gets all the transaction fees for transactions that are included in the block. A harvester will therefore usually include as many transactions as possible.  Transactions reflect all account activities. In order for a client to have an up to date balance for every account it is crucial to know about every transaction that occurred and therefore the client must have knowledge about every single block in the chain (one says: the client must be synchronized with the block chain).  Official Source", 
            "title": "Blockchain related requests"
        }, 
        {
            "location": "/documentation/blockchain/#blockhttp-definition", 
            "text": "export declare type BlockHeight = number;\n\nexport declare type BlockChainScore = number;\n\nexport declare class BlockHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n\n    /**\n     * Gets a block from the chain that has a given hash.\n     * @param BlockHeight - A BlockHeight JSON object\n     * @returns Observable Block \n     */\n    getBlockByHeight(blockHeight: BlockHeight): Observable Block ;\n}", 
            "title": "BlockHttp definition"
        }, 
        {
            "location": "/documentation/blockchain/#blockhttp-usage", 
            "text": "import {BlockHttp, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst blockHttp = new BlockHttp({domain:  104.128.226.60 });\nblockHttp.getBlockByHeight(1033023).subscribe(block =  {\n    console.log(block);\n});  Output  Block {\n  height: 1033023,\n  type: 1,\n  timeStamp: 72650707,\n  prevBlockHash: { data: 'ec766003b1f7ed462ddb5e3bd71d7def7f52cf34aa2ed3f0887bfbeaf59bb77c' },\n  signature: '1e58ab2147db1edf746e899569e2c371c3b532fdf29ed77f3ddf54723b1ccc9ce745fc01ccb97b445e90e509035b1909950c4ba3428c20f31056bab4feff2e00',\n  signer: '45880194fad01fcb55887b73eeffdc263914ed5749bf2f3acb928c843c57bd9a',\n  transactions: [],\n  version: -1744830463 }  Run the code", 
            "title": "BlockHttp usage"
        }, 
        {
            "location": "/documentation/blockchain/#chainhttp-definition", 
            "text": "export declare class ChainHttp extends HttpEndpoint {\n    constructor(serverConfig?: ServerConfig);\n    /**\n     * Gets the current height of the block chain.\n     * @returns Observable BlockHeight \n     */\n    getBlockchainHeight(): Observable BlockHeight ;\n    /**\n     * Gets the current score of the block chain. The higher the score, the better the chain.\n     * During synchronization, nodes try to get the best block chain in the network.\n     * @returns Observable BlockChainScore \n     */\n    getBlockchainScore(): Observable BlockChainScore ;\n    /**\n     * Gets the current last block of the chain.\n     * @returns Observable Block \n     */\n    getBlockchainLastBlock(): Observable Block ;\n}", 
            "title": "ChainHttp definition"
        }, 
        {
            "location": "/documentation/blockchain/#chainhttp-usage", 
            "text": "import {ChainHttp, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst chainHttp = new ChainHttp({domain:  104.128.226.60 });\nchainHttp.getBlockchainLastBlock().subscribe(block =  {\n    console.log(block);\n});  Output  Block {\n  height: 1035218,\n  type: 1,\n  timeStamp: 72783289,\n  prevBlockHash: { data: '551c478f401323be74da2618bd686d30c8c805c2d7bb3c19c49a8c0be6333d7f' },\n  signature: '0ccb28a63fe3fb1f65c0815c76ba7bad5896b71a9e696d28dd29f3b5294e977b51ecbf4add3f528c965ef67eba1c62acbb74c0779f2fc1a1c7bda6cb467fdb05',\n  signer: 'b3180ba3814a293f6b0ade952a65abc2aad6a430e4c33a20c216c8c6ceba584f',\n  transactions: [],\n  version: -1744830463 }  Run the code", 
            "title": "ChainHttp usage"
        }, 
        {
            "location": "/documentation/blockchain/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/documentation/blockchain/#block", 
            "text": "export declare enum BlockVersion {\n  MAIN_NET = 0x68,\n  TEST_NET = 0x98\n}\n\nexport declare enum BlockType {\n  NEMESIS = -1,\n  REGULAR = 1\n}\n\n/**\n * A blockchain is the structure that contains the transaction information. A blockchain can contain up to 120 transactions. Blocks are generated and signed by accounts and are the instrument by which information is spread in the network.\n */\nexport declare class Block  {\n\n  /**\n   * The height of the blockchain. Each blockchain has a unique height. Subsequent blocks differ in height by 1.\n   */\n  readonly height: BlockHeight;\n\n  /**\n   * The blockchain type\n   */\n  readonly type: BlockType;\n\n  /**\n   * The number of seconds elapsed since the creation of the nemesis blockchain.\n   */\n  readonly timeStamp: number;\n\n  /**\n   * The sha3-256 hash of the last blockchain as hex-string.\n   */\n  readonly prevBlockHash: HashData;\n\n  /**\n   * The signature of the blockchain. The signature was generated by the signer and can be used to validate that the blockchain data was not modified by a node.\n   */\n  readonly signature: string;\n\n  /**\n   * The public key of the harvester of the blockchain as hexadecimal number.\n   */\n  readonly signer: string;\n\n  /**\n   * The array of transaction\n   */\n  readonly transactions: Transaction[];\n\n  /**\n   * The blockchain version\n   */\n  readonly version: BlockVersion;\n }", 
            "title": "Block"
        }, 
        {
            "location": "/documentation/listener/", 
            "text": "Listeners\n\n\nAccountListener definition\n\n\n/**\n * Account listener\n */\nexport declare class AccountListener extends Listener {\n\n    /**\n     * Constructor\n     * @param config\n     */\n    constructor(config?: WebSocketConfig);\n\n    /**\n     * Start listening updates\n     * @param address\n     * @returns {Observable\nAccountInfoWithMetaData\n}\n     */\n    given(address: Address): Observable\nAccountInfoWithMetaData\n;\n}\n\n\n\n\n\n\nAccountListener usage\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {AccountListener, Address, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\nTCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\n);\nlet accountListener = new AccountListener({domain: \n23.228.67.85\n}).given(address).subscribe(x =\n {\n    console.log(x);\n}, err =\n {\n    console.log(err);\n});\n\n\n\n\n\n\nOutput\n\n\nAccountInfoWithMetaData {\n  balance: \n   Balance {\n     balance: 10246300001,\n     vestedBalance: 5507591402,\n     unvestedBalance: 4738708599 },\n  importance: 0,\n  publicAccount: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA',\n        networkType: 152 },\n     publicKey: 'a4f9d42cf8e1f7c6c3216ede81896c4fa9f49071ee4aee2a4843e2711899b23a' },\n  harvestedBlocks: 0,\n  cosignatoriesCount: undefined,\n  minCosignatories: undefined,\n  status: 'LOCKED',\n  remoteStatus: 'ACTIVE',\n  cosignatoryOf: \n   [ AccountInfo {\n       balance: [Object],\n       importance: 0,\n       publicAccount: [Object],\n       harvestedBlocks: 0,\n       cosignatoriesCount: undefined,\n       minCosignatories: undefined },\n     AccountInfo {\n       balance: [Object],\n       importance: 0,\n       publicAccount: [Object],\n       harvestedBlocks: 0,\n       cosignatoriesCount: undefined,\n       minCosignatories: undefined } ],\n  cosignatories: [] }\n\n\n\n\n\nRun the code\n\n\nBlockchainListener definition\n\n\n/**\n * Blockchain listener\n */\nexport declare class BlockchainListener extends Listener {\n\n    /**\n     * Constructor\n     * @param config\n     */\n    constructor(config?: WebSocketConfig);\n\n    /**\n     * Start listening new blocks\n     * @returns {Observable\nBlock\n}\n     */\n    newBlock(): Observable\nBlock\n;\n\n    /**\n     * Start listening new blockchain height\n     * @returns {Observable\nBlockHeight\n}\n     */\n    newHeight(): Observable\nBlockHeight\n;\n}\n\n\n\n\n\n\nUnconfirmedTransactionListener definition\n\n\n/**\n * UnconfirmedTransaction listener\n */\nexport declare class UnconfirmedTransactionListener extends Listener {\n\n    /**\n     * Constructor\n     * @param config\n     */\n    constructor(config?: WebSocketConfig);\n\n    /**\n     * Start listening new unconfirmed transactions\n     * @param address\n     * @returns {Observable\nTransaction\n}\n     */\n    given(address: Address): Observable\nTransaction\n;\n\n}\n\n\n\n\n\n\nConfirmedTransactionListener definition\n\n\n/**\n * ConfirmedTransaction listener\n */\nexport declare class ConfirmedTransactionListener extends Listener {\n\n    /**\n     * Constructor\n     * @param config\n     */\n    constructor(config?: WebSocketConfig);\n\n    /**\n     * Start listening new confirmed transactions\n     * @param address\n     * @returns {Observable\nTransaction\n}\n     */\n    given(address: Address): Observable\nTransaction\n;\n\n}", 
            "title": "Listener"
        }, 
        {
            "location": "/documentation/listener/#listeners", 
            "text": "", 
            "title": "Listeners"
        }, 
        {
            "location": "/documentation/listener/#accountlistener-definition", 
            "text": "/**\n * Account listener\n */\nexport declare class AccountListener extends Listener {\n\n    /**\n     * Constructor\n     * @param config\n     */\n    constructor(config?: WebSocketConfig);\n\n    /**\n     * Start listening updates\n     * @param address\n     * @returns {Observable AccountInfoWithMetaData }\n     */\n    given(address: Address): Observable AccountInfoWithMetaData ;\n}", 
            "title": "AccountListener definition"
        }, 
        {
            "location": "/documentation/listener/#accountlistener-usage", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {AccountListener, Address, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address( TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA );\nlet accountListener = new AccountListener({domain:  23.228.67.85 }).given(address).subscribe(x =  {\n    console.log(x);\n}, err =  {\n    console.log(err);\n});  Output  AccountInfoWithMetaData {\n  balance: \n   Balance {\n     balance: 10246300001,\n     vestedBalance: 5507591402,\n     unvestedBalance: 4738708599 },\n  importance: 0,\n  publicAccount: \n   PublicAccount {\n     address: \n      Address {\n        value: 'TCJZJHAV63RE2JSKN27DFIHZRXIHAI736WXEOJGA',\n        networkType: 152 },\n     publicKey: 'a4f9d42cf8e1f7c6c3216ede81896c4fa9f49071ee4aee2a4843e2711899b23a' },\n  harvestedBlocks: 0,\n  cosignatoriesCount: undefined,\n  minCosignatories: undefined,\n  status: 'LOCKED',\n  remoteStatus: 'ACTIVE',\n  cosignatoryOf: \n   [ AccountInfo {\n       balance: [Object],\n       importance: 0,\n       publicAccount: [Object],\n       harvestedBlocks: 0,\n       cosignatoriesCount: undefined,\n       minCosignatories: undefined },\n     AccountInfo {\n       balance: [Object],\n       importance: 0,\n       publicAccount: [Object],\n       harvestedBlocks: 0,\n       cosignatoriesCount: undefined,\n       minCosignatories: undefined } ],\n  cosignatories: [] }  Run the code", 
            "title": "AccountListener usage"
        }, 
        {
            "location": "/documentation/listener/#blockchainlistener-definition", 
            "text": "/**\n * Blockchain listener\n */\nexport declare class BlockchainListener extends Listener {\n\n    /**\n     * Constructor\n     * @param config\n     */\n    constructor(config?: WebSocketConfig);\n\n    /**\n     * Start listening new blocks\n     * @returns {Observable Block }\n     */\n    newBlock(): Observable Block ;\n\n    /**\n     * Start listening new blockchain height\n     * @returns {Observable BlockHeight }\n     */\n    newHeight(): Observable BlockHeight ;\n}", 
            "title": "BlockchainListener definition"
        }, 
        {
            "location": "/documentation/listener/#unconfirmedtransactionlistener-definition", 
            "text": "/**\n * UnconfirmedTransaction listener\n */\nexport declare class UnconfirmedTransactionListener extends Listener {\n\n    /**\n     * Constructor\n     * @param config\n     */\n    constructor(config?: WebSocketConfig);\n\n    /**\n     * Start listening new unconfirmed transactions\n     * @param address\n     * @returns {Observable Transaction }\n     */\n    given(address: Address): Observable Transaction ;\n\n}", 
            "title": "UnconfirmedTransactionListener definition"
        }, 
        {
            "location": "/documentation/listener/#confirmedtransactionlistener-definition", 
            "text": "/**\n * ConfirmedTransaction listener\n */\nexport declare class ConfirmedTransactionListener extends Listener {\n\n    /**\n     * Constructor\n     * @param config\n     */\n    constructor(config?: WebSocketConfig);\n\n    /**\n     * Start listening new confirmed transactions\n     * @param address\n     * @returns {Observable Transaction }\n     */\n    given(address: Address): Observable Transaction ;\n\n}", 
            "title": "ConfirmedTransactionListener definition"
        }, 
        {
            "location": "/documentation/wallet/", 
            "text": "Wallets\n\n\nSimpleWallet definition\n\n\n/**\n * Simple wallet model generates a private key from a PRNG\n */\nexport declare class SimpleWallet extends Wallet {\n\n    /**\n     * The encripted private key and information to decrypt it\n     */\n    readonly encryptedPrivateKey: EncryptedPrivateKey;\n\n    /**\n     * Create a SimpleWallet\n     * @param name\n     * @param password\n     * @returns {SimpleWallet}\n     */\n    static create(name: string, password: Password): SimpleWallet;\n\n    /**\n     * Create a SimpleWallet from private key\n     * @param name\n     * @param network\n     * @param password\n     * @param privateKey\n     * @returns {SimpleWallet}\n     */\n    static createWithPrivateKey(name: string, password: Password, privateKey: string): SimpleWallet;\n\n    /**\n     * Open a wallet and generate an Account\n     * @param password\n     * @returns {Account}\n     */\n    open(password: Password): Account;\n}\n\n\n\n\n\nSimpleWallet usage\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst password = new Password(\npassword\n);\nconst simpleWallet = SimpleWallet.create(\nsimple wallet\n, password);\n\nconsole.log(simpleWallet);\n\n\n\n\nOutput\n\n\nSimpleWallet {\n  name: 'simple wallet',\n  network: 152,\n  address: \n   Address {\n     value: 'TBSICCK3PJZDWQ4JCPWT55IRBWEQMRSABQ3QJHE4',\n     networkType: 152 },\n  creationDate: \n   LocalDateTime {\n     _date: LocalDate { _year: 2017, _month: 7, _day: 24 },\n     _time: LocalTime { _hour: 16, _minute: 44, _second: 14, _nano: 870000000 } },\n  encryptedPrivateKey: \n   EncryptedPrivateKey {\n     encryptedKey: '2cb583e61208964d465955cc35c86c9e83733a10adc40cee6b8c650478ffe3667ccb70328a0dc2c67de9770806040580',\n     iv: 'c192d9a501c7dde5c7e05186c93b63da' } }\n\n\n\n\n\nRun the code\n\n\nBrainWallet definition\n\n\n/**\n * Brain wallet derived the private key from the brainPassword, hashing the brainPassword multiple times, therefore it's crucial to select a SAFE brainPassword.\n */\nexport declare class BrainWallet extends Wallet {\n\n    /**\n     * Create a BrainWallet\n     * @param name\n     * @param password\n     * @returns {BrainWallet}\n     */\n    static create(name: string, password: BrainPassword): BrainWallet;\n\n    /**\n     * Open a wallet and generate an Account\n     * @param password\n     * @returns {Account}\n     */\n    open(password: BrainPassword): Account;\n}\n\n\n\n\n\nBrainWallet usage\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst brainPassword =  new BrainPassword(\nentertain destruction sassy impartial morning electric limit glib bait grape icy measure\n)\nconst brainWallet = BrainWallet.create(\nbrain wallet\n, brainPassword);\n\nconsole.log(brainWallet);\n\n\n\n\nOutput\n\n\nBrainWallet {\n  name: 'brain wallet',\n  network: 152,\n  address: \n   Address {\n     value: 'TBUWTIIYM2BFFAE3JOEW3LGG5X3QTO7L2RWGZ6XV',\n     networkType: 152 },\n  creationDate: \n   LocalDateTime {\n     _date: LocalDate { _year: 2017, _month: 7, _day: 24 },\n     _time: LocalTime { _hour: 16, _minute: 44, _second: 42, _nano: 402000000 } } }\n\n\n\n\n\nRun the code\n\n\nModels\n\n\nWallet\n\n\n/**\n * Wallet base model\n */\nexport declare abstract class Wallet {\n\n    /**\n     * The wallet's name\n     */\n    readonly name: string;\n\n    /**\n     * The wallet's network\n     */\n    readonly network: NetworkTypes;\n\n    /**\n     * The wallet's address\n     */\n    readonly address: Address;\n\n    /**\n     * The wallet's creation date\n     */\n    readonly creationDate: LocalDateTime;\n\n    /**\n     * Abstract open wallet method returning an account from current wallet.\n     * @param password\n     */\n    abstract open(password: Password): Account;\n}\n\n\n\n\n\nPassword\n\n\n/**\n * Password model\n */\nexport declare class Password {\n\n    /**\n     * Password value\n     */\n    readonly value: string;\n\n    /**\n     * Create a password with at least 8 characters\n     * @param password\n     */\n    constructor(password: string);\n}\n\n\n\n\n\nBrainPassword\n\n\n/**\n * Brain password is an extended version of Password. With the brain password we derive the private key in BrainWallets.\n */\nexport declare class BrainPassword extends Password {\n\n    /**\n     * Constructor\n     * @param password - password must be secure, we are we recommend using a 12 random words password. The password must have at least 32 characters.\n     */\n    constructor(password: string);\n}\n\n\n\n\n\nEncryptedPrivateKey\n\n\n/**\n * EncryptedPrivateKey model\n */\nexport declare class EncryptedPrivateKey {\n\n    /**\n     * Encrypted private key data\n     */\n    readonly encryptedKey: string;\n\n    /**\n     * Initialization vector used in the decrypt process\n     */\n    readonly iv: string;\n}", 
            "title": "Wallet"
        }, 
        {
            "location": "/documentation/wallet/#wallets", 
            "text": "", 
            "title": "Wallets"
        }, 
        {
            "location": "/documentation/wallet/#simplewallet-definition", 
            "text": "/**\n * Simple wallet model generates a private key from a PRNG\n */\nexport declare class SimpleWallet extends Wallet {\n\n    /**\n     * The encripted private key and information to decrypt it\n     */\n    readonly encryptedPrivateKey: EncryptedPrivateKey;\n\n    /**\n     * Create a SimpleWallet\n     * @param name\n     * @param password\n     * @returns {SimpleWallet}\n     */\n    static create(name: string, password: Password): SimpleWallet;\n\n    /**\n     * Create a SimpleWallet from private key\n     * @param name\n     * @param network\n     * @param password\n     * @param privateKey\n     * @returns {SimpleWallet}\n     */\n    static createWithPrivateKey(name: string, password: Password, privateKey: string): SimpleWallet;\n\n    /**\n     * Open a wallet and generate an Account\n     * @param password\n     * @returns {Account}\n     */\n    open(password: Password): Account;\n}", 
            "title": "SimpleWallet definition"
        }, 
        {
            "location": "/documentation/wallet/#simplewallet-usage", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst password = new Password( password );\nconst simpleWallet = SimpleWallet.create( simple wallet , password);\n\nconsole.log(simpleWallet);  Output  SimpleWallet {\n  name: 'simple wallet',\n  network: 152,\n  address: \n   Address {\n     value: 'TBSICCK3PJZDWQ4JCPWT55IRBWEQMRSABQ3QJHE4',\n     networkType: 152 },\n  creationDate: \n   LocalDateTime {\n     _date: LocalDate { _year: 2017, _month: 7, _day: 24 },\n     _time: LocalTime { _hour: 16, _minute: 44, _second: 14, _nano: 870000000 } },\n  encryptedPrivateKey: \n   EncryptedPrivateKey {\n     encryptedKey: '2cb583e61208964d465955cc35c86c9e83733a10adc40cee6b8c650478ffe3667ccb70328a0dc2c67de9770806040580',\n     iv: 'c192d9a501c7dde5c7e05186c93b63da' } }  Run the code", 
            "title": "SimpleWallet usage"
        }, 
        {
            "location": "/documentation/wallet/#brainwallet-definition", 
            "text": "/**\n * Brain wallet derived the private key from the brainPassword, hashing the brainPassword multiple times, therefore it's crucial to select a SAFE brainPassword.\n */\nexport declare class BrainWallet extends Wallet {\n\n    /**\n     * Create a BrainWallet\n     * @param name\n     * @param password\n     * @returns {BrainWallet}\n     */\n    static create(name: string, password: BrainPassword): BrainWallet;\n\n    /**\n     * Open a wallet and generate an Account\n     * @param password\n     * @returns {Account}\n     */\n    open(password: BrainPassword): Account;\n}", 
            "title": "BrainWallet definition"
        }, 
        {
            "location": "/documentation/wallet/#brainwallet-usage", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst brainPassword =  new BrainPassword( entertain destruction sassy impartial morning electric limit glib bait grape icy measure )\nconst brainWallet = BrainWallet.create( brain wallet , brainPassword);\n\nconsole.log(brainWallet);  Output  BrainWallet {\n  name: 'brain wallet',\n  network: 152,\n  address: \n   Address {\n     value: 'TBUWTIIYM2BFFAE3JOEW3LGG5X3QTO7L2RWGZ6XV',\n     networkType: 152 },\n  creationDate: \n   LocalDateTime {\n     _date: LocalDate { _year: 2017, _month: 7, _day: 24 },\n     _time: LocalTime { _hour: 16, _minute: 44, _second: 42, _nano: 402000000 } } }  Run the code", 
            "title": "BrainWallet usage"
        }, 
        {
            "location": "/documentation/wallet/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/documentation/wallet/#wallet", 
            "text": "/**\n * Wallet base model\n */\nexport declare abstract class Wallet {\n\n    /**\n     * The wallet's name\n     */\n    readonly name: string;\n\n    /**\n     * The wallet's network\n     */\n    readonly network: NetworkTypes;\n\n    /**\n     * The wallet's address\n     */\n    readonly address: Address;\n\n    /**\n     * The wallet's creation date\n     */\n    readonly creationDate: LocalDateTime;\n\n    /**\n     * Abstract open wallet method returning an account from current wallet.\n     * @param password\n     */\n    abstract open(password: Password): Account;\n}", 
            "title": "Wallet"
        }, 
        {
            "location": "/documentation/wallet/#password", 
            "text": "/**\n * Password model\n */\nexport declare class Password {\n\n    /**\n     * Password value\n     */\n    readonly value: string;\n\n    /**\n     * Create a password with at least 8 characters\n     * @param password\n     */\n    constructor(password: string);\n}", 
            "title": "Password"
        }, 
        {
            "location": "/documentation/wallet/#brainpassword", 
            "text": "/**\n * Brain password is an extended version of Password. With the brain password we derive the private key in BrainWallets.\n */\nexport declare class BrainPassword extends Password {\n\n    /**\n     * Constructor\n     * @param password - password must be secure, we are we recommend using a 12 random words password. The password must have at least 32 characters.\n     */\n    constructor(password: string);\n}", 
            "title": "BrainPassword"
        }, 
        {
            "location": "/documentation/wallet/#encryptedprivatekey", 
            "text": "/**\n * EncryptedPrivateKey model\n */\nexport declare class EncryptedPrivateKey {\n\n    /**\n     * Encrypted private key data\n     */\n    readonly encryptedKey: string;\n\n    /**\n     * Initialization vector used in the decrypt process\n     */\n    readonly iv: string;\n}", 
            "title": "EncryptedPrivateKey"
        }, 
        {
            "location": "/guide/overview/", 
            "text": "Working examples\n\n\nThe guide section shows some \nHow to\n use the NEM Library. \n\n\nYou can find the code examples pre-configured and ready to use at \ngithub.com/aleixmorgadas/nem-library-examples\n\n\nTimeWindow concept\n\n\nThe TimeWindow concept is related with the Transactions. A transaction has as \nTimeWindow\n where it can be included in a block,\nonce the deadline of the TimeWindow is after the Node timestamp, the transaction is rejected.", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/overview/#working-examples", 
            "text": "The guide section shows some  How to  use the NEM Library.   You can find the code examples pre-configured and ready to use at  github.com/aleixmorgadas/nem-library-examples", 
            "title": "Working examples"
        }, 
        {
            "location": "/guide/overview/#timewindow-concept", 
            "text": "The TimeWindow concept is related with the Transactions. A transaction has as  TimeWindow  where it can be included in a block,\nonce the deadline of the TimeWindow is after the Node timestamp, the transaction is rejected.", 
            "title": "TimeWindow concept"
        }, 
        {
            "location": "/guide/account/", 
            "text": "How to receive all transactions for an account\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.allTransactions(new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n))\n    .subscribe(allTransactions =\n {\n       console.log(allTransactions);\n    });\n\n\n\n\nSource code\n\n\nHow to receive all transactions for an account paginated\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport { AccountHttp, Address, NEMLibrary, NetworkTypes } from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\nlet address = new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n);\nlet accountHttp = new AccountHttp();\n\nlet pageable = accountHttp.allTransactionsPaginated(address);\n\npageable.subscribe(transactions =\n {\n    // do something with the info\n});\n\npageable.nextPage(); // Fetch the nexts 25 transactions\n\n\n\n\nSource code\n\n\nHow to receive incoming transactions for an account\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.incomingTransactions(new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n))\n    .subscribe(x =\n {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to receive outgoing transactions for an account\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.outgoingTransactions(new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n))\n    .subscribe(x =\n {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to get the unconfirmed transactions for an account\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.unconfirmedTransactions(new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n))\n    .subscribe(x =\n {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to get Account harvested blocks info paginated\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.getAccountImportances()\n    .subscribe(x =\n {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to get Account Importances\n\n\nimport {AccountHttp, Address, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.getAccountImportances()\n    .subscribe(x =\n {\n        console.log(x);\n    });\n\n\n\n\nSource code\n\n\nHow to convert a Normal Account into Multisig Account\n\n\nimport {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM, MultisigAggregateModificationTransaction,\n    CosignatoryModification, CosignatoryModificationAction\n} from \nnem-library\n;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp({domain: \n104.128.226.60\n});\n\n// Replace with the private key of the account that you want to convert into multisig\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst cosignatory1PublicKey: string = process.env.COSIGNATORY_1_PUBLIC_KEY;\nconst cosignatory2PublicKey: string = process.env.COSIGNATORY_2_PUBLIC_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst cosignatory1 = PublicAccount.createWithPublicKey(cosignatory1PublicKey);\nconst cosignatory2 = PublicAccount.createWithPublicKey(cosignatory2PublicKey);\n\nconst convertIntoMultisigTransaction = MultisigAggregateModificationTransaction.create(\n    TimeWindow.createWithDeadline(),\n    [\n        new CosignatoryModification(cosignatory1, CosignatoryModificationAction.ADD),\n        new CosignatoryModification(cosignatory2, CosignatoryModificationAction.ADD),\n    ],\n    2\n);\n\nconst signedTransaction = account.signTransaction(convertIntoMultisigTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe(x =\n console.log(x));\n\n\n\n\nSource code\n\n\nHow to enable harvesting\n\n\nimport {\n    NEMLibrary, NetworkTypes, Account, TimeWindow,\n    PublicAccount, TransactionHttp, ImportanceMode, ImportanceTransferTransaction, AccountHttp\n} from \nnem-library\n;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst delegateAccountHarvestingPrivateKey: string = process.env.HARVESTING_PRIVATE_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\nconst delegatedAccount = Account.createWithPublicKey(delegateAccountHarvestingPrivateKey);\n\nconst importanceTransferTransaction = ImportanceTransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    ImportanceMode.Activate,\n    PublicAccount.createWithPublicKey(delegatedAccount.publicKey)\n);\n\nconst signedTransaction = account.signTransaction(importanceTransferTransaction);\n\nconst transactionHttp = new TransactionHttp({domain: \n104.128.226.60\n});\ntransactionHttp.announceTransaction(signedTransaction).subscribe(x =\n console.log(x));\n\n// Wait aproximately 6h for you delegated account to be active\n\nconst accountHttp = new AccountHttp({domain: \n104.128.226.60\n});\n\n// Testnet supernode\nconst supernodeDomain = \n188.68.50.161\n;\n\naccountHttp.unlockHarvesting(supernodeDomain, delegateAccountHarvestingPrivateKey).subscribe(success =\n console.log(success));\n\n\n\n\n\nSource code", 
            "title": "Account"
        }, 
        {
            "location": "/guide/account/#how-to-receive-all-transactions-for-an-account", 
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.allTransactions(new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ))\n    .subscribe(allTransactions =  {\n       console.log(allTransactions);\n    });  Source code", 
            "title": "How to receive all transactions for an account"
        }, 
        {
            "location": "/guide/account/#how-to-receive-all-transactions-for-an-account-paginated", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport { AccountHttp, Address, NEMLibrary, NetworkTypes } from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\nlet address = new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J );\nlet accountHttp = new AccountHttp();\n\nlet pageable = accountHttp.allTransactionsPaginated(address);\n\npageable.subscribe(transactions =  {\n    // do something with the info\n});\n\npageable.nextPage(); // Fetch the nexts 25 transactions  Source code", 
            "title": "How to receive all transactions for an account paginated"
        }, 
        {
            "location": "/guide/account/#how-to-receive-incoming-transactions-for-an-account", 
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.incomingTransactions(new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ))\n    .subscribe(x =  {\n        console.log(x);\n    });  Source code", 
            "title": "How to receive incoming transactions for an account"
        }, 
        {
            "location": "/guide/account/#how-to-receive-outgoing-transactions-for-an-account", 
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.outgoingTransactions(new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ))\n    .subscribe(x =  {\n        console.log(x);\n    });  Source code", 
            "title": "How to receive outgoing transactions for an account"
        }, 
        {
            "location": "/guide/account/#how-to-get-the-unconfirmed-transactions-for-an-account", 
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.unconfirmedTransactions(new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ))\n    .subscribe(x =  {\n        console.log(x);\n    });  Source code", 
            "title": "How to get the unconfirmed transactions for an account"
        }, 
        {
            "location": "/guide/account/#how-to-get-account-harvested-blocks-info-paginated", 
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.getAccountImportances()\n    .subscribe(x =  {\n        console.log(x);\n    });  Source code", 
            "title": "How to get Account harvested blocks info paginated"
        }, 
        {
            "location": "/guide/account/#how-to-get-account-importances", 
            "text": "import {AccountHttp, Address, NEMLibrary, NetworkTypes} from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.getAccountImportances()\n    .subscribe(x =  {\n        console.log(x);\n    });  Source code", 
            "title": "How to get Account Importances"
        }, 
        {
            "location": "/guide/account/#how-to-convert-a-normal-account-into-multisig-account", 
            "text": "import {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM, MultisigAggregateModificationTransaction,\n    CosignatoryModification, CosignatoryModificationAction\n} from  nem-library ;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp({domain:  104.128.226.60 });\n\n// Replace with the private key of the account that you want to convert into multisig\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst cosignatory1PublicKey: string = process.env.COSIGNATORY_1_PUBLIC_KEY;\nconst cosignatory2PublicKey: string = process.env.COSIGNATORY_2_PUBLIC_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst cosignatory1 = PublicAccount.createWithPublicKey(cosignatory1PublicKey);\nconst cosignatory2 = PublicAccount.createWithPublicKey(cosignatory2PublicKey);\n\nconst convertIntoMultisigTransaction = MultisigAggregateModificationTransaction.create(\n    TimeWindow.createWithDeadline(),\n    [\n        new CosignatoryModification(cosignatory1, CosignatoryModificationAction.ADD),\n        new CosignatoryModification(cosignatory2, CosignatoryModificationAction.ADD),\n    ],\n    2\n);\n\nconst signedTransaction = account.signTransaction(convertIntoMultisigTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe(x =  console.log(x));  Source code", 
            "title": "How to convert a Normal Account into Multisig Account"
        }, 
        {
            "location": "/guide/account/#how-to-enable-harvesting", 
            "text": "import {\n    NEMLibrary, NetworkTypes, Account, TimeWindow,\n    PublicAccount, TransactionHttp, ImportanceMode, ImportanceTransferTransaction, AccountHttp\n} from  nem-library ;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst delegateAccountHarvestingPrivateKey: string = process.env.HARVESTING_PRIVATE_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\nconst delegatedAccount = Account.createWithPublicKey(delegateAccountHarvestingPrivateKey);\n\nconst importanceTransferTransaction = ImportanceTransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    ImportanceMode.Activate,\n    PublicAccount.createWithPublicKey(delegatedAccount.publicKey)\n);\n\nconst signedTransaction = account.signTransaction(importanceTransferTransaction);\n\nconst transactionHttp = new TransactionHttp({domain:  104.128.226.60 });\ntransactionHttp.announceTransaction(signedTransaction).subscribe(x =  console.log(x));\n\n// Wait aproximately 6h for you delegated account to be active\n\nconst accountHttp = new AccountHttp({domain:  104.128.226.60 });\n\n// Testnet supernode\nconst supernodeDomain =  188.68.50.161 ;\n\naccountHttp.unlockHarvesting(supernodeDomain, delegateAccountHarvestingPrivateKey).subscribe(success =  console.log(success));  Source code", 
            "title": "How to enable harvesting"
        }, 
        {
            "location": "/guide/transaction/", 
            "text": "How to create a Transfer Transaction\n\n\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM\n} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n),\n    XEM(2),\n    EmptyMessage\n);\n\n\n\n\nSource code\n\n\nHow to sign a Transaction\n\n\nimport {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM\n} from \nnem-library\n;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp({domain: \n104.128.226.60\n});\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n),\n    XEM(2),\n    EmptyMessage\n);\n\nconst signedTransaction = account.signTransaction(transferTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =\n console.log(x));\n\n\n\n\nSource code\n\n\nHow to create a Transfer Transaction with a Message\n\n\n/**\n * nem-library 0.3.0\n */\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow,\n    XEM, PlainMessage\n} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n),\n    XEM(0),\n    PlainMessage.create(\na transaction\n)\n);\n\n\n\n\n\nHow to create a Transfer Transaction with an Encrypted Message\n\n\n/**\n * nem-library 0.3.0\n */\nimport {\n    NEMLibrary, NetworkTypes, Account, TransferTransaction, TimeWindow,\n    TransactionHttp, XEM, PublicAccount\n} from \nnem-library\n;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp({domain: \n104.128.226.60\n});\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst recipientPublicAccount = PublicAccount.createWithPublicKey(\nb254d8b2b00e1b1266eb54a6931cd7c1b0f307e41d9ebb01f025f4933758f0be\n);\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst encryptedMessage = account.encryptMessage(\na transaction\n, recipientPublicAccount);\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    recipientPublicAccount.address,\n    XEM(2),\n    encryptedMessage\n);\n\n\n\n\n\n\nSource code\n\n\nHow to create a MultiSig Transaction\n\n\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, Transaction, XEM\n} from \nnem-library\n;\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\n// Replace with the multisig account\nconst multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY;\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n),\n    XEM(2),\n    EmptyMessage\n);\n\nconst multisigTransaction: MultisigTransaction = MultisigTransaction.create(\n    TimeWindow.createWithDeadline(),\n    transferTransaction,\n    PublicAccount.createWithPublicKey(multisigAccountPublicKey)\n);\n\n\n\n\nSource code\n\n\nHow to filter Transactions by type\n\n\nimport {\n    AccountHttp, Address, MultisigTransaction, NEMLibrary, NetworkTypes, Transaction,\n    TransactionTypes\n} from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.allTransactions(new Address(\nTCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J\n))\n    .map((transactions: Transaction[]): MultisigTransaction[] =\n {\n        console.log(\n);\n        console.log(\nAll Transactions\n, transactions);\n        return \nMultisigTransaction[]\ntransactions.filter(x =\n x.type == TransactionTypes.MULTISIG)\n    })\n    .subscribe((x: MultisigTransaction[]) =\n {\n        console.log(\n\\n\\n\n);\n        console.log(\nJust Multisig\n, x)\n    });\n\n\n\n\nSource code", 
            "title": "Transaction"
        }, 
        {
            "location": "/guide/transaction/#how-to-create-a-transfer-transaction", 
            "text": "import {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM\n} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ),\n    XEM(2),\n    EmptyMessage\n);  Source code", 
            "title": "How to create a Transfer Transaction"
        }, 
        {
            "location": "/guide/transaction/#how-to-sign-a-transaction", 
            "text": "import {\n    AccountHttp, NEMLibrary, NetworkTypes, Address, Account, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, XEM\n} from  nem-library ;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp({domain:  104.128.226.60 });\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ),\n    XEM(2),\n    EmptyMessage\n);\n\nconst signedTransaction = account.signTransaction(transferTransaction);\n\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =  console.log(x));  Source code", 
            "title": "How to sign a Transaction"
        }, 
        {
            "location": "/guide/transaction/#how-to-create-a-transfer-transaction-with-a-message", 
            "text": "/**\n * nem-library 0.3.0\n */\nimport {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, Transaction, TimeWindow,\n    XEM, PlainMessage\n} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ),\n    XEM(0),\n    PlainMessage.create( a transaction )\n);", 
            "title": "How to create a Transfer Transaction with a Message"
        }, 
        {
            "location": "/guide/transaction/#how-to-create-a-transfer-transaction-with-an-encrypted-message", 
            "text": "/**\n * nem-library 0.3.0\n */\nimport {\n    NEMLibrary, NetworkTypes, Account, TransferTransaction, TimeWindow,\n    TransactionHttp, XEM, PublicAccount\n} from  nem-library ;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst transactionHttp = new TransactionHttp({domain:  104.128.226.60 });\n\n// Replace with a cosignatory private key\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst recipientPublicAccount = PublicAccount.createWithPublicKey( b254d8b2b00e1b1266eb54a6931cd7c1b0f307e41d9ebb01f025f4933758f0be );\n\nconst account = Account.createWithPrivateKey(privateKey);\n\nconst encryptedMessage = account.encryptMessage( a transaction , recipientPublicAccount);\nconst transferTransaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    recipientPublicAccount.address,\n    XEM(2),\n    encryptedMessage\n);  Source code", 
            "title": "How to create a Transfer Transaction with an Encrypted Message"
        }, 
        {
            "location": "/guide/transaction/#how-to-create-a-multisig-transaction", 
            "text": "import {\n    NEMLibrary, NetworkTypes, Address, TransferTransaction, TimeWindow,\n    EmptyMessage, MultisigTransaction, PublicAccount, TransactionHttp, Transaction, XEM\n} from  nem-library ;\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\n// Replace with the multisig account\nconst multisigAccountPublicKey: string = process.env.MULTISIG_PUBLIC_KEY;\n\nconst transferTransaction: Transaction = TransferTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ),\n    XEM(2),\n    EmptyMessage\n);\n\nconst multisigTransaction: MultisigTransaction = MultisigTransaction.create(\n    TimeWindow.createWithDeadline(),\n    transferTransaction,\n    PublicAccount.createWithPublicKey(multisigAccountPublicKey)\n);  Source code", 
            "title": "How to create a MultiSig Transaction"
        }, 
        {
            "location": "/guide/transaction/#how-to-filter-transactions-by-type", 
            "text": "import {\n    AccountHttp, Address, MultisigTransaction, NEMLibrary, NetworkTypes, Transaction,\n    TransactionTypes\n} from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst accountHttp = new AccountHttp();\n\naccountHttp.allTransactions(new Address( TCFFOM-Q2SBX7-7E2FZC-3VX43Z-TRV4ZN-TXTCGW-BM5J ))\n    .map((transactions: Transaction[]): MultisigTransaction[] =  {\n        console.log( );\n        console.log( All Transactions , transactions);\n        return  MultisigTransaction[] transactions.filter(x =  x.type == TransactionTypes.MULTISIG)\n    })\n    .subscribe((x: MultisigTransaction[]) =  {\n        console.log( \\n\\n );\n        console.log( Just Multisig , x)\n    });  Source code", 
            "title": "How to filter Transactions by type"
        }, 
        {
            "location": "/guide/namespace/", 
            "text": "How to create a Namespace\n\n\nimport{\n    NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp\n} from \nnem-library\n;\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp({domain: \n104.128.226.60\n});\n\nconst namespace = \nnew-namespace\n;\n\nconst provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create(\n    TimeWindow.createWithDeadline(),\n    namespace\n);\n\nconst signedTransaction = account.signTransaction(provisionNamespaceTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =\n console.log(x));\n\n\n\n\nSource code\n\n\nHow to create a Sub-Namespace\n\n\nimport {\n    NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp\n} from \nnem-library\n;\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp({domain: \n104.128.226.60\n});\n\nconst namespace = \nnew-namespace\n;\nconst subnamespace = \nsubnamespace\n;\n\nconst provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create(\n    TimeWindow.createWithDeadline(),\n    subnamespace,\n    namespace\n);\n\nconst signedTransaction = account.signTransaction(provisionNamespaceTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =\n console.log(x));\n\n\n\n\n\nSource code\n\n\nHow to know if a Namespace exists\n\n\nimport {\n    NEMLibrary, NetworkTypes, NamespaceHttp\n} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp({domain: \n104.128.226.60\n});\nconst namespace = \nnew-namespace\n;\n\nnamespaceHttp.getNamespace(namespace).subscribe(namespace =\n console.log(namespace));\n\n\n\n\nSource code\n\n\nHow to know the owner of a Namespace\n\n\nimport {\n    NEMLibrary, NetworkTypes, NamespaceHttp\n} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp({domain: \n104.128.226.60\n});\nconst namespace = \nnew-namespace\n;\n\nnamespaceHttp.getNamespace(namespace).subscribe(namespace =\n console.log(namespace));\n\n\n\n\n\nSource code", 
            "title": "Namespace"
        }, 
        {
            "location": "/guide/namespace/#how-to-create-a-namespace", 
            "text": "import{\n    NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp\n} from  nem-library ;\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp({domain:  104.128.226.60 });\n\nconst namespace =  new-namespace ;\n\nconst provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create(\n    TimeWindow.createWithDeadline(),\n    namespace\n);\n\nconst signedTransaction = account.signTransaction(provisionNamespaceTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =  console.log(x));  Source code", 
            "title": "How to create a Namespace"
        }, 
        {
            "location": "/guide/namespace/#how-to-create-a-sub-namespace", 
            "text": "import {\n    NEMLibrary, NetworkTypes, Transaction, TimeWindow, ProvisionNamespaceTransaction, Account, TransactionHttp\n} from  nem-library ;\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp({domain:  104.128.226.60 });\n\nconst namespace =  new-namespace ;\nconst subnamespace =  subnamespace ;\n\nconst provisionNamespaceTransaction: Transaction = ProvisionNamespaceTransaction.create(\n    TimeWindow.createWithDeadline(),\n    subnamespace,\n    namespace\n);\n\nconst signedTransaction = account.signTransaction(provisionNamespaceTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =  console.log(x));  Source code", 
            "title": "How to create a Sub-Namespace"
        }, 
        {
            "location": "/guide/namespace/#how-to-know-if-a-namespace-exists", 
            "text": "import {\n    NEMLibrary, NetworkTypes, NamespaceHttp\n} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp({domain:  104.128.226.60 });\nconst namespace =  new-namespace ;\n\nnamespaceHttp.getNamespace(namespace).subscribe(namespace =  console.log(namespace));  Source code", 
            "title": "How to know if a Namespace exists"
        }, 
        {
            "location": "/guide/namespace/#how-to-know-the-owner-of-a-namespace", 
            "text": "import {\n    NEMLibrary, NetworkTypes, NamespaceHttp\n} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst namespaceHttp = new NamespaceHttp({domain:  104.128.226.60 });\nconst namespace =  new-namespace ;\n\nnamespaceHttp.getNamespace(namespace).subscribe(namespace =  console.log(namespace));  Source code", 
            "title": "How to know the owner of a Namespace"
        }, 
        {
            "location": "/guide/mosaic/", 
            "text": "How to create a Mosaic\n\n\nimport {\n    NEMLibrary, NetworkTypes, TimeWindow, Account, TransactionHttp,\n    MosaicDefinitionCreationTransaction, MosaicDefinition, PublicAccount, MosaicId, MosaicProperties, MosaicLevy,\n    MosaicLevyType\n} from \nnem-library\n;\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp({domain: \n104.128.226.60\n});\n\nconst mosaicDefinitionTransaction = MosaicDefinitionCreationTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new MosaicDefinition(\n        PublicAccount.createWithPublicKey(account.publicKey),\n        new MosaicId(\nnew-namespace\n, \nnew-mosaic\n),\n        \nmosaic description\n,\n        new MosaicProperties(0, 9000000, true, true),\n        new MosaicLevy(\n            MosaicLevyType.Percentil,\n            account.address,\n            new MosaicId(\nnem\n, \nxem\n),\n            2\n        )\n    )\n);\n\nconst signedTransaction = account.signTransaction(mosaicDefinitionTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =\n console.log(x));\n\n\n\n\n\nSource code\n\n\nHow to get Namespace Mosaic Definitions\n\n\nimport {\n    NEMLibrary, NetworkTypes, MosaicHttp, TransactionTypes\n} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst mosaicHttp = new MosaicHttp({domain: \n104.128.226.60\n});\nconst namespace = \nnew-namespace\n;\n\nmosaicHttp.getMosaicDefinitions(namespace).subscribe(mosaicDefinitions =\n console.log(mosaicDefinitions));\n\n\n\n\n\nSource code", 
            "title": "Mosaic"
        }, 
        {
            "location": "/guide/mosaic/#how-to-create-a-mosaic", 
            "text": "import {\n    NEMLibrary, NetworkTypes, TimeWindow, Account, TransactionHttp,\n    MosaicDefinitionCreationTransaction, MosaicDefinition, PublicAccount, MosaicId, MosaicProperties, MosaicLevy,\n    MosaicLevyType\n} from  nem-library ;\n\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\nconst account = Account.createWithPrivateKey(privateKey);\nconst transactionHttp = new TransactionHttp({domain:  104.128.226.60 });\n\nconst mosaicDefinitionTransaction = MosaicDefinitionCreationTransaction.create(\n    TimeWindow.createWithDeadline(),\n    new MosaicDefinition(\n        PublicAccount.createWithPublicKey(account.publicKey),\n        new MosaicId( new-namespace ,  new-mosaic ),\n         mosaic description ,\n        new MosaicProperties(0, 9000000, true, true),\n        new MosaicLevy(\n            MosaicLevyType.Percentil,\n            account.address,\n            new MosaicId( nem ,  xem ),\n            2\n        )\n    )\n);\n\nconst signedTransaction = account.signTransaction(mosaicDefinitionTransaction);\ntransactionHttp.announceTransaction(signedTransaction).subscribe( x =  console.log(x));  Source code", 
            "title": "How to create a Mosaic"
        }, 
        {
            "location": "/guide/mosaic/#how-to-get-namespace-mosaic-definitions", 
            "text": "import {\n    NEMLibrary, NetworkTypes, MosaicHttp, TransactionTypes\n} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst mosaicHttp = new MosaicHttp({domain:  104.128.226.60 });\nconst namespace =  new-namespace ;\n\nmosaicHttp.getMosaicDefinitions(namespace).subscribe(mosaicDefinitions =  console.log(mosaicDefinitions));  Source code", 
            "title": "How to get Namespace Mosaic Definitions"
        }, 
        {
            "location": "/guide/node/", 
            "text": "How to get NEM Node information\n\n\nimport {NEMLibrary, NetworkTypes, NodeHttp} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp({domain: \n104.128.226.60\n});\nnodeHttp.getNodeInfo().subscribe(node =\n console.log(node));\n\n\n\n\n\nSource code\n\n\nHow to get extended information about a NEM Node\n\n\nimport {NEMLibrary, NetworkTypes, NodeHttp} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp({domain: \n104.128.226.60\n});\nnodeHttp.getNisNodeInfo().subscribe(nisNodeInfo =\n console.log(nisNodeInfo));\n\n\n\n\nSource code\n\n\nHow to get all active nodes\n\n\nimport {NEMLibrary, NetworkTypes, NodeHttp} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp({domain: \n104.128.226.60\n});\nnodeHttp.getActiveNodes().subscribe(nodes =\n console.log(nodes));\n\n\n\n\nSource code", 
            "title": "Node"
        }, 
        {
            "location": "/guide/node/#how-to-get-nem-node-information", 
            "text": "import {NEMLibrary, NetworkTypes, NodeHttp} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp({domain:  104.128.226.60 });\nnodeHttp.getNodeInfo().subscribe(node =  console.log(node));  Source code", 
            "title": "How to get NEM Node information"
        }, 
        {
            "location": "/guide/node/#how-to-get-extended-information-about-a-nem-node", 
            "text": "import {NEMLibrary, NetworkTypes, NodeHttp} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp({domain:  104.128.226.60 });\nnodeHttp.getNisNodeInfo().subscribe(nisNodeInfo =  console.log(nisNodeInfo));  Source code", 
            "title": "How to get extended information about a NEM Node"
        }, 
        {
            "location": "/guide/node/#how-to-get-all-active-nodes", 
            "text": "import {NEMLibrary, NetworkTypes, NodeHttp} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst nodeHttp = new NodeHttp({domain:  104.128.226.60 });\nnodeHttp.getActiveNodes().subscribe(nodes =  console.log(nodes));  Source code", 
            "title": "How to get all active nodes"
        }, 
        {
            "location": "/guide/blockchain/", 
            "text": "Blockchain\n\n\nHow to get a Block by Height\n\n\nimport {BlockHttp, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst blockHttp = new BlockHttp({domain: \n104.128.226.60\n});\nblockHttp.getBlockByHeight(1033023).subscribe(block =\n {\n    console.log(block);\n});\n\n\n\n\nSource code\n\n\nHow to get Last block of the blockchain\n\n\nimport {ChainHttp, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst chainHttp = new ChainHttp({domain: \n104.128.226.60\n});\nchainHttp.getBlockchainLastBlock().subscribe(block =\n {\n    console.log(block);\n});\n\n\n\n\nSource code", 
            "title": "Blockchain"
        }, 
        {
            "location": "/guide/blockchain/#blockchain", 
            "text": "", 
            "title": "Blockchain"
        }, 
        {
            "location": "/guide/blockchain/#how-to-get-a-block-by-height", 
            "text": "import {BlockHttp, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst blockHttp = new BlockHttp({domain:  104.128.226.60 });\nblockHttp.getBlockByHeight(1033023).subscribe(block =  {\n    console.log(block);\n});  Source code", 
            "title": "How to get a Block by Height"
        }, 
        {
            "location": "/guide/blockchain/#how-to-get-last-block-of-the-blockchain", 
            "text": "import {ChainHttp, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst chainHttp = new ChainHttp({domain:  104.128.226.60 });\nchainHttp.getBlockchainLastBlock().subscribe(block =  {\n    console.log(block);\n});  Source code", 
            "title": "How to get Last block of the blockchain"
        }, 
        {
            "location": "/guide/listener/", 
            "text": "How to create a listener for account information\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {AccountListener, Address, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\nTCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA\n);\nlet accountListener = new AccountListener({domain: \n23.228.67.85\n}).given(address).subscribe(x =\n {\n    console.log(x);\n}, err =\n {\n    console.log(err);\n});\n\n\n\n\n\n\n\nSource code\n\n\nHow to create a listener for new blocks information\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {BlockchainListener, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet blockchainListener = new BlockchainListener({domain: \n23.228.67.85\n}).newBlock().subscribe(x =\n {\n    console.log(x);\n}, err =\n {\n    console.log(err);\n});\n\n\n\n\n\n\nSource code\n\n\nHow to create a listener for new blockchain height information\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {BlockchainListener, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet blockchainListener = new BlockchainListener({domain: \n23.228.67.85\n}).newHeight().subscribe(x =\n {\n    console.log(x);\n}, err =\n {\n    console.log(err);\n});\n\n\n\n\n\n\nSource code\n\n\nHow to create a listener for unconfirmed transactions information\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {Address, NEMLibrary, NetworkTypes, UnconfirmedTransactionListener} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\nTDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\n);\n\nlet unconfirmedTransactionListener = new UnconfirmedTransactionListener({domain: \n23.228.67.85\n}).given(address).subscribe(x =\n {\n    console.log(x);\n}, err =\n {\n    console.log(err);\n});\n\n\n\n\nSource code\n\n\nHow to create a listener for confirmed transactions information\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {Address, ConfirmedTransactionListener, NEMLibrary, NetworkTypes} from \nnem-library\n;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address(\nTDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K\n);\n\nlet confirmedTransactionListener = new ConfirmedTransactionListener({domain: \n23.228.67.85\n}).given(address).subscribe(x =\n {\n    console.log(x);\n}, err =\n {\n    console.log(err);\n});\n\n\n\n\nSource code", 
            "title": "Listener"
        }, 
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-account-information", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {AccountListener, Address, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address( TCJZJH-AV63RE-2JSKN2-7DFIHZ-RXIHAI-736WXE-OJGA );\nlet accountListener = new AccountListener({domain:  23.228.67.85 }).given(address).subscribe(x =  {\n    console.log(x);\n}, err =  {\n    console.log(err);\n});  Source code", 
            "title": "How to create a listener for account information"
        }, 
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-new-blocks-information", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {BlockchainListener, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet blockchainListener = new BlockchainListener({domain:  23.228.67.85 }).newBlock().subscribe(x =  {\n    console.log(x);\n}, err =  {\n    console.log(err);\n});  Source code", 
            "title": "How to create a listener for new blocks information"
        }, 
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-new-blockchain-height-information", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {BlockchainListener, NEMLibrary, NetworkTypes} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nlet blockchainListener = new BlockchainListener({domain:  23.228.67.85 }).newHeight().subscribe(x =  {\n    console.log(x);\n}, err =  {\n    console.log(err);\n});  Source code", 
            "title": "How to create a listener for new blockchain height information"
        }, 
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-unconfirmed-transactions-information", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {Address, NEMLibrary, NetworkTypes, UnconfirmedTransactionListener} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address( TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K );\n\nlet unconfirmedTransactionListener = new UnconfirmedTransactionListener({domain:  23.228.67.85 }).given(address).subscribe(x =  {\n    console.log(x);\n}, err =  {\n    console.log(err);\n});  Source code", 
            "title": "How to create a listener for unconfirmed transactions information"
        }, 
        {
            "location": "/guide/listener/#how-to-create-a-listener-for-confirmed-transactions-information", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {Address, ConfirmedTransactionListener, NEMLibrary, NetworkTypes} from  nem-library ;\n\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst address = new Address( TDM3DO-ZM5WJ3-ZRBPSM-YRU6JS-WKUCAH-5VIPOF-4W7K );\n\nlet confirmedTransactionListener = new ConfirmedTransactionListener({domain:  23.228.67.85 }).given(address).subscribe(x =  {\n    console.log(x);\n}, err =  {\n    console.log(err);\n});  Source code", 
            "title": "How to create a listener for confirmed transactions information"
        }, 
        {
            "location": "/guide/wallet/", 
            "text": "How to create a Simple Wallet\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst password = new Password(\npassword\n);\nconst simpleWallet = SimpleWallet.create(\nsimple wallet\n, password);\n\n\n\n\nSource code\n\n\nHow to create a Brain Wallet\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from \nnem-library\n;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst brainPassword =  new BrainPassword(\nentertain destruction sassy impartial morning electric limit glib bait grape icy measure\n)\nconst brainWallet = BrainWallet.create(\nbrain wallet\n, brainPassword);\n\n\n\n\nSource code\n\n\nHow to create a Simple Wallet from a private key\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \nnem-library\n;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\n\n\nconst password = new Password(\npassword\n);\nconst simpleWallet = SimpleWallet.createWithPrivateKey(\nsimple wallet\n, password, privateKey);\n\n\n\n\nSource code\n\n\nHow to open a Wallet\n\n\n/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from \nnem-library\n;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\n\n\nconst password = new Password(\npassword\n);\nconst simpleWallet = SimpleWallet.createWithPrivateKey(\nsimple wallet\n, password, privateKey);\nconst account = simpleWallet.open(password);\n\n\n\n\nSource code", 
            "title": "Wallet"
        }, 
        {
            "location": "/guide/wallet/#how-to-create-a-simple-wallet", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst password = new Password( password );\nconst simpleWallet = SimpleWallet.create( simple wallet , password);  Source code", 
            "title": "How to create a Simple Wallet"
        }, 
        {
            "location": "/guide/wallet/#how-to-create-a-brain-wallet", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {BrainWallet, BrainPassword, NetworkTypes, NEMLibrary} from  nem-library ;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst brainPassword =  new BrainPassword( entertain destruction sassy impartial morning electric limit glib bait grape icy measure )\nconst brainWallet = BrainWallet.create( brain wallet , brainPassword);  Source code", 
            "title": "How to create a Brain Wallet"
        }, 
        {
            "location": "/guide/wallet/#how-to-create-a-simple-wallet-from-a-private-key", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from  nem-library ;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\n\n\nconst password = new Password( password );\nconst simpleWallet = SimpleWallet.createWithPrivateKey( simple wallet , password, privateKey);  Source code", 
            "title": "How to create a Simple Wallet from a private key"
        }, 
        {
            "location": "/guide/wallet/#how-to-open-a-wallet", 
            "text": "/**\n * nem-library 0.3.0\n */\n\nimport {SimpleWallet, Password, NetworkTypes, NEMLibrary} from  nem-library ;\ndeclare let process: any;\n\n// Initialize NEMLibrary for TEST_NET Network\nNEMLibrary.bootstrap(NetworkTypes.TEST_NET);\n\nconst privateKey: string = process.env.PRIVATE_KEY;\n\n\nconst password = new Password( password );\nconst simpleWallet = SimpleWallet.createWithPrivateKey( simple wallet , password, privateKey);\nconst account = simpleWallet.open(password);  Source code", 
            "title": "How to open a Wallet"
        }, 
        {
            "location": "/support/", 
            "text": "Bug reports\n\n\nIf you think you have found a bug in NEM Library, first make sure that you \nare testing against the latest version of NEM Library - your issue may already \nhave been fixed. If not, search our issues list on GitHub in case a similar \nissue has already been opened.\n\n\nIt is very helpful if you can prepare a reproduction of the bug. In other words, \nprovide a small test case which we can run to confirm your bug. It makes it easier to \nfind the problem and to fix it.\n\n\nPlease, take in consideration the next template to report your issue:\n\n\n\n\nExpected Behaviour\n\n\nShort and expressive sentence explaining what the code should do.\n\n\nCurrent Behaviour\n\n\nA short sentence enplaning what the code does.\n\n\nSteps to reproduce\n\n\nFor faster issue detection, we would need a step by step description do reproduce the issue.\n\n\n\n\nProvide as much information as you can.\n\n\nOpen a new issue \nhere\n.\n\n\nFeature requests\n\n\nIf you find yourself wishing for a feature that doesn't exist in NEM Library, \nyou are probably not alone. There are bound to be others out there with similar \nneeds. Many of the features that NEM Library has today have been added because \nour users saw the need. Open an \nissue\n on our issues list on GitHub which describes \nthe feature you would like to see, why you need it, and how it should work.\n\n\nJoin the development discussion\n\n\nWe love to listen your thoughts about NEM Library, you can find us in \nGitter\n or checkout our \nAbout section", 
            "title": "Support"
        }, 
        {
            "location": "/support/#bug-reports", 
            "text": "If you think you have found a bug in NEM Library, first make sure that you \nare testing against the latest version of NEM Library - your issue may already \nhave been fixed. If not, search our issues list on GitHub in case a similar \nissue has already been opened.  It is very helpful if you can prepare a reproduction of the bug. In other words, \nprovide a small test case which we can run to confirm your bug. It makes it easier to \nfind the problem and to fix it.  Please, take in consideration the next template to report your issue:   Expected Behaviour  Short and expressive sentence explaining what the code should do.  Current Behaviour  A short sentence enplaning what the code does.  Steps to reproduce  For faster issue detection, we would need a step by step description do reproduce the issue.   Provide as much information as you can.", 
            "title": "Bug reports"
        }, 
        {
            "location": "/support/#open-a-new-issue-here", 
            "text": "", 
            "title": "Open a new issue here."
        }, 
        {
            "location": "/support/#feature-requests", 
            "text": "If you find yourself wishing for a feature that doesn't exist in NEM Library, \nyou are probably not alone. There are bound to be others out there with similar \nneeds. Many of the features that NEM Library has today have been added because \nour users saw the need. Open an  issue  on our issues list on GitHub which describes \nthe feature you would like to see, why you need it, and how it should work.", 
            "title": "Feature requests"
        }, 
        {
            "location": "/support/#join-the-development-discussion", 
            "text": "We love to listen your thoughts about NEM Library, you can find us in  Gitter  or checkout our  About section", 
            "title": "Join the development discussion"
        }, 
        {
            "location": "/internal_development_process/", 
            "text": "Agile\n\n\nNEM Library is developed following the \nAgile Manifesto\n\u2019s values:\n\n\n\n\nIndividuals and interactions over processes and tools\n\n\nWorking software over extensive documentation\n\n\nCustomer collaboration over contract negotiation\n\n\nResponding to change over following the plan\n\n\n\n\nDevelopment Methodology\n\n\nNEM Library is developed applying \nTest-Driven Development\n and \n\neXtreme Programming\n.", 
            "title": "Internal Development Process"
        }, 
        {
            "location": "/internal_development_process/#agile", 
            "text": "NEM Library is developed following the  Agile Manifesto \u2019s values:   Individuals and interactions over processes and tools  Working software over extensive documentation  Customer collaboration over contract negotiation  Responding to change over following the plan", 
            "title": "Agile"
        }, 
        {
            "location": "/internal_development_process/#development-methodology", 
            "text": "NEM Library is developed applying  Test-Driven Development  and  eXtreme Programming .", 
            "title": "Development Methodology"
        }, 
        {
            "location": "/roadmap/", 
            "text": "Roadmap\n\n\n0.1\n\n\n\n\n[X] AccountHttp\n\n\n[X] TransactionHttp\n\n\n[X] Immutable data interfaces \n\n\n[X] Client side signature\n\n\n\n\n0.2 Stable\n\n\nWARNING!\n This version has not compatibility with 0.1\n\n\n\n\n[X] Model transactions\n\n\n[X] Endpoints return immutable models instead of immutable interfaces\n\n\n[X] BlockchainHttp\n\n\n[X] NodeHttp\n\n\n[X] NamespaceHttp\n\n\n[X] MosaicHttp\n\n\n[X] Documentation\n\n\n[X] TransactionFees\n\n\n\n\n0.3 Under development\n\n\n\n\n[ ] WebSocket support\n\n\n[ ] Listeners\n\n\n[ ] Wallet\n\n\n[ ] Persistent Wallet\n\n\n\n\n0.4\n\n\n\n\n[ ] Error handling\n\n\n[ ] Connection pool\n\n\n[ ] Node Type Connection\n\n\n\n\n0.5\n\n\n\n\n[ ] High Order Filter Functions\n\n\n[ ] High Order Data Transformation Functions\n\n\n\n\n0.6\n\n\n\n\n[ ] Concurrent data fetching\n\n\n[ ] Error handling strategies", 
            "title": "Roadmap"
        }, 
        {
            "location": "/roadmap/#roadmap", 
            "text": "", 
            "title": "Roadmap"
        }, 
        {
            "location": "/roadmap/#01", 
            "text": "[X] AccountHttp  [X] TransactionHttp  [X] Immutable data interfaces   [X] Client side signature", 
            "title": "0.1"
        }, 
        {
            "location": "/roadmap/#02-stable", 
            "text": "WARNING!  This version has not compatibility with 0.1   [X] Model transactions  [X] Endpoints return immutable models instead of immutable interfaces  [X] BlockchainHttp  [X] NodeHttp  [X] NamespaceHttp  [X] MosaicHttp  [X] Documentation  [X] TransactionFees", 
            "title": "0.2 Stable"
        }, 
        {
            "location": "/roadmap/#03-under-development", 
            "text": "[ ] WebSocket support  [ ] Listeners  [ ] Wallet  [ ] Persistent Wallet", 
            "title": "0.3 Under development"
        }, 
        {
            "location": "/roadmap/#04", 
            "text": "[ ] Error handling  [ ] Connection pool  [ ] Node Type Connection", 
            "title": "0.4"
        }, 
        {
            "location": "/roadmap/#05", 
            "text": "[ ] High Order Filter Functions  [ ] High Order Data Transformation Functions", 
            "title": "0.5"
        }, 
        {
            "location": "/roadmap/#06", 
            "text": "[ ] Concurrent data fetching  [ ] Error handling strategies", 
            "title": "0.6"
        }, 
        {
            "location": "/about/", 
            "text": "About NEM Library\n\n\nThe origin of NEM Library is the need of a new development approach for enterprise\nready solutions build on top of \nNEM Blockchain\n.\n\n\nThe characteristics of NEM Library are similar to \nNEM Framework\n definition, but\nNEM Library has not the same roadmap or scope as described in NEM Framework document. So, NEM Library future is guided\nby the needs of the NEM Library usage and products build on top of it.\n\n\nNEM Library is developed independently of any institution by \nGuillem\n and \nAleix\n.\n\n\nFollow us on our social networks!\n\n\n\n\nGuillem: \nTwitter\n, \nGitHub\n Email; guillemchain at gmail.com\n\n\nAleix: \nTwitter\n, \nGitHub\n, \nMedium\n, Email; aleix602 at gmail.com", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-nem-library", 
            "text": "The origin of NEM Library is the need of a new development approach for enterprise\nready solutions build on top of  NEM Blockchain .  The characteristics of NEM Library are similar to  NEM Framework  definition, but\nNEM Library has not the same roadmap or scope as described in NEM Framework document. So, NEM Library future is guided\nby the needs of the NEM Library usage and products build on top of it.  NEM Library is developed independently of any institution by  Guillem  and  Aleix .  Follow us on our social networks!   Guillem:  Twitter ,  GitHub  Email; guillemchain at gmail.com  Aleix:  Twitter ,  GitHub ,  Medium , Email; aleix602 at gmail.com", 
            "title": "About NEM Library"
        }
    ]
}